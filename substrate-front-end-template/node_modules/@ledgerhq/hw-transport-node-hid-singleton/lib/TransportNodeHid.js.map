{"version":3,"sources":["../src/TransportNodeHid.js"],"names":["transportInstance","TransportNodeHidSingleton","TransportNodeHidNoEvents","disconnect","device","close","emit","open","Promise","resolve","then","CantOpenDevice","HID","path","unlisten","onDisconnect","off","on","isSupported","list","listen","observer","unsubscribed","devices","deviceModel","productId","next","type","descriptor","name","deviceName","onAdd","onRemove","stop","unsubscribe"],"mappings":"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","sourcesContent":["//@flow\n\nimport HID from \"node-hid\";\nimport TransportNodeHidNoEvents, {\n  getDevices,\n} from \"@ledgerhq/hw-transport-node-hid-noevents\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription,\n} from \"@ledgerhq/hw-transport\";\nimport { log } from \"@ledgerhq/logs\";\nimport { identifyUSBProductId } from \"@ledgerhq/devices\";\nimport { CantOpenDevice } from \"@ledgerhq/errors\";\nimport { listenDevices } from \"./listenDevices\";\n\nlet transportInstance;\n\n/**\n * node-hid Transport implementation\n * @example\n * import TransportNodeHid from \"@ledgerhq/hw-transport-node-hid-singleton\";\n * ...\n * TransportNodeHid.create().then(transport => ...)\n */\nexport default class TransportNodeHidSingleton extends TransportNodeHidNoEvents {\n  /**\n   *\n   */\n  static isSupported = TransportNodeHidNoEvents.isSupported;\n\n  /**\n   *\n   */\n  static list = TransportNodeHidNoEvents.list;\n\n  /**\n   */\n  static listen = (observer: Observer<DescriptorEvent<*>>): Subscription => {\n    let unsubscribed;\n    Promise.resolve(getDevices()).then((devices) => {\n      // this needs to run asynchronously so the subscription is defined during this phase\n      for (const device of devices) {\n        if (!unsubscribed) {\n          const deviceModel = identifyUSBProductId(device.productId);\n          observer.next({\n            type: \"add\",\n            descriptor: \"\",\n            device: { name: device.deviceName },\n            deviceModel,\n          });\n        }\n      }\n    });\n\n    const onAdd = (device) => {\n      const deviceModel = identifyUSBProductId(device.productId);\n      observer.next({\n        type: \"add\",\n        descriptor: \"\",\n        deviceModel,\n        device: { name: device.deviceName },\n      });\n    };\n\n    const onRemove = (device) => {\n      const deviceModel = identifyUSBProductId(device.productId);\n      observer.next({\n        type: \"remove\",\n        descriptor: \"\",\n        deviceModel,\n        device: { name: device.deviceName },\n      });\n    };\n\n    const stop = listenDevices(onAdd, onRemove);\n\n    function unsubscribe() {\n      stop();\n      unsubscribed = true;\n    }\n    return { unsubscribe };\n  };\n\n  /**\n   * globally disconnect the transport singleton\n   */\n  static async disconnect() {\n    if (transportInstance) {\n      transportInstance.device.close();\n      transportInstance.emit(\"disconnect\");\n      transportInstance = null;\n    }\n  }\n\n  /**\n   * if path=\"\" is not provided, the library will take the first device\n   */\n  static open(): Promise<TransportNodeHidSingleton> {\n    return Promise.resolve().then(() => {\n      if (transportInstance) {\n        log(\"hid-verbose\", \"reusing opened transport instance\");\n        return transportInstance;\n      }\n\n      const device = getDevices()[0];\n      if (!device) throw new CantOpenDevice(\"no device found\");\n      log(\"hid-verbose\", \"new HID transport\");\n      transportInstance = new TransportNodeHidSingleton(\n        new HID.HID(device.path)\n      );\n      const unlisten = listenDevices(\n        () => {},\n        () => {\n          // assume any ledger disconnection concerns current transport\n          if (transportInstance) {\n            transportInstance.emit(\"disconnect\");\n          }\n        }\n      );\n      const onDisconnect = () => {\n        if (!transportInstance) return;\n        log(\"hid-verbose\", \"transport instance was disconnected\");\n        transportInstance.off(\"disconnect\", onDisconnect);\n        transportInstance = null;\n        unlisten();\n      };\n      transportInstance.on(\"disconnect\", onDisconnect);\n\n      return transportInstance;\n    });\n  }\n\n  close() {\n    // intentionally, a close will not effectively close the hid connection\n    return Promise.resolve();\n  }\n}\n"],"file":"TransportNodeHid.js"}