{"version":3,"sources":["../src/TransportNodeHid.js"],"names":["HID","TransportNodeHidNoEvents","getDevices","log","identifyUSBProductId","CantOpenDevice","listenDevices","transportInstance","TransportNodeHidSingleton","disconnect","device","close","emit","open","Promise","resolve","then","path","unlisten","onDisconnect","off","on","isSupported","list","listen","observer","unsubscribed","devices","deviceModel","productId","next","type","descriptor","name","deviceName","onAdd","onRemove","stop","unsubscribe"],"mappings":"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","sourcesContent":["//@flow\n\nimport HID from \"node-hid\";\nimport TransportNodeHidNoEvents, {\n  getDevices,\n} from \"@ledgerhq/hw-transport-node-hid-noevents\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription,\n} from \"@ledgerhq/hw-transport\";\nimport { log } from \"@ledgerhq/logs\";\nimport { identifyUSBProductId } from \"@ledgerhq/devices\";\nimport { CantOpenDevice } from \"@ledgerhq/errors\";\nimport { listenDevices } from \"./listenDevices\";\n\nlet transportInstance;\n\n/**\n * node-hid Transport implementation\n * @example\n * import TransportNodeHid from \"@ledgerhq/hw-transport-node-hid-singleton\";\n * ...\n * TransportNodeHid.create().then(transport => ...)\n */\nexport default class TransportNodeHidSingleton extends TransportNodeHidNoEvents {\n  /**\n   *\n   */\n  static isSupported = TransportNodeHidNoEvents.isSupported;\n\n  /**\n   *\n   */\n  static list = TransportNodeHidNoEvents.list;\n\n  /**\n   */\n  static listen = (observer: Observer<DescriptorEvent<*>>): Subscription => {\n    let unsubscribed;\n    Promise.resolve(getDevices()).then((devices) => {\n      // this needs to run asynchronously so the subscription is defined during this phase\n      for (const device of devices) {\n        if (!unsubscribed) {\n          const deviceModel = identifyUSBProductId(device.productId);\n          observer.next({\n            type: \"add\",\n            descriptor: \"\",\n            device: { name: device.deviceName },\n            deviceModel,\n          });\n        }\n      }\n    });\n\n    const onAdd = (device) => {\n      const deviceModel = identifyUSBProductId(device.productId);\n      observer.next({\n        type: \"add\",\n        descriptor: \"\",\n        deviceModel,\n        device: { name: device.deviceName },\n      });\n    };\n\n    const onRemove = (device) => {\n      const deviceModel = identifyUSBProductId(device.productId);\n      observer.next({\n        type: \"remove\",\n        descriptor: \"\",\n        deviceModel,\n        device: { name: device.deviceName },\n      });\n    };\n\n    const stop = listenDevices(onAdd, onRemove);\n\n    function unsubscribe() {\n      stop();\n      unsubscribed = true;\n    }\n    return { unsubscribe };\n  };\n\n  /**\n   * globally disconnect the transport singleton\n   */\n  static async disconnect() {\n    if (transportInstance) {\n      transportInstance.device.close();\n      transportInstance.emit(\"disconnect\");\n      transportInstance = null;\n    }\n  }\n\n  /**\n   * if path=\"\" is not provided, the library will take the first device\n   */\n  static open(): Promise<TransportNodeHidSingleton> {\n    return Promise.resolve().then(() => {\n      if (transportInstance) {\n        log(\"hid-verbose\", \"reusing opened transport instance\");\n        return transportInstance;\n      }\n\n      const device = getDevices()[0];\n      if (!device) throw new CantOpenDevice(\"no device found\");\n      log(\"hid-verbose\", \"new HID transport\");\n      transportInstance = new TransportNodeHidSingleton(\n        new HID.HID(device.path)\n      );\n      const unlisten = listenDevices(\n        () => {},\n        () => {\n          // assume any ledger disconnection concerns current transport\n          if (transportInstance) {\n            transportInstance.emit(\"disconnect\");\n          }\n        }\n      );\n      const onDisconnect = () => {\n        if (!transportInstance) return;\n        log(\"hid-verbose\", \"transport instance was disconnected\");\n        transportInstance.off(\"disconnect\", onDisconnect);\n        transportInstance = null;\n        unlisten();\n      };\n      transportInstance.on(\"disconnect\", onDisconnect);\n\n      return transportInstance;\n    });\n  }\n\n  close() {\n    // intentionally, a close will not effectively close the hid connection\n    return Promise.resolve();\n  }\n}\n"],"file":"TransportNodeHid.js"}