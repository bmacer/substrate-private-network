{"ast":null,"code":"// Copyright 2017-2021 @polkadot/metadata authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { logger } from '@polkadot/util';\nimport { extractTypes } from \"./extractTypes.mjs\";\nimport { flattenUniq } from \"./flattenUniq.mjs\";\nconst l = logger('metadata');\n/** @internal */\n\nexport function validateTypes(registry, types, throwError) {\n  const missing = flattenUniq(extractTypes(types)).filter(type => !registry.hasType(type));\n\n  if (missing.length !== 0) {\n    const message = `Unknown types found, no types for ${missing.join(', ')}`;\n\n    if (throwError) {\n      throw new Error(message);\n    } else {\n      l.warn(message);\n    }\n  }\n}","map":{"version":3,"sources":["/Users/bmacer/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/metadata/util/validateTypes.mjs"],"names":["logger","extractTypes","flattenUniq","l","validateTypes","registry","types","throwError","missing","filter","type","hasType","length","message","join","Error","warn"],"mappings":"AAAA;AACA;AACA,SAASA,MAAT,QAAuB,gBAAvB;AACA,SAASC,YAAT,QAA6B,oBAA7B;AACA,SAASC,WAAT,QAA4B,mBAA5B;AACA,MAAMC,CAAC,GAAGH,MAAM,CAAC,UAAD,CAAhB;AACA;;AAEA,OAAO,SAASI,aAAT,CAAuBC,QAAvB,EAAiCC,KAAjC,EAAwCC,UAAxC,EAAoD;AACzD,QAAMC,OAAO,GAAGN,WAAW,CAACD,YAAY,CAACK,KAAD,CAAb,CAAX,CAAiCG,MAAjC,CAAwCC,IAAI,IAAI,CAACL,QAAQ,CAACM,OAAT,CAAiBD,IAAjB,CAAjD,CAAhB;;AAEA,MAAIF,OAAO,CAACI,MAAR,KAAmB,CAAvB,EAA0B;AACxB,UAAMC,OAAO,GAAI,qCAAoCL,OAAO,CAACM,IAAR,CAAa,IAAb,CAAmB,EAAxE;;AAEA,QAAIP,UAAJ,EAAgB;AACd,YAAM,IAAIQ,KAAJ,CAAUF,OAAV,CAAN;AACD,KAFD,MAEO;AACLV,MAAAA,CAAC,CAACa,IAAF,CAAOH,OAAP;AACD;AACF;AACF","sourcesContent":["// Copyright 2017-2021 @polkadot/metadata authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { logger } from '@polkadot/util';\nimport { extractTypes } from \"./extractTypes.mjs\";\nimport { flattenUniq } from \"./flattenUniq.mjs\";\nconst l = logger('metadata');\n/** @internal */\n\nexport function validateTypes(registry, types, throwError) {\n  const missing = flattenUniq(extractTypes(types)).filter(type => !registry.hasType(type));\n\n  if (missing.length !== 0) {\n    const message = `Unknown types found, no types for ${missing.join(', ')}`;\n\n    if (throwError) {\n      throw new Error(message);\n    } else {\n      l.warn(message);\n    }\n  }\n}"]},"metadata":{},"sourceType":"module"}