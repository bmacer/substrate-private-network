{"ast":null,"code":"// Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { isFunction } from '@polkadot/util';\nimport { combineLatest, of } from '@polkadot/x-rxjs';\nimport { catchError, map, switchMap } from '@polkadot/x-rxjs/operators';\nimport { memo } from \"../util/index.mjs\";\n\nfunction parse(api, [hashes, proposals, votes]) {\n  return proposals.map((proposalOpt, index) => proposalOpt && proposalOpt.isSome ? {\n    hash: api.registry.createType('Hash', hashes[index]),\n    proposal: proposalOpt.unwrap(),\n    votes: votes[index].unwrapOr(null)\n  } : null).filter(proposal => !!proposal);\n}\n\nfunction _proposalsFrom(instanceId, api, section = 'council') {\n  return memo(instanceId, hashes => {\n    var _api$query$section;\n\n    return (isFunction((_api$query$section = api.query[section]) === null || _api$query$section === void 0 ? void 0 : _api$query$section.proposals) && hashes.length ? combineLatest([of(hashes), combineLatest(hashes.map(hash => // this should simply be api.query[section].proposalOf.multi<Option<Proposal>>(hashes),\n    // however we have had cases on Edgeware where the indices have moved around after an\n    // upgrade, which results in invalid on-chain data\n    api.query[section].proposalOf(hash).pipe(catchError(() => of(null))))), api.query[section].voting.multi(hashes)]) : of([[], [], []])).pipe(map(result => parse(api, result)));\n  });\n}\n\nexport function proposals(instanceId, api, section = 'council') {\n  const proposalsFrom = _proposalsFrom(instanceId, api, section);\n\n  return memo(instanceId, () => {\n    var _api$query$section2;\n\n    return isFunction((_api$query$section2 = api.query[section]) === null || _api$query$section2 === void 0 ? void 0 : _api$query$section2.proposals) ? api.query[section].proposals().pipe(switchMap(proposalsFrom)) : of([]);\n  });\n}\nexport function proposal(instanceId, api, section = 'council') {\n  const proposalsFrom = _proposalsFrom(instanceId, api, section);\n\n  return memo(instanceId, hash => {\n    var _api$query$section3;\n\n    return isFunction((_api$query$section3 = api.query[section]) === null || _api$query$section3 === void 0 ? void 0 : _api$query$section3.proposals) ? proposalsFrom([hash]).pipe(map(([proposal]) => proposal)) : of(null);\n  });\n}","map":{"version":3,"sources":["/Users/bmacer/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/api-derive/collective/proposals.mjs"],"names":["isFunction","combineLatest","of","catchError","map","switchMap","memo","parse","api","hashes","proposals","votes","proposalOpt","index","isSome","hash","registry","createType","proposal","unwrap","unwrapOr","filter","_proposalsFrom","instanceId","section","_api$query$section","query","length","proposalOf","pipe","voting","multi","result","proposalsFrom","_api$query$section2","_api$query$section3"],"mappings":"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","sourcesContent":["// Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { isFunction } from '@polkadot/util';\nimport { combineLatest, of } from '@polkadot/x-rxjs';\nimport { catchError, map, switchMap } from '@polkadot/x-rxjs/operators';\nimport { memo } from \"../util/index.mjs\";\n\nfunction parse(api, [hashes, proposals, votes]) {\n  return proposals.map((proposalOpt, index) => proposalOpt && proposalOpt.isSome ? {\n    hash: api.registry.createType('Hash', hashes[index]),\n    proposal: proposalOpt.unwrap(),\n    votes: votes[index].unwrapOr(null)\n  } : null).filter(proposal => !!proposal);\n}\n\nfunction _proposalsFrom(instanceId, api, section = 'council') {\n  return memo(instanceId, hashes => {\n    var _api$query$section;\n\n    return (isFunction((_api$query$section = api.query[section]) === null || _api$query$section === void 0 ? void 0 : _api$query$section.proposals) && hashes.length ? combineLatest([of(hashes), combineLatest(hashes.map(hash => // this should simply be api.query[section].proposalOf.multi<Option<Proposal>>(hashes),\n    // however we have had cases on Edgeware where the indices have moved around after an\n    // upgrade, which results in invalid on-chain data\n    api.query[section].proposalOf(hash).pipe(catchError(() => of(null))))), api.query[section].voting.multi(hashes)]) : of([[], [], []])).pipe(map(result => parse(api, result)));\n  });\n}\n\nexport function proposals(instanceId, api, section = 'council') {\n  const proposalsFrom = _proposalsFrom(instanceId, api, section);\n\n  return memo(instanceId, () => {\n    var _api$query$section2;\n\n    return isFunction((_api$query$section2 = api.query[section]) === null || _api$query$section2 === void 0 ? void 0 : _api$query$section2.proposals) ? api.query[section].proposals().pipe(switchMap(proposalsFrom)) : of([]);\n  });\n}\nexport function proposal(instanceId, api, section = 'council') {\n  const proposalsFrom = _proposalsFrom(instanceId, api, section);\n\n  return memo(instanceId, hash => {\n    var _api$query$section3;\n\n    return isFunction((_api$query$section3 = api.query[section]) === null || _api$query$section3 === void 0 ? void 0 : _api$query$section3.proposals) ? proposalsFrom([hash]).pipe(map(([proposal]) => proposal)) : of(null);\n  });\n}"]},"metadata":{},"sourceType":"module"}