{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/ui-keyring authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { createPair } from '@polkadot/keyring/pair';\nimport { chains } from '@polkadot/ui-settings/defaults/chains';\nimport { bnToBn, hexToU8a, isHex, isString, u8aSorted } from '@polkadot/util';\nimport { base64Decode, createKeyMulti } from '@polkadot/util-crypto';\nimport { env } from \"./observable/env.mjs\";\nimport { Base } from \"./Base.mjs\";\nimport { accountKey, accountRegex, addressKey, addressRegex, contractKey, contractRegex } from \"./defaults.mjs\";\nimport { KeyringOption } from \"./options/index.mjs\";\nconst RECENT_EXPIRY = 24 * 60 * 60; // No accounts (or test accounts) should be loaded until after the chain determination.\n// Chain determination occurs outside of Keyring. Loading `keyring.loadAll({ type: 'ed25519' | 'sr25519' })` is triggered\n// from the API after the chain is received\n\nvar _stores = _classPrivateFieldLooseKey(\"stores\");\n\nexport class Keyring extends Base {\n  constructor(...args) {\n    super(...args);\n    this.keyringOption = new KeyringOption();\n    Object.defineProperty(this, _stores, {\n      writable: true,\n      value: {\n        account: () => this.accounts,\n        address: () => this.addresses,\n        contract: () => this.contracts\n      }\n    });\n  }\n\n  addExternal(address, meta = {}) {\n    const pair = this.keyring.addFromAddress(address, _objectSpread(_objectSpread({}, meta), {}, {\n      isExternal: true\n    }), null);\n    return {\n      json: this.saveAccount(pair),\n      pair\n    };\n  }\n\n  addHardware(address, hardwareType, meta = {}) {\n    return this.addExternal(address, _objectSpread(_objectSpread({}, meta), {}, {\n      hardwareType,\n      isHardware: true\n    }));\n  }\n\n  addMultisig(addresses, threshold, meta = {}) {\n    const address = createKeyMulti(addresses, threshold); // we could use `sortAddresses`, but rather use internal encode/decode so we are 100%\n\n    const who = u8aSorted(addresses.map(who => this.decodeAddress(who))).map(who => this.encodeAddress(who));\n    return this.addExternal(address, _objectSpread(_objectSpread({}, meta), {}, {\n      isMultisig: true,\n      threshold: bnToBn(threshold).toNumber(),\n      who\n    }));\n  }\n\n  addPair(pair, password) {\n    this.keyring.addPair(pair);\n    return {\n      json: this.saveAccount(pair, password),\n      pair\n    };\n  }\n\n  addUri(suri, password, meta = {}, type) {\n    const pair = this.keyring.addFromUri(suri, meta, type);\n    return {\n      json: this.saveAccount(pair, password),\n      pair\n    };\n  }\n\n  backupAccount(pair, password) {\n    if (!pair.isLocked) {\n      pair.lock();\n    }\n\n    pair.decodePkcs8(password);\n    return pair.toJson(password);\n  }\n\n  createFromJson(json, meta = {}) {\n    return this.keyring.createFromJson(_objectSpread(_objectSpread({}, json), {}, {\n      meta: _objectSpread(_objectSpread({}, json.meta || {}), {}, {\n        meta\n      })\n    }));\n  }\n\n  createFromUri(suri, meta = {}, type) {\n    return this.keyring.createFromUri(suri, meta, type);\n  }\n\n  encryptAccount(pair, password) {\n    const json = pair.toJson(password);\n    json.meta.whenEdited = Date.now();\n    this.keyring.addFromJson(json);\n    this.accounts.add(this._store, pair.address, json, pair.type);\n  }\n\n  forgetAccount(address) {\n    this.keyring.removePair(address);\n    this.accounts.remove(this._store, address);\n  }\n\n  forgetAddress(address) {\n    this.addresses.remove(this._store, address);\n  }\n\n  forgetContract(address) {\n    this.contracts.remove(this._store, address);\n  }\n\n  getAccount(address) {\n    return this.getAddress(address, 'account');\n  }\n\n  getAccounts() {\n    const available = this.accounts.subject.getValue();\n    return Object.keys(available).map(address => this.getAddress(address, 'account')).filter(account => env.isDevelopment() || account.meta.isTesting !== true);\n  }\n\n  getAddress(_address, type = null) {\n    const address = isString(_address) ? _address : this.encodeAddress(_address);\n    const publicKey = this.decodeAddress(address);\n    const stores = type ? [_classPrivateFieldLooseBase(this, _stores)[_stores][type]] : Object.values(_classPrivateFieldLooseBase(this, _stores)[_stores]);\n    const info = stores.reduce((lastInfo, store) => store().subject.getValue()[address] || lastInfo, undefined);\n    return info && {\n      address,\n      meta: info.json.meta,\n      publicKey\n    };\n  }\n\n  getAddresses() {\n    const available = this.addresses.subject.getValue();\n    return Object.keys(available).map(address => this.getAddress(address));\n  }\n\n  getContract(address) {\n    return this.getAddress(address, 'contract');\n  }\n\n  getContracts() {\n    const available = this.contracts.subject.getValue();\n    return Object.entries(available).filter(([, {\n      json: {\n        meta: {\n          contract\n        }\n      }\n    }]) => !!contract && contract.genesisHash === this.genesisHash).map(([address]) => this.getContract(address));\n  }\n\n  rewriteKey(json, key, hexAddr, creator) {\n    if (hexAddr.substr(0, 2) === '0x') {\n      return;\n    }\n\n    this._store.remove(key);\n\n    this._store.set(creator(hexAddr), json);\n  }\n\n  loadAccount(json, key) {\n    if (!json.meta.isTesting && json.encoded) {\n      // FIXME Just for the transition period (ignoreChecksum)\n      const pair = this.keyring.addFromJson(json, true);\n      this.accounts.add(this._store, pair.address, json, pair.type);\n    }\n\n    const [, hexAddr] = key.split(':');\n    this.rewriteKey(json, key, hexAddr.trim(), accountKey);\n  }\n\n  loadAddress(json, key) {\n    const {\n      isRecent,\n      whenCreated = 0\n    } = json.meta;\n\n    if (isRecent && Date.now() - whenCreated > RECENT_EXPIRY) {\n      this._store.remove(key);\n\n      return;\n    } // We assume anything hex that is not 32bytes (64 + 2 bytes hex) is an Ethereum-like address\n    // (this caters for both H160 addresses as well as full or compressed publicKeys) - in the case\n    // of both ecdsa and ethereum, we keep it as-is\n\n\n    const address = isHex(json.address) && json.address.length !== 66 ? json.address : this.encodeAddress(isHex(json.address) ? hexToU8a(json.address) // FIXME Just for the transition period (ignoreChecksum)\n    : this.decodeAddress(json.address, true));\n    const [, hexAddr] = key.split(':');\n    this.addresses.add(this._store, address, json);\n    this.rewriteKey(json, key, hexAddr, addressKey);\n  }\n\n  loadContract(json, key) {\n    const address = this.encodeAddress(this.decodeAddress(json.address));\n    const [, hexAddr] = key.split(':'); // move genesisHash to top-level (TODO Remove from contracts section?)\n\n    json.meta.genesisHash = json.meta.genesisHash || json.meta.contract && json.meta.contract.genesisHash;\n    this.contracts.add(this._store, address, json);\n    this.rewriteKey(json, key, hexAddr, contractKey);\n  }\n\n  loadInjected(address, meta) {\n    const json = {\n      address,\n      meta: _objectSpread(_objectSpread({}, meta), {}, {\n        isInjected: true\n      })\n    };\n    const pair = this.keyring.addFromAddress(address, json.meta);\n    this.accounts.add(this._store, pair.address, json, pair.type);\n  }\n\n  allowGenesis(json) {\n    if (json && json.meta && this.genesisHash) {\n      const hashes = Object.values(chains).find(hashes => hashes.includes(this.genesisHash || '')) || [this.genesisHash];\n\n      if (json.meta.genesisHash) {\n        return hashes.includes(json.meta.genesisHash);\n      } else if (json.meta.contract) {\n        return hashes.includes(json.meta.contract.genesisHash);\n      }\n    }\n\n    return true;\n  }\n\n  loadAll(options, injected = []) {\n    super.initKeyring(options);\n\n    this._store.all((key, json) => {\n      if (options.filter ? options.filter(json) : true) {\n        try {\n          if (this.allowGenesis(json)) {\n            if (accountRegex.test(key)) {\n              this.loadAccount(json, key);\n            } else if (addressRegex.test(key)) {\n              this.loadAddress(json, key);\n            } else if (contractRegex.test(key)) {\n              this.loadContract(json, key);\n            }\n          }\n        } catch (error) {// ignore\n        }\n      }\n    });\n\n    injected.forEach(account => {\n      if (this.allowGenesis(account)) {\n        try {\n          this.loadInjected(account.address, account.meta);\n        } catch (error) {// ignore\n        }\n      }\n    });\n    this.keyringOption.init(this);\n  }\n\n  restoreAccount(json, password) {\n    const cryptoType = Array.isArray(json.encoding.content) ? json.encoding.content[1] : 'ed25519';\n    const encType = Array.isArray(json.encoding.type) ? json.encoding.type : [json.encoding.type];\n    const pair = createPair({\n      toSS58: this.encodeAddress,\n      type: cryptoType\n    }, {\n      publicKey: this.decodeAddress(json.address, true)\n    }, json.meta, isHex(json.encoded) ? hexToU8a(json.encoded) : base64Decode(json.encoded), encType); // unlock, save account and then lock (locking cleans secretKey, so needs to be last)\n\n    pair.decodePkcs8(password);\n    this.addPair(pair, password);\n    pair.lock();\n    return pair;\n  }\n\n  saveAccount(pair, password) {\n    this.addTimestamp(pair);\n    const json = pair.toJson(password);\n    this.keyring.addFromJson(json);\n    this.accounts.add(this._store, pair.address, json, pair.type);\n    return json;\n  }\n\n  saveAccountMeta(pair, meta) {\n    const address = pair.address;\n\n    this._store.get(accountKey(address), json => {\n      pair.setMeta(meta);\n      json.meta = pair.meta;\n      this.accounts.add(this._store, address, json, pair.type);\n    });\n  }\n\n  saveAddress(address, meta, type = 'address') {\n    const available = this.addresses.subject.getValue();\n    const json = available[address] && available[address].json || {\n      address,\n      meta: {\n        isRecent: undefined,\n        whenCreated: Date.now()\n      }\n    };\n    Object.keys(meta).forEach(key => {\n      json.meta[key] = meta[key];\n    });\n    delete json.meta.isRecent;\n\n    _classPrivateFieldLooseBase(this, _stores)[_stores][type]().add(this._store, address, json);\n\n    return json;\n  }\n\n  saveContract(address, meta) {\n    return this.saveAddress(address, meta, 'contract');\n  }\n\n  saveRecent(address) {\n    const available = this.addresses.subject.getValue();\n\n    if (!available[address]) {\n      this.addresses.add(this._store, address, {\n        address,\n        meta: {\n          genesisHash: this.genesisHash,\n          isRecent: true,\n          whenCreated: Date.now()\n        }\n      });\n    }\n\n    return this.addresses.subject.getValue()[address];\n  }\n\n}","map":{"version":3,"sources":["/Users/bmacer/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/ui-keyring/Keyring.mjs"],"names":["_defineProperty","_classPrivateFieldLooseBase","_classPrivateFieldLooseKey","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","createPair","chains","bnToBn","hexToU8a","isHex","isString","u8aSorted","base64Decode","createKeyMulti","env","Base","accountKey","accountRegex","addressKey","addressRegex","contractKey","contractRegex","KeyringOption","RECENT_EXPIRY","_stores","Keyring","constructor","args","keyringOption","writable","value","account","accounts","address","addresses","contract","contracts","addExternal","meta","pair","keyring","addFromAddress","isExternal","json","saveAccount","addHardware","hardwareType","isHardware","addMultisig","threshold","who","map","decodeAddress","encodeAddress","isMultisig","toNumber","addPair","password","addUri","suri","type","addFromUri","backupAccount","isLocked","lock","decodePkcs8","toJson","createFromJson","createFromUri","encryptAccount","whenEdited","Date","now","addFromJson","add","_store","forgetAccount","removePair","remove","forgetAddress","forgetContract","getAccount","getAddress","getAccounts","available","subject","getValue","isDevelopment","isTesting","_address","publicKey","stores","values","info","reduce","lastInfo","store","undefined","getAddresses","getContract","getContracts","entries","genesisHash","rewriteKey","hexAddr","creator","substr","set","loadAccount","encoded","split","trim","loadAddress","isRecent","whenCreated","loadContract","loadInjected","isInjected","allowGenesis","hashes","find","includes","loadAll","options","injected","initKeyring","all","test","error","init","restoreAccount","cryptoType","Array","isArray","encoding","content","encType","toSS58","addTimestamp","saveAccountMeta","get","setMeta","saveAddress","saveContract","saveRecent"],"mappings":"AAAA,OAAOA,eAAP,MAA4B,2CAA5B;AACA,OAAOC,2BAAP,MAAwC,uDAAxC;AACA,OAAOC,0BAAP,MAAuC,sDAAvC;;AAEA,SAASC,OAAT,CAAiBC,MAAjB,EAAyBC,cAAzB,EAAyC;AAAE,MAAIC,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYF,MAAZ,CAAX;;AAAgC,MAAIG,MAAM,CAACC,qBAAX,EAAkC;AAAE,QAAIC,OAAO,GAAGF,MAAM,CAACC,qBAAP,CAA6BJ,MAA7B,CAAd;AAAoD,QAAIC,cAAJ,EAAoBI,OAAO,GAAGA,OAAO,CAACC,MAAR,CAAe,UAAUC,GAAV,EAAe;AAAE,aAAOJ,MAAM,CAACK,wBAAP,CAAgCR,MAAhC,EAAwCO,GAAxC,EAA6CE,UAApD;AAAiE,KAAjG,CAAV;AAA8GP,IAAAA,IAAI,CAACQ,IAAL,CAAUC,KAAV,CAAgBT,IAAhB,EAAsBG,OAAtB;AAAiC;;AAAC,SAAOH,IAAP;AAAc;;AAErV,SAASU,aAAT,CAAuBC,MAAvB,EAA+B;AAAE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,SAAS,CAACC,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C;AAAE,QAAIG,MAAM,GAAGF,SAAS,CAACD,CAAD,CAAT,IAAgB,IAAhB,GAAuBC,SAAS,CAACD,CAAD,CAAhC,GAAsC,EAAnD;;AAAuD,QAAIA,CAAC,GAAG,CAAR,EAAW;AAAEf,MAAAA,OAAO,CAACI,MAAM,CAACc,MAAD,CAAP,EAAiB,IAAjB,CAAP,CAA8BC,OAA9B,CAAsC,UAAUC,GAAV,EAAe;AAAEvB,QAAAA,eAAe,CAACiB,MAAD,EAASM,GAAT,EAAcF,MAAM,CAACE,GAAD,CAApB,CAAf;AAA4C,OAAnG;AAAuG,KAApH,MAA0H,IAAIhB,MAAM,CAACiB,yBAAX,EAAsC;AAAEjB,MAAAA,MAAM,CAACkB,gBAAP,CAAwBR,MAAxB,EAAgCV,MAAM,CAACiB,yBAAP,CAAiCH,MAAjC,CAAhC;AAA4E,KAApH,MAA0H;AAAElB,MAAAA,OAAO,CAACI,MAAM,CAACc,MAAD,CAAP,CAAP,CAAwBC,OAAxB,CAAgC,UAAUC,GAAV,EAAe;AAAEhB,QAAAA,MAAM,CAACmB,cAAP,CAAsBT,MAAtB,EAA8BM,GAA9B,EAAmChB,MAAM,CAACK,wBAAP,CAAgCS,MAAhC,EAAwCE,GAAxC,CAAnC;AAAmF,OAApI;AAAwI;AAAE;;AAAC,SAAON,MAAP;AAAgB,C,CAEthB;AACA;;;AACA,SAASU,UAAT,QAA2B,wBAA3B;AACA,SAASC,MAAT,QAAuB,uCAAvB;AACA,SAASC,MAAT,EAAiBC,QAAjB,EAA2BC,KAA3B,EAAkCC,QAAlC,EAA4CC,SAA5C,QAA6D,gBAA7D;AACA,SAASC,YAAT,EAAuBC,cAAvB,QAA6C,uBAA7C;AACA,SAASC,GAAT,QAAoB,sBAApB;AACA,SAASC,IAAT,QAAqB,YAArB;AACA,SAASC,UAAT,EAAqBC,YAArB,EAAmCC,UAAnC,EAA+CC,YAA/C,EAA6DC,WAA7D,EAA0EC,aAA1E,QAA+F,gBAA/F;AACA,SAASC,aAAT,QAA8B,qBAA9B;AACA,MAAMC,aAAa,GAAG,KAAK,EAAL,GAAU,EAAhC,C,CAAoC;AACpC;AACA;;AAEA,IAAIC,OAAO,GAAG5C,0BAA0B,CAAC,QAAD,CAAxC;;AAEA,OAAO,MAAM6C,OAAN,SAAsBV,IAAtB,CAA2B;AAChCW,EAAAA,WAAW,CAAC,GAAGC,IAAJ,EAAU;AACnB,UAAM,GAAGA,IAAT;AACA,SAAKC,aAAL,GAAqB,IAAIN,aAAJ,EAArB;AACArC,IAAAA,MAAM,CAACmB,cAAP,CAAsB,IAAtB,EAA4BoB,OAA5B,EAAqC;AACnCK,MAAAA,QAAQ,EAAE,IADyB;AAEnCC,MAAAA,KAAK,EAAE;AACLC,QAAAA,OAAO,EAAE,MAAM,KAAKC,QADf;AAELC,QAAAA,OAAO,EAAE,MAAM,KAAKC,SAFf;AAGLC,QAAAA,QAAQ,EAAE,MAAM,KAAKC;AAHhB;AAF4B,KAArC;AAQD;;AAEDC,EAAAA,WAAW,CAACJ,OAAD,EAAUK,IAAI,GAAG,EAAjB,EAAqB;AAC9B,UAAMC,IAAI,GAAG,KAAKC,OAAL,CAAaC,cAAb,CAA4BR,OAA5B,EAAqCvC,aAAa,CAACA,aAAa,CAAC,EAAD,EAAK4C,IAAL,CAAd,EAA0B,EAA1B,EAA8B;AAC3FI,MAAAA,UAAU,EAAE;AAD+E,KAA9B,CAAlD,EAET,IAFS,CAAb;AAGA,WAAO;AACLC,MAAAA,IAAI,EAAE,KAAKC,WAAL,CAAiBL,IAAjB,CADD;AAELA,MAAAA;AAFK,KAAP;AAID;;AAEDM,EAAAA,WAAW,CAACZ,OAAD,EAAUa,YAAV,EAAwBR,IAAI,GAAG,EAA/B,EAAmC;AAC5C,WAAO,KAAKD,WAAL,CAAiBJ,OAAjB,EAA0BvC,aAAa,CAACA,aAAa,CAAC,EAAD,EAAK4C,IAAL,CAAd,EAA0B,EAA1B,EAA8B;AAC1EQ,MAAAA,YAD0E;AAE1EC,MAAAA,UAAU,EAAE;AAF8D,KAA9B,CAAvC,CAAP;AAID;;AAEDC,EAAAA,WAAW,CAACd,SAAD,EAAYe,SAAZ,EAAuBX,IAAI,GAAG,EAA9B,EAAkC;AAC3C,UAAML,OAAO,GAAGpB,cAAc,CAACqB,SAAD,EAAYe,SAAZ,CAA9B,CAD2C,CACW;;AAEtD,UAAMC,GAAG,GAAGvC,SAAS,CAACuB,SAAS,CAACiB,GAAV,CAAcD,GAAG,IAAI,KAAKE,aAAL,CAAmBF,GAAnB,CAArB,CAAD,CAAT,CAAyDC,GAAzD,CAA6DD,GAAG,IAAI,KAAKG,aAAL,CAAmBH,GAAnB,CAApE,CAAZ;AACA,WAAO,KAAKb,WAAL,CAAiBJ,OAAjB,EAA0BvC,aAAa,CAACA,aAAa,CAAC,EAAD,EAAK4C,IAAL,CAAd,EAA0B,EAA1B,EAA8B;AAC1EgB,MAAAA,UAAU,EAAE,IAD8D;AAE1EL,MAAAA,SAAS,EAAE1C,MAAM,CAAC0C,SAAD,CAAN,CAAkBM,QAAlB,EAF+D;AAG1EL,MAAAA;AAH0E,KAA9B,CAAvC,CAAP;AAKD;;AAEDM,EAAAA,OAAO,CAACjB,IAAD,EAAOkB,QAAP,EAAiB;AACtB,SAAKjB,OAAL,CAAagB,OAAb,CAAqBjB,IAArB;AACA,WAAO;AACLI,MAAAA,IAAI,EAAE,KAAKC,WAAL,CAAiBL,IAAjB,EAAuBkB,QAAvB,CADD;AAELlB,MAAAA;AAFK,KAAP;AAID;;AAEDmB,EAAAA,MAAM,CAACC,IAAD,EAAOF,QAAP,EAAiBnB,IAAI,GAAG,EAAxB,EAA4BsB,IAA5B,EAAkC;AACtC,UAAMrB,IAAI,GAAG,KAAKC,OAAL,CAAaqB,UAAb,CAAwBF,IAAxB,EAA8BrB,IAA9B,EAAoCsB,IAApC,CAAb;AACA,WAAO;AACLjB,MAAAA,IAAI,EAAE,KAAKC,WAAL,CAAiBL,IAAjB,EAAuBkB,QAAvB,CADD;AAELlB,MAAAA;AAFK,KAAP;AAID;;AAEDuB,EAAAA,aAAa,CAACvB,IAAD,EAAOkB,QAAP,EAAiB;AAC5B,QAAI,CAAClB,IAAI,CAACwB,QAAV,EAAoB;AAClBxB,MAAAA,IAAI,CAACyB,IAAL;AACD;;AAEDzB,IAAAA,IAAI,CAAC0B,WAAL,CAAiBR,QAAjB;AACA,WAAOlB,IAAI,CAAC2B,MAAL,CAAYT,QAAZ,CAAP;AACD;;AAEDU,EAAAA,cAAc,CAACxB,IAAD,EAAOL,IAAI,GAAG,EAAd,EAAkB;AAC9B,WAAO,KAAKE,OAAL,CAAa2B,cAAb,CAA4BzE,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKiD,IAAL,CAAd,EAA0B,EAA1B,EAA8B;AAC5EL,MAAAA,IAAI,EAAE5C,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKiD,IAAI,CAACL,IAAL,IAAa,EAAlB,CAAd,EAAqC,EAArC,EAAyC;AAC1DA,QAAAA;AAD0D,OAAzC;AADyD,KAA9B,CAAzC,CAAP;AAKD;;AAED8B,EAAAA,aAAa,CAACT,IAAD,EAAOrB,IAAI,GAAG,EAAd,EAAkBsB,IAAlB,EAAwB;AACnC,WAAO,KAAKpB,OAAL,CAAa4B,aAAb,CAA2BT,IAA3B,EAAiCrB,IAAjC,EAAuCsB,IAAvC,CAAP;AACD;;AAEDS,EAAAA,cAAc,CAAC9B,IAAD,EAAOkB,QAAP,EAAiB;AAC7B,UAAMd,IAAI,GAAGJ,IAAI,CAAC2B,MAAL,CAAYT,QAAZ,CAAb;AACAd,IAAAA,IAAI,CAACL,IAAL,CAAUgC,UAAV,GAAuBC,IAAI,CAACC,GAAL,EAAvB;AACA,SAAKhC,OAAL,CAAaiC,WAAb,CAAyB9B,IAAzB;AACA,SAAKX,QAAL,CAAc0C,GAAd,CAAkB,KAAKC,MAAvB,EAA+BpC,IAAI,CAACN,OAApC,EAA6CU,IAA7C,EAAmDJ,IAAI,CAACqB,IAAxD;AACD;;AAEDgB,EAAAA,aAAa,CAAC3C,OAAD,EAAU;AACrB,SAAKO,OAAL,CAAaqC,UAAb,CAAwB5C,OAAxB;AACA,SAAKD,QAAL,CAAc8C,MAAd,CAAqB,KAAKH,MAA1B,EAAkC1C,OAAlC;AACD;;AAED8C,EAAAA,aAAa,CAAC9C,OAAD,EAAU;AACrB,SAAKC,SAAL,CAAe4C,MAAf,CAAsB,KAAKH,MAA3B,EAAmC1C,OAAnC;AACD;;AAED+C,EAAAA,cAAc,CAAC/C,OAAD,EAAU;AACtB,SAAKG,SAAL,CAAe0C,MAAf,CAAsB,KAAKH,MAA3B,EAAmC1C,OAAnC;AACD;;AAEDgD,EAAAA,UAAU,CAAChD,OAAD,EAAU;AAClB,WAAO,KAAKiD,UAAL,CAAgBjD,OAAhB,EAAyB,SAAzB,CAAP;AACD;;AAEDkD,EAAAA,WAAW,GAAG;AACZ,UAAMC,SAAS,GAAG,KAAKpD,QAAL,CAAcqD,OAAd,CAAsBC,QAAtB,EAAlB;AACA,WAAOrG,MAAM,CAACD,IAAP,CAAYoG,SAAZ,EAAuBjC,GAAvB,CAA2BlB,OAAO,IAAI,KAAKiD,UAAL,CAAgBjD,OAAhB,EAAyB,SAAzB,CAAtC,EAA2E7C,MAA3E,CAAkF2C,OAAO,IAAIjB,GAAG,CAACyE,aAAJ,MAAuBxD,OAAO,CAACO,IAAR,CAAakD,SAAb,KAA2B,IAA/I,CAAP;AACD;;AAEDN,EAAAA,UAAU,CAACO,QAAD,EAAW7B,IAAI,GAAG,IAAlB,EAAwB;AAChC,UAAM3B,OAAO,GAAGvB,QAAQ,CAAC+E,QAAD,CAAR,GAAqBA,QAArB,GAAgC,KAAKpC,aAAL,CAAmBoC,QAAnB,CAAhD;AACA,UAAMC,SAAS,GAAG,KAAKtC,aAAL,CAAmBnB,OAAnB,CAAlB;AACA,UAAM0D,MAAM,GAAG/B,IAAI,GAAG,CAACjF,2BAA2B,CAAC,IAAD,EAAO6C,OAAP,CAA3B,CAA2CA,OAA3C,EAAoDoC,IAApD,CAAD,CAAH,GAAiE3E,MAAM,CAAC2G,MAAP,CAAcjH,2BAA2B,CAAC,IAAD,EAAO6C,OAAP,CAA3B,CAA2CA,OAA3C,CAAd,CAApF;AACA,UAAMqE,IAAI,GAAGF,MAAM,CAACG,MAAP,CAAc,CAACC,QAAD,EAAWC,KAAX,KAAqBA,KAAK,GAAGX,OAAR,CAAgBC,QAAhB,GAA2BrD,OAA3B,KAAuC8D,QAA1E,EAAoFE,SAApF,CAAb;AACA,WAAOJ,IAAI,IAAI;AACb5D,MAAAA,OADa;AAEbK,MAAAA,IAAI,EAAEuD,IAAI,CAAClD,IAAL,CAAUL,IAFH;AAGboD,MAAAA;AAHa,KAAf;AAKD;;AAEDQ,EAAAA,YAAY,GAAG;AACb,UAAMd,SAAS,GAAG,KAAKlD,SAAL,CAAemD,OAAf,CAAuBC,QAAvB,EAAlB;AACA,WAAOrG,MAAM,CAACD,IAAP,CAAYoG,SAAZ,EAAuBjC,GAAvB,CAA2BlB,OAAO,IAAI,KAAKiD,UAAL,CAAgBjD,OAAhB,CAAtC,CAAP;AACD;;AAEDkE,EAAAA,WAAW,CAAClE,OAAD,EAAU;AACnB,WAAO,KAAKiD,UAAL,CAAgBjD,OAAhB,EAAyB,UAAzB,CAAP;AACD;;AAEDmE,EAAAA,YAAY,GAAG;AACb,UAAMhB,SAAS,GAAG,KAAKhD,SAAL,CAAeiD,OAAf,CAAuBC,QAAvB,EAAlB;AACA,WAAOrG,MAAM,CAACoH,OAAP,CAAejB,SAAf,EAA0BhG,MAA1B,CAAiC,CAAC,GAAG;AAC1CuD,MAAAA,IAAI,EAAE;AACJL,QAAAA,IAAI,EAAE;AACJH,UAAAA;AADI;AADF;AADoC,KAAH,CAAD,KAMjC,CAAC,CAACA,QAAF,IAAcA,QAAQ,CAACmE,WAAT,KAAyB,KAAKA,WAN5C,EAMyDnD,GANzD,CAM6D,CAAC,CAAClB,OAAD,CAAD,KAAe,KAAKkE,WAAL,CAAiBlE,OAAjB,CAN5E,CAAP;AAOD;;AAEDsE,EAAAA,UAAU,CAAC5D,IAAD,EAAO1C,GAAP,EAAYuG,OAAZ,EAAqBC,OAArB,EAA8B;AACtC,QAAID,OAAO,CAACE,MAAR,CAAe,CAAf,EAAkB,CAAlB,MAAyB,IAA7B,EAAmC;AACjC;AACD;;AAED,SAAK/B,MAAL,CAAYG,MAAZ,CAAmB7E,GAAnB;;AAEA,SAAK0E,MAAL,CAAYgC,GAAZ,CAAgBF,OAAO,CAACD,OAAD,CAAvB,EAAkC7D,IAAlC;AACD;;AAEDiE,EAAAA,WAAW,CAACjE,IAAD,EAAO1C,GAAP,EAAY;AACrB,QAAI,CAAC0C,IAAI,CAACL,IAAL,CAAUkD,SAAX,IAAwB7C,IAAI,CAACkE,OAAjC,EAA0C;AACxC;AACA,YAAMtE,IAAI,GAAG,KAAKC,OAAL,CAAaiC,WAAb,CAAyB9B,IAAzB,EAA+B,IAA/B,CAAb;AACA,WAAKX,QAAL,CAAc0C,GAAd,CAAkB,KAAKC,MAAvB,EAA+BpC,IAAI,CAACN,OAApC,EAA6CU,IAA7C,EAAmDJ,IAAI,CAACqB,IAAxD;AACD;;AAED,UAAM,GAAG4C,OAAH,IAAcvG,GAAG,CAAC6G,KAAJ,CAAU,GAAV,CAApB;AACA,SAAKP,UAAL,CAAgB5D,IAAhB,EAAsB1C,GAAtB,EAA2BuG,OAAO,CAACO,IAAR,EAA3B,EAA2C/F,UAA3C;AACD;;AAEDgG,EAAAA,WAAW,CAACrE,IAAD,EAAO1C,GAAP,EAAY;AACrB,UAAM;AACJgH,MAAAA,QADI;AAEJC,MAAAA,WAAW,GAAG;AAFV,QAGFvE,IAAI,CAACL,IAHT;;AAKA,QAAI2E,QAAQ,IAAI1C,IAAI,CAACC,GAAL,KAAa0C,WAAb,GAA2B3F,aAA3C,EAA0D;AACxD,WAAKoD,MAAL,CAAYG,MAAZ,CAAmB7E,GAAnB;;AAEA;AACD,KAVoB,CAUnB;AACF;AACA;;;AAGA,UAAMgC,OAAO,GAAGxB,KAAK,CAACkC,IAAI,CAACV,OAAN,CAAL,IAAuBU,IAAI,CAACV,OAAL,CAAanC,MAAb,KAAwB,EAA/C,GAAoD6C,IAAI,CAACV,OAAzD,GAAmE,KAAKoB,aAAL,CAAmB5C,KAAK,CAACkC,IAAI,CAACV,OAAN,CAAL,GAAsBzB,QAAQ,CAACmC,IAAI,CAACV,OAAN,CAA9B,CAA6C;AAA7C,MACpG,KAAKmB,aAAL,CAAmBT,IAAI,CAACV,OAAxB,EAAiC,IAAjC,CADiF,CAAnF;AAEA,UAAM,GAAGuE,OAAH,IAAcvG,GAAG,CAAC6G,KAAJ,CAAU,GAAV,CAApB;AACA,SAAK5E,SAAL,CAAewC,GAAf,CAAmB,KAAKC,MAAxB,EAAgC1C,OAAhC,EAAyCU,IAAzC;AACA,SAAK4D,UAAL,CAAgB5D,IAAhB,EAAsB1C,GAAtB,EAA2BuG,OAA3B,EAAoCtF,UAApC;AACD;;AAEDiG,EAAAA,YAAY,CAACxE,IAAD,EAAO1C,GAAP,EAAY;AACtB,UAAMgC,OAAO,GAAG,KAAKoB,aAAL,CAAmB,KAAKD,aAAL,CAAmBT,IAAI,CAACV,OAAxB,CAAnB,CAAhB;AACA,UAAM,GAAGuE,OAAH,IAAcvG,GAAG,CAAC6G,KAAJ,CAAU,GAAV,CAApB,CAFsB,CAEc;;AAEpCnE,IAAAA,IAAI,CAACL,IAAL,CAAUgE,WAAV,GAAwB3D,IAAI,CAACL,IAAL,CAAUgE,WAAV,IAAyB3D,IAAI,CAACL,IAAL,CAAUH,QAAV,IAAsBQ,IAAI,CAACL,IAAL,CAAUH,QAAV,CAAmBmE,WAA1F;AACA,SAAKlE,SAAL,CAAesC,GAAf,CAAmB,KAAKC,MAAxB,EAAgC1C,OAAhC,EAAyCU,IAAzC;AACA,SAAK4D,UAAL,CAAgB5D,IAAhB,EAAsB1C,GAAtB,EAA2BuG,OAA3B,EAAoCpF,WAApC;AACD;;AAEDgG,EAAAA,YAAY,CAACnF,OAAD,EAAUK,IAAV,EAAgB;AAC1B,UAAMK,IAAI,GAAG;AACXV,MAAAA,OADW;AAEXK,MAAAA,IAAI,EAAE5C,aAAa,CAACA,aAAa,CAAC,EAAD,EAAK4C,IAAL,CAAd,EAA0B,EAA1B,EAA8B;AAC/C+E,QAAAA,UAAU,EAAE;AADmC,OAA9B;AAFR,KAAb;AAMA,UAAM9E,IAAI,GAAG,KAAKC,OAAL,CAAaC,cAAb,CAA4BR,OAA5B,EAAqCU,IAAI,CAACL,IAA1C,CAAb;AACA,SAAKN,QAAL,CAAc0C,GAAd,CAAkB,KAAKC,MAAvB,EAA+BpC,IAAI,CAACN,OAApC,EAA6CU,IAA7C,EAAmDJ,IAAI,CAACqB,IAAxD;AACD;;AAED0D,EAAAA,YAAY,CAAC3E,IAAD,EAAO;AACjB,QAAIA,IAAI,IAAIA,IAAI,CAACL,IAAb,IAAqB,KAAKgE,WAA9B,EAA2C;AACzC,YAAMiB,MAAM,GAAGtI,MAAM,CAAC2G,MAAP,CAActF,MAAd,EAAsBkH,IAAtB,CAA2BD,MAAM,IAAIA,MAAM,CAACE,QAAP,CAAgB,KAAKnB,WAAL,IAAoB,EAApC,CAArC,KAAiF,CAAC,KAAKA,WAAN,CAAhG;;AAEA,UAAI3D,IAAI,CAACL,IAAL,CAAUgE,WAAd,EAA2B;AACzB,eAAOiB,MAAM,CAACE,QAAP,CAAgB9E,IAAI,CAACL,IAAL,CAAUgE,WAA1B,CAAP;AACD,OAFD,MAEO,IAAI3D,IAAI,CAACL,IAAL,CAAUH,QAAd,EAAwB;AAC7B,eAAOoF,MAAM,CAACE,QAAP,CAAgB9E,IAAI,CAACL,IAAL,CAAUH,QAAV,CAAmBmE,WAAnC,CAAP;AACD;AACF;;AAED,WAAO,IAAP;AACD;;AAEDoB,EAAAA,OAAO,CAACC,OAAD,EAAUC,QAAQ,GAAG,EAArB,EAAyB;AAC9B,UAAMC,WAAN,CAAkBF,OAAlB;;AAEA,SAAKhD,MAAL,CAAYmD,GAAZ,CAAgB,CAAC7H,GAAD,EAAM0C,IAAN,KAAe;AAC7B,UAAIgF,OAAO,CAACvI,MAAR,GAAiBuI,OAAO,CAACvI,MAAR,CAAeuD,IAAf,CAAjB,GAAwC,IAA5C,EAAkD;AAChD,YAAI;AACF,cAAI,KAAK2E,YAAL,CAAkB3E,IAAlB,CAAJ,EAA6B;AAC3B,gBAAI1B,YAAY,CAAC8G,IAAb,CAAkB9H,GAAlB,CAAJ,EAA4B;AAC1B,mBAAK2G,WAAL,CAAiBjE,IAAjB,EAAuB1C,GAAvB;AACD,aAFD,MAEO,IAAIkB,YAAY,CAAC4G,IAAb,CAAkB9H,GAAlB,CAAJ,EAA4B;AACjC,mBAAK+G,WAAL,CAAiBrE,IAAjB,EAAuB1C,GAAvB;AACD,aAFM,MAEA,IAAIoB,aAAa,CAAC0G,IAAd,CAAmB9H,GAAnB,CAAJ,EAA6B;AAClC,mBAAKkH,YAAL,CAAkBxE,IAAlB,EAAwB1C,GAAxB;AACD;AACF;AACF,SAVD,CAUE,OAAO+H,KAAP,EAAc,CAAC;AAChB;AACF;AACF,KAfD;;AAiBAJ,IAAAA,QAAQ,CAAC5H,OAAT,CAAiB+B,OAAO,IAAI;AAC1B,UAAI,KAAKuF,YAAL,CAAkBvF,OAAlB,CAAJ,EAAgC;AAC9B,YAAI;AACF,eAAKqF,YAAL,CAAkBrF,OAAO,CAACE,OAA1B,EAAmCF,OAAO,CAACO,IAA3C;AACD,SAFD,CAEE,OAAO0F,KAAP,EAAc,CAAC;AAChB;AACF;AACF,KAPD;AAQA,SAAKpG,aAAL,CAAmBqG,IAAnB,CAAwB,IAAxB;AACD;;AAEDC,EAAAA,cAAc,CAACvF,IAAD,EAAOc,QAAP,EAAiB;AAC7B,UAAM0E,UAAU,GAAGC,KAAK,CAACC,OAAN,CAAc1F,IAAI,CAAC2F,QAAL,CAAcC,OAA5B,IAAuC5F,IAAI,CAAC2F,QAAL,CAAcC,OAAd,CAAsB,CAAtB,CAAvC,GAAkE,SAArF;AACA,UAAMC,OAAO,GAAGJ,KAAK,CAACC,OAAN,CAAc1F,IAAI,CAAC2F,QAAL,CAAc1E,IAA5B,IAAoCjB,IAAI,CAAC2F,QAAL,CAAc1E,IAAlD,GAAyD,CAACjB,IAAI,CAAC2F,QAAL,CAAc1E,IAAf,CAAzE;AACA,UAAMrB,IAAI,GAAGlC,UAAU,CAAC;AACtBoI,MAAAA,MAAM,EAAE,KAAKpF,aADS;AAEtBO,MAAAA,IAAI,EAAEuE;AAFgB,KAAD,EAGpB;AACDzC,MAAAA,SAAS,EAAE,KAAKtC,aAAL,CAAmBT,IAAI,CAACV,OAAxB,EAAiC,IAAjC;AADV,KAHoB,EAKpBU,IAAI,CAACL,IALe,EAKT7B,KAAK,CAACkC,IAAI,CAACkE,OAAN,CAAL,GAAsBrG,QAAQ,CAACmC,IAAI,CAACkE,OAAN,CAA9B,GAA+CjG,YAAY,CAAC+B,IAAI,CAACkE,OAAN,CALlD,EAKkE2B,OALlE,CAAvB,CAH6B,CAQsE;;AAEnGjG,IAAAA,IAAI,CAAC0B,WAAL,CAAiBR,QAAjB;AACA,SAAKD,OAAL,CAAajB,IAAb,EAAmBkB,QAAnB;AACAlB,IAAAA,IAAI,CAACyB,IAAL;AACA,WAAOzB,IAAP;AACD;;AAEDK,EAAAA,WAAW,CAACL,IAAD,EAAOkB,QAAP,EAAiB;AAC1B,SAAKiF,YAAL,CAAkBnG,IAAlB;AACA,UAAMI,IAAI,GAAGJ,IAAI,CAAC2B,MAAL,CAAYT,QAAZ,CAAb;AACA,SAAKjB,OAAL,CAAaiC,WAAb,CAAyB9B,IAAzB;AACA,SAAKX,QAAL,CAAc0C,GAAd,CAAkB,KAAKC,MAAvB,EAA+BpC,IAAI,CAACN,OAApC,EAA6CU,IAA7C,EAAmDJ,IAAI,CAACqB,IAAxD;AACA,WAAOjB,IAAP;AACD;;AAEDgG,EAAAA,eAAe,CAACpG,IAAD,EAAOD,IAAP,EAAa;AAC1B,UAAML,OAAO,GAAGM,IAAI,CAACN,OAArB;;AAEA,SAAK0C,MAAL,CAAYiE,GAAZ,CAAgB5H,UAAU,CAACiB,OAAD,CAA1B,EAAqCU,IAAI,IAAI;AAC3CJ,MAAAA,IAAI,CAACsG,OAAL,CAAavG,IAAb;AACAK,MAAAA,IAAI,CAACL,IAAL,GAAYC,IAAI,CAACD,IAAjB;AACA,WAAKN,QAAL,CAAc0C,GAAd,CAAkB,KAAKC,MAAvB,EAA+B1C,OAA/B,EAAwCU,IAAxC,EAA8CJ,IAAI,CAACqB,IAAnD;AACD,KAJD;AAKD;;AAEDkF,EAAAA,WAAW,CAAC7G,OAAD,EAAUK,IAAV,EAAgBsB,IAAI,GAAG,SAAvB,EAAkC;AAC3C,UAAMwB,SAAS,GAAG,KAAKlD,SAAL,CAAemD,OAAf,CAAuBC,QAAvB,EAAlB;AACA,UAAM3C,IAAI,GAAGyC,SAAS,CAACnD,OAAD,CAAT,IAAsBmD,SAAS,CAACnD,OAAD,CAAT,CAAmBU,IAAzC,IAAiD;AAC5DV,MAAAA,OAD4D;AAE5DK,MAAAA,IAAI,EAAE;AACJ2E,QAAAA,QAAQ,EAAEhB,SADN;AAEJiB,QAAAA,WAAW,EAAE3C,IAAI,CAACC,GAAL;AAFT;AAFsD,KAA9D;AAOAvF,IAAAA,MAAM,CAACD,IAAP,CAAYsD,IAAZ,EAAkBtC,OAAlB,CAA0BC,GAAG,IAAI;AAC/B0C,MAAAA,IAAI,CAACL,IAAL,CAAUrC,GAAV,IAAiBqC,IAAI,CAACrC,GAAD,CAArB;AACD,KAFD;AAGA,WAAO0C,IAAI,CAACL,IAAL,CAAU2E,QAAjB;;AAEAtI,IAAAA,2BAA2B,CAAC,IAAD,EAAO6C,OAAP,CAA3B,CAA2CA,OAA3C,EAAoDoC,IAApD,IAA4Dc,GAA5D,CAAgE,KAAKC,MAArE,EAA6E1C,OAA7E,EAAsFU,IAAtF;;AAEA,WAAOA,IAAP;AACD;;AAEDoG,EAAAA,YAAY,CAAC9G,OAAD,EAAUK,IAAV,EAAgB;AAC1B,WAAO,KAAKwG,WAAL,CAAiB7G,OAAjB,EAA0BK,IAA1B,EAAgC,UAAhC,CAAP;AACD;;AAED0G,EAAAA,UAAU,CAAC/G,OAAD,EAAU;AAClB,UAAMmD,SAAS,GAAG,KAAKlD,SAAL,CAAemD,OAAf,CAAuBC,QAAvB,EAAlB;;AAEA,QAAI,CAACF,SAAS,CAACnD,OAAD,CAAd,EAAyB;AACvB,WAAKC,SAAL,CAAewC,GAAf,CAAmB,KAAKC,MAAxB,EAAgC1C,OAAhC,EAAyC;AACvCA,QAAAA,OADuC;AAEvCK,QAAAA,IAAI,EAAE;AACJgE,UAAAA,WAAW,EAAE,KAAKA,WADd;AAEJW,UAAAA,QAAQ,EAAE,IAFN;AAGJC,UAAAA,WAAW,EAAE3C,IAAI,CAACC,GAAL;AAHT;AAFiC,OAAzC;AAQD;;AAED,WAAO,KAAKtC,SAAL,CAAemD,OAAf,CAAuBC,QAAvB,GAAkCrD,OAAlC,CAAP;AACD;;AAhU+B","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/ui-keyring authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { createPair } from '@polkadot/keyring/pair';\nimport { chains } from '@polkadot/ui-settings/defaults/chains';\nimport { bnToBn, hexToU8a, isHex, isString, u8aSorted } from '@polkadot/util';\nimport { base64Decode, createKeyMulti } from '@polkadot/util-crypto';\nimport { env } from \"./observable/env.mjs\";\nimport { Base } from \"./Base.mjs\";\nimport { accountKey, accountRegex, addressKey, addressRegex, contractKey, contractRegex } from \"./defaults.mjs\";\nimport { KeyringOption } from \"./options/index.mjs\";\nconst RECENT_EXPIRY = 24 * 60 * 60; // No accounts (or test accounts) should be loaded until after the chain determination.\n// Chain determination occurs outside of Keyring. Loading `keyring.loadAll({ type: 'ed25519' | 'sr25519' })` is triggered\n// from the API after the chain is received\n\nvar _stores = _classPrivateFieldLooseKey(\"stores\");\n\nexport class Keyring extends Base {\n  constructor(...args) {\n    super(...args);\n    this.keyringOption = new KeyringOption();\n    Object.defineProperty(this, _stores, {\n      writable: true,\n      value: {\n        account: () => this.accounts,\n        address: () => this.addresses,\n        contract: () => this.contracts\n      }\n    });\n  }\n\n  addExternal(address, meta = {}) {\n    const pair = this.keyring.addFromAddress(address, _objectSpread(_objectSpread({}, meta), {}, {\n      isExternal: true\n    }), null);\n    return {\n      json: this.saveAccount(pair),\n      pair\n    };\n  }\n\n  addHardware(address, hardwareType, meta = {}) {\n    return this.addExternal(address, _objectSpread(_objectSpread({}, meta), {}, {\n      hardwareType,\n      isHardware: true\n    }));\n  }\n\n  addMultisig(addresses, threshold, meta = {}) {\n    const address = createKeyMulti(addresses, threshold); // we could use `sortAddresses`, but rather use internal encode/decode so we are 100%\n\n    const who = u8aSorted(addresses.map(who => this.decodeAddress(who))).map(who => this.encodeAddress(who));\n    return this.addExternal(address, _objectSpread(_objectSpread({}, meta), {}, {\n      isMultisig: true,\n      threshold: bnToBn(threshold).toNumber(),\n      who\n    }));\n  }\n\n  addPair(pair, password) {\n    this.keyring.addPair(pair);\n    return {\n      json: this.saveAccount(pair, password),\n      pair\n    };\n  }\n\n  addUri(suri, password, meta = {}, type) {\n    const pair = this.keyring.addFromUri(suri, meta, type);\n    return {\n      json: this.saveAccount(pair, password),\n      pair\n    };\n  }\n\n  backupAccount(pair, password) {\n    if (!pair.isLocked) {\n      pair.lock();\n    }\n\n    pair.decodePkcs8(password);\n    return pair.toJson(password);\n  }\n\n  createFromJson(json, meta = {}) {\n    return this.keyring.createFromJson(_objectSpread(_objectSpread({}, json), {}, {\n      meta: _objectSpread(_objectSpread({}, json.meta || {}), {}, {\n        meta\n      })\n    }));\n  }\n\n  createFromUri(suri, meta = {}, type) {\n    return this.keyring.createFromUri(suri, meta, type);\n  }\n\n  encryptAccount(pair, password) {\n    const json = pair.toJson(password);\n    json.meta.whenEdited = Date.now();\n    this.keyring.addFromJson(json);\n    this.accounts.add(this._store, pair.address, json, pair.type);\n  }\n\n  forgetAccount(address) {\n    this.keyring.removePair(address);\n    this.accounts.remove(this._store, address);\n  }\n\n  forgetAddress(address) {\n    this.addresses.remove(this._store, address);\n  }\n\n  forgetContract(address) {\n    this.contracts.remove(this._store, address);\n  }\n\n  getAccount(address) {\n    return this.getAddress(address, 'account');\n  }\n\n  getAccounts() {\n    const available = this.accounts.subject.getValue();\n    return Object.keys(available).map(address => this.getAddress(address, 'account')).filter(account => env.isDevelopment() || account.meta.isTesting !== true);\n  }\n\n  getAddress(_address, type = null) {\n    const address = isString(_address) ? _address : this.encodeAddress(_address);\n    const publicKey = this.decodeAddress(address);\n    const stores = type ? [_classPrivateFieldLooseBase(this, _stores)[_stores][type]] : Object.values(_classPrivateFieldLooseBase(this, _stores)[_stores]);\n    const info = stores.reduce((lastInfo, store) => store().subject.getValue()[address] || lastInfo, undefined);\n    return info && {\n      address,\n      meta: info.json.meta,\n      publicKey\n    };\n  }\n\n  getAddresses() {\n    const available = this.addresses.subject.getValue();\n    return Object.keys(available).map(address => this.getAddress(address));\n  }\n\n  getContract(address) {\n    return this.getAddress(address, 'contract');\n  }\n\n  getContracts() {\n    const available = this.contracts.subject.getValue();\n    return Object.entries(available).filter(([, {\n      json: {\n        meta: {\n          contract\n        }\n      }\n    }]) => !!contract && contract.genesisHash === this.genesisHash).map(([address]) => this.getContract(address));\n  }\n\n  rewriteKey(json, key, hexAddr, creator) {\n    if (hexAddr.substr(0, 2) === '0x') {\n      return;\n    }\n\n    this._store.remove(key);\n\n    this._store.set(creator(hexAddr), json);\n  }\n\n  loadAccount(json, key) {\n    if (!json.meta.isTesting && json.encoded) {\n      // FIXME Just for the transition period (ignoreChecksum)\n      const pair = this.keyring.addFromJson(json, true);\n      this.accounts.add(this._store, pair.address, json, pair.type);\n    }\n\n    const [, hexAddr] = key.split(':');\n    this.rewriteKey(json, key, hexAddr.trim(), accountKey);\n  }\n\n  loadAddress(json, key) {\n    const {\n      isRecent,\n      whenCreated = 0\n    } = json.meta;\n\n    if (isRecent && Date.now() - whenCreated > RECENT_EXPIRY) {\n      this._store.remove(key);\n\n      return;\n    } // We assume anything hex that is not 32bytes (64 + 2 bytes hex) is an Ethereum-like address\n    // (this caters for both H160 addresses as well as full or compressed publicKeys) - in the case\n    // of both ecdsa and ethereum, we keep it as-is\n\n\n    const address = isHex(json.address) && json.address.length !== 66 ? json.address : this.encodeAddress(isHex(json.address) ? hexToU8a(json.address) // FIXME Just for the transition period (ignoreChecksum)\n    : this.decodeAddress(json.address, true));\n    const [, hexAddr] = key.split(':');\n    this.addresses.add(this._store, address, json);\n    this.rewriteKey(json, key, hexAddr, addressKey);\n  }\n\n  loadContract(json, key) {\n    const address = this.encodeAddress(this.decodeAddress(json.address));\n    const [, hexAddr] = key.split(':'); // move genesisHash to top-level (TODO Remove from contracts section?)\n\n    json.meta.genesisHash = json.meta.genesisHash || json.meta.contract && json.meta.contract.genesisHash;\n    this.contracts.add(this._store, address, json);\n    this.rewriteKey(json, key, hexAddr, contractKey);\n  }\n\n  loadInjected(address, meta) {\n    const json = {\n      address,\n      meta: _objectSpread(_objectSpread({}, meta), {}, {\n        isInjected: true\n      })\n    };\n    const pair = this.keyring.addFromAddress(address, json.meta);\n    this.accounts.add(this._store, pair.address, json, pair.type);\n  }\n\n  allowGenesis(json) {\n    if (json && json.meta && this.genesisHash) {\n      const hashes = Object.values(chains).find(hashes => hashes.includes(this.genesisHash || '')) || [this.genesisHash];\n\n      if (json.meta.genesisHash) {\n        return hashes.includes(json.meta.genesisHash);\n      } else if (json.meta.contract) {\n        return hashes.includes(json.meta.contract.genesisHash);\n      }\n    }\n\n    return true;\n  }\n\n  loadAll(options, injected = []) {\n    super.initKeyring(options);\n\n    this._store.all((key, json) => {\n      if (options.filter ? options.filter(json) : true) {\n        try {\n          if (this.allowGenesis(json)) {\n            if (accountRegex.test(key)) {\n              this.loadAccount(json, key);\n            } else if (addressRegex.test(key)) {\n              this.loadAddress(json, key);\n            } else if (contractRegex.test(key)) {\n              this.loadContract(json, key);\n            }\n          }\n        } catch (error) {// ignore\n        }\n      }\n    });\n\n    injected.forEach(account => {\n      if (this.allowGenesis(account)) {\n        try {\n          this.loadInjected(account.address, account.meta);\n        } catch (error) {// ignore\n        }\n      }\n    });\n    this.keyringOption.init(this);\n  }\n\n  restoreAccount(json, password) {\n    const cryptoType = Array.isArray(json.encoding.content) ? json.encoding.content[1] : 'ed25519';\n    const encType = Array.isArray(json.encoding.type) ? json.encoding.type : [json.encoding.type];\n    const pair = createPair({\n      toSS58: this.encodeAddress,\n      type: cryptoType\n    }, {\n      publicKey: this.decodeAddress(json.address, true)\n    }, json.meta, isHex(json.encoded) ? hexToU8a(json.encoded) : base64Decode(json.encoded), encType); // unlock, save account and then lock (locking cleans secretKey, so needs to be last)\n\n    pair.decodePkcs8(password);\n    this.addPair(pair, password);\n    pair.lock();\n    return pair;\n  }\n\n  saveAccount(pair, password) {\n    this.addTimestamp(pair);\n    const json = pair.toJson(password);\n    this.keyring.addFromJson(json);\n    this.accounts.add(this._store, pair.address, json, pair.type);\n    return json;\n  }\n\n  saveAccountMeta(pair, meta) {\n    const address = pair.address;\n\n    this._store.get(accountKey(address), json => {\n      pair.setMeta(meta);\n      json.meta = pair.meta;\n      this.accounts.add(this._store, address, json, pair.type);\n    });\n  }\n\n  saveAddress(address, meta, type = 'address') {\n    const available = this.addresses.subject.getValue();\n    const json = available[address] && available[address].json || {\n      address,\n      meta: {\n        isRecent: undefined,\n        whenCreated: Date.now()\n      }\n    };\n    Object.keys(meta).forEach(key => {\n      json.meta[key] = meta[key];\n    });\n    delete json.meta.isRecent;\n\n    _classPrivateFieldLooseBase(this, _stores)[_stores][type]().add(this._store, address, json);\n\n    return json;\n  }\n\n  saveContract(address, meta) {\n    return this.saveAddress(address, meta, 'contract');\n  }\n\n  saveRecent(address) {\n    const available = this.addresses.subject.getValue();\n\n    if (!available[address]) {\n      this.addresses.add(this._store, address, {\n        address,\n        meta: {\n          genesisHash: this.genesisHash,\n          isRecent: true,\n          whenCreated: Date.now()\n        }\n      });\n    }\n\n    return this.addresses.subject.getValue()[address];\n  }\n\n}"]},"metadata":{},"sourceType":"module"}