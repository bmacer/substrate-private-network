{"ast":null,"code":"// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isNumber, isUndefined } from '@polkadot/util';\nimport { BTreeMap, BTreeSet, CodecSet, Compact, Enum, HashMap, Int, Option, Result, Struct, Tuple, U8aFixed, UInt, Vec, VecFixed } from \"../codec/index.mjs\";\nimport { DoNotConstruct } from \"../primitive/index.mjs\";\nimport { getTypeDef } from \"./getTypeDef.mjs\";\nimport { TypeDefInfo } from \"./types.mjs\";\nexport function createClass(registry, type) {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  return getTypeClass(registry, getTypeDef(type));\n} // An unsafe version of the `createType` below. It's unsafe because the `type`\n// argument here can be any string, which, if it cannot be parsed, it will yield\n// a runtime error.\n\nexport function ClassOfUnsafe(registry, name) {\n  return createClass(registry, name);\n} // alias for createClass\n\nexport function ClassOf(registry, name) {\n  // TS2589: Type instantiation is excessively deep and possibly infinite.\n  // The above happens with as Constructor<InterfaceTypes[K]>;\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n  return ClassOfUnsafe(registry, name);\n}\n\nfunction getSubDefArray(value) {\n  assert(value.sub && Array.isArray(value.sub), `Expected subtype as TypeDef[] in ${JSON.stringify(value)}`);\n  return value.sub;\n}\n\nfunction getSubDef(value) {\n  assert(value.sub && !Array.isArray(value.sub), `Expected subtype as TypeDef in ${JSON.stringify(value)}`);\n  return value.sub;\n}\n\nfunction getSubType(value) {\n  return getSubDef(value).type;\n} // create a maps of type string constructors from the input\n\n\nfunction getTypeClassMap(value) {\n  const result = {};\n  return getSubDefArray(value).reduce((result, sub) => {\n    result[sub.name] = sub.type;\n    return result;\n  }, result);\n} // create an array of type string constructors from the input\n\n\nfunction getTypeClassArray(value) {\n  return getSubDefArray(value).map(({\n    type\n  }) => type);\n}\n\nfunction createInt({\n  displayName,\n  length\n}, Clazz) {\n  assert(isNumber(length), `Expected bitLength information for ${displayName || Clazz.constructor.name}<bitLength>`);\n  return Clazz.with(length, displayName);\n}\n\nfunction createHashMap(value, Clazz) {\n  const [keyType, valueType] = getTypeClassArray(value);\n  return Clazz.with(keyType, valueType);\n}\n\nconst infoMapping = {\n  [TypeDefInfo.BTreeMap]: (registry, value) => createHashMap(value, BTreeMap),\n  [TypeDefInfo.BTreeSet]: (registry, value) => BTreeSet.with(getSubType(value)),\n  [TypeDefInfo.Compact]: (registry, value) => Compact.with(getSubType(value)),\n  [TypeDefInfo.DoNotConstruct]: (registry, value) => DoNotConstruct.with(value.displayName),\n  [TypeDefInfo.Enum]: (registry, value) => Enum.with(getTypeClassMap(value)),\n  [TypeDefInfo.HashMap]: (registry, value) => createHashMap(value, HashMap),\n  [TypeDefInfo.Int]: (registry, value) => createInt(value, Int),\n  // We have circular deps between Linkage & Struct\n  [TypeDefInfo.Linkage]: (registry, value) => {\n    const type = `Option<${getSubType(value)}>`; // eslint-disable-next-line sort-keys\n\n    const Clazz = Struct.with({\n      previous: type,\n      next: type\n    }); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n    Clazz.prototype.toRawType = function () {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call\n      return `Linkage<${this.next.toRawType(true)}>`;\n    };\n\n    return Clazz;\n  },\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  [TypeDefInfo.Null]: (registry, _) => createClass(registry, 'Null'),\n  [TypeDefInfo.Option]: (registry, value) => Option.with(getSubType(value)),\n  [TypeDefInfo.Plain]: (registry, value) => registry.getOrUnknown(value.type),\n  [TypeDefInfo.Result]: (registry, value) => {\n    const [Ok, Error] = getTypeClassArray(value); // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n    return Result.with({\n      Error,\n      Ok\n    });\n  },\n  [TypeDefInfo.Set]: (registry, value) => {\n    const result = {};\n    return CodecSet.with(getSubDefArray(value).reduce((result, {\n      index,\n      name\n    }) => {\n      result[name] = index;\n      return result;\n    }, result), value.length);\n  },\n  [TypeDefInfo.Struct]: (registry, value) => Struct.with(getTypeClassMap(value), value.alias),\n  [TypeDefInfo.Tuple]: (registry, value) => Tuple.with(getTypeClassArray(value)),\n  [TypeDefInfo.UInt]: (registry, value) => createInt(value, UInt),\n  [TypeDefInfo.Vec]: (registry, value) => {\n    const subType = getSubType(value);\n    return subType === 'u8' ? createClass(registry, 'Bytes') : Vec.with(subType);\n  },\n  [TypeDefInfo.VecFixed]: (registry, {\n    displayName,\n    length,\n    sub\n  }) => {\n    assert(isNumber(length) && !isUndefined(sub), 'Expected length & type information for fixed vector');\n    return sub.type === 'u8' ? U8aFixed.with(length * 8, displayName) : VecFixed.with(sub.type, length);\n  }\n}; // Returns the type Class for construction\n\nexport function getTypeClass(registry, value) {\n  const Type = registry.get(value.type);\n\n  if (Type) {\n    return Type;\n  }\n\n  const getFn = infoMapping[value.info];\n  assert(getFn, `Unable to construct class from ${JSON.stringify(value)}`);\n  return getFn(registry, value);\n}","map":{"version":3,"sources":["/Users/bmacer/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/types/create/createClass.mjs"],"names":["assert","isNumber","isUndefined","BTreeMap","BTreeSet","CodecSet","Compact","Enum","HashMap","Int","Option","Result","Struct","Tuple","U8aFixed","UInt","Vec","VecFixed","DoNotConstruct","getTypeDef","TypeDefInfo","createClass","registry","type","getTypeClass","ClassOfUnsafe","name","ClassOf","getSubDefArray","value","sub","Array","isArray","JSON","stringify","getSubDef","getSubType","getTypeClassMap","result","reduce","getTypeClassArray","map","createInt","displayName","length","Clazz","constructor","with","createHashMap","keyType","valueType","infoMapping","Linkage","previous","next","prototype","toRawType","Null","_","Plain","getOrUnknown","Ok","Error","Set","index","alias","subType","Type","get","getFn","info"],"mappings":"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","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isNumber, isUndefined } from '@polkadot/util';\nimport { BTreeMap, BTreeSet, CodecSet, Compact, Enum, HashMap, Int, Option, Result, Struct, Tuple, U8aFixed, UInt, Vec, VecFixed } from \"../codec/index.mjs\";\nimport { DoNotConstruct } from \"../primitive/index.mjs\";\nimport { getTypeDef } from \"./getTypeDef.mjs\";\nimport { TypeDefInfo } from \"./types.mjs\";\nexport function createClass(registry, type) {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  return getTypeClass(registry, getTypeDef(type));\n} // An unsafe version of the `createType` below. It's unsafe because the `type`\n// argument here can be any string, which, if it cannot be parsed, it will yield\n// a runtime error.\n\nexport function ClassOfUnsafe(registry, name) {\n  return createClass(registry, name);\n} // alias for createClass\n\nexport function ClassOf(registry, name) {\n  // TS2589: Type instantiation is excessively deep and possibly infinite.\n  // The above happens with as Constructor<InterfaceTypes[K]>;\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n  return ClassOfUnsafe(registry, name);\n}\n\nfunction getSubDefArray(value) {\n  assert(value.sub && Array.isArray(value.sub), `Expected subtype as TypeDef[] in ${JSON.stringify(value)}`);\n  return value.sub;\n}\n\nfunction getSubDef(value) {\n  assert(value.sub && !Array.isArray(value.sub), `Expected subtype as TypeDef in ${JSON.stringify(value)}`);\n  return value.sub;\n}\n\nfunction getSubType(value) {\n  return getSubDef(value).type;\n} // create a maps of type string constructors from the input\n\n\nfunction getTypeClassMap(value) {\n  const result = {};\n  return getSubDefArray(value).reduce((result, sub) => {\n    result[sub.name] = sub.type;\n    return result;\n  }, result);\n} // create an array of type string constructors from the input\n\n\nfunction getTypeClassArray(value) {\n  return getSubDefArray(value).map(({\n    type\n  }) => type);\n}\n\nfunction createInt({\n  displayName,\n  length\n}, Clazz) {\n  assert(isNumber(length), `Expected bitLength information for ${displayName || Clazz.constructor.name}<bitLength>`);\n  return Clazz.with(length, displayName);\n}\n\nfunction createHashMap(value, Clazz) {\n  const [keyType, valueType] = getTypeClassArray(value);\n  return Clazz.with(keyType, valueType);\n}\n\nconst infoMapping = {\n  [TypeDefInfo.BTreeMap]: (registry, value) => createHashMap(value, BTreeMap),\n  [TypeDefInfo.BTreeSet]: (registry, value) => BTreeSet.with(getSubType(value)),\n  [TypeDefInfo.Compact]: (registry, value) => Compact.with(getSubType(value)),\n  [TypeDefInfo.DoNotConstruct]: (registry, value) => DoNotConstruct.with(value.displayName),\n  [TypeDefInfo.Enum]: (registry, value) => Enum.with(getTypeClassMap(value)),\n  [TypeDefInfo.HashMap]: (registry, value) => createHashMap(value, HashMap),\n  [TypeDefInfo.Int]: (registry, value) => createInt(value, Int),\n  // We have circular deps between Linkage & Struct\n  [TypeDefInfo.Linkage]: (registry, value) => {\n    const type = `Option<${getSubType(value)}>`; // eslint-disable-next-line sort-keys\n\n    const Clazz = Struct.with({\n      previous: type,\n      next: type\n    }); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n    Clazz.prototype.toRawType = function () {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call\n      return `Linkage<${this.next.toRawType(true)}>`;\n    };\n\n    return Clazz;\n  },\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  [TypeDefInfo.Null]: (registry, _) => createClass(registry, 'Null'),\n  [TypeDefInfo.Option]: (registry, value) => Option.with(getSubType(value)),\n  [TypeDefInfo.Plain]: (registry, value) => registry.getOrUnknown(value.type),\n  [TypeDefInfo.Result]: (registry, value) => {\n    const [Ok, Error] = getTypeClassArray(value); // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n    return Result.with({\n      Error,\n      Ok\n    });\n  },\n  [TypeDefInfo.Set]: (registry, value) => {\n    const result = {};\n    return CodecSet.with(getSubDefArray(value).reduce((result, {\n      index,\n      name\n    }) => {\n      result[name] = index;\n      return result;\n    }, result), value.length);\n  },\n  [TypeDefInfo.Struct]: (registry, value) => Struct.with(getTypeClassMap(value), value.alias),\n  [TypeDefInfo.Tuple]: (registry, value) => Tuple.with(getTypeClassArray(value)),\n  [TypeDefInfo.UInt]: (registry, value) => createInt(value, UInt),\n  [TypeDefInfo.Vec]: (registry, value) => {\n    const subType = getSubType(value);\n    return subType === 'u8' ? createClass(registry, 'Bytes') : Vec.with(subType);\n  },\n  [TypeDefInfo.VecFixed]: (registry, {\n    displayName,\n    length,\n    sub\n  }) => {\n    assert(isNumber(length) && !isUndefined(sub), 'Expected length & type information for fixed vector');\n    return sub.type === 'u8' ? U8aFixed.with(length * 8, displayName) : VecFixed.with(sub.type, length);\n  }\n}; // Returns the type Class for construction\n\nexport function getTypeClass(registry, value) {\n  const Type = registry.get(value.type);\n\n  if (Type) {\n    return Type;\n  }\n\n  const getFn = infoMapping[value.info];\n  assert(getFn, `Unable to construct class from ${JSON.stringify(value)}`);\n  return getFn(registry, value);\n}"]},"metadata":{},"sourceType":"module"}