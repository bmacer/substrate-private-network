{"ast":null,"code":"// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, bnToBn, formatNumber, hexToU8a, isHex, isObject, isU8a, u8aToBn, u8aToU8a } from '@polkadot/util';\nimport { Enum } from \"../codec/Enum.mjs\";\nimport { Raw } from \"../codec/Raw.mjs\";\nimport { Tuple } from \"../codec/Tuple.mjs\";\nimport { u64 as U64 } from \"../primitive/U64.mjs\";\nimport { IMMORTAL_ERA } from \"./constants.mjs\";\n\nfunction getTrailingZeros(period) {\n  const binary = period.toString(2);\n  let index = 0;\n\n  while (binary[binary.length - 1 - index] === '0') {\n    index++;\n  }\n\n  return index;\n}\n/**\n * @name ImmortalEra\n * @description\n * The ImmortalEra for an extrinsic\n */\n\n\nexport class ImmortalEra extends Raw {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  constructor(registry, value) {\n    // For immortals, we always provide the known value (i.e. treated as a\n    // constant no matter how it is constructed - it is a fixed structure)\n    super(registry, IMMORTAL_ERA);\n  }\n\n}\n/**\n * @name MortalEra\n * @description\n * The MortalEra for an extrinsic, indicating period and phase\n */\n\nexport class MortalEra extends Tuple {\n  constructor(registry, value) {\n    super(registry, {\n      period: U64,\n      phase: U64\n    }, MortalEra._decodeMortalEra(registry, value));\n  }\n  /** @internal */\n\n\n  static _decodeMortalEra(registry, value) {\n    if (!value) {\n      return [new U64(registry), new U64(registry)];\n    } else if (isU8a(value) || isHex(value) || Array.isArray(value)) {\n      return MortalEra._decodeMortalU8a(registry, u8aToU8a(value));\n    } else if (isObject(value)) {\n      return MortalEra._decodeMortalObject(registry, value);\n    }\n\n    throw new Error('Invalid data passed to Mortal era');\n  }\n  /** @internal */\n\n\n  static _decodeMortalObject(registry, value) {\n    const {\n      current,\n      period\n    } = value;\n    let calPeriod = Math.pow(2, Math.ceil(Math.log2(period)));\n    calPeriod = Math.min(Math.max(calPeriod, 4), 1 << 16);\n    const phase = current % calPeriod;\n    const quantizeFactor = Math.max(calPeriod >> 12, 1);\n    const quantizedPhase = phase / quantizeFactor * quantizeFactor;\n    return [new U64(registry, calPeriod), new U64(registry, quantizedPhase)];\n  }\n  /** @internal */\n\n\n  static _decodeMortalU8a(registry, value) {\n    if (value.length === 0) {\n      return [new U64(registry), new U64(registry)];\n    }\n\n    const first = u8aToBn(value.subarray(0, 1)).toNumber();\n    const second = u8aToBn(value.subarray(1, 2)).toNumber();\n    const encoded = first + (second << 8);\n    const period = 2 << encoded % (1 << 4);\n    const quantizeFactor = Math.max(period >> 12, 1);\n    const phase = (encoded >> 4) * quantizeFactor;\n    assert(period >= 4 && phase < period, 'Invalid data passed to Mortal era');\n    return [new U64(registry, period), new U64(registry, phase)];\n  }\n  /**\n   * @description Encoded length for mortals occupy 2 bytes, different from the actual Tuple since it is encoded. This is a shortcut fro `toU8a().length`\n   */\n\n\n  get encodedLength() {\n    return 2;\n  }\n  /**\n   * @description The period of this Mortal wraps as a [[U64]]\n   */\n\n\n  get period() {\n    return this[0];\n  }\n  /**\n   * @description The phase of this Mortal wraps as a [[U64]]\n   */\n\n\n  get phase() {\n    return this[1];\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman() {\n    return {\n      period: formatNumber(this.period),\n      phase: formatNumber(this.phase)\n    };\n  }\n  /**\n   * @description Returns a JSON representation of the actual value\n   */\n\n\n  toJSON() {\n    return this.toHex();\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the parity-codec specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   * Period and phase are encoded:\n   *   - The period of validity from the block hash found in the signing material.\n   *   - The phase in the period that this transaction's lifetime begins (and, importantly,\n   *     implies which block hash is included in the signature material). If the `period` is\n   *     greater than 1 << 12, then it will be a factor of the times greater than 1<<12 that\n   *     `period` is.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  toU8a(isBare) {\n    const period = this.period.toNumber();\n    const phase = this.phase.toNumber();\n    const quantizeFactor = Math.max(period >> 12, 1);\n    const trailingZeros = getTrailingZeros(period);\n    const encoded = Math.min(15, Math.max(1, trailingZeros - 1)) + (phase / quantizeFactor << 4);\n    const first = encoded >> 8;\n    const second = encoded & 0xff;\n    return new Uint8Array([second, first]);\n  }\n  /**\n   * @description Get the block number of the start of the era whose properties this object describes that `current` belongs to.\n   */\n\n\n  birth(current) {\n    // FIXME No toNumber() here\n    return Math.floor((Math.max(bnToBn(current).toNumber(), this.phase.toNumber()) - this.phase.toNumber()) / this.period.toNumber()) * this.period.toNumber() + this.phase.toNumber();\n  }\n  /**\n   * @description Get the block number of the first block at which the era has ended.\n   */\n\n\n  death(current) {\n    // FIXME No toNumber() here\n    return this.birth(current) + this.period.toNumber();\n  }\n\n}\n/**\n * @name GenericExtrinsicEra\n * @description\n * The era for an extrinsic, indicating either a mortal or immortal extrinsic\n */\n\nexport class GenericExtrinsicEra extends Enum {\n  constructor(registry, value) {\n    super(registry, {\n      ImmortalEra,\n      MortalEra\n    }, GenericExtrinsicEra._decodeExtrinsicEra(value));\n  }\n  /** @internal */\n  // eslint-disable-next-line @typescript-eslint/ban-types\n\n\n  static _decodeExtrinsicEra(value = new Uint8Array()) {\n    if (value instanceof GenericExtrinsicEra) {\n      return GenericExtrinsicEra._decodeExtrinsicEra(value.toU8a());\n    } else if (isHex(value)) {\n      return GenericExtrinsicEra._decodeExtrinsicEra(hexToU8a(value));\n    } else if (!value || isU8a(value)) {\n      return !(value !== null && value !== void 0 && value.length) || value[0] === 0 ? new Uint8Array([0]) : new Uint8Array([1, value[0], value[1]]);\n    } else if (isObject(value)) {\n      // this is to de-serialize from JSON\n      return value.MortalEra ? {\n        MortalEra: value.MortalEra\n      } : value.ImmortalEra ? {\n        ImmortalEra: value.ImmortalEra\n      } : {\n        MortalEra: value\n      };\n    }\n\n    throw new Error('Invalid data passed to Era');\n  }\n  /**\n   * @description Override the encoded length method\n   */\n\n\n  get encodedLength() {\n    return this.isImmortalEra ? this.asImmortalEra.encodedLength : this.asMortalEra.encodedLength;\n  }\n  /**\n   * @description Returns the item as a [[ImmortalEra]]\n   */\n\n\n  get asImmortalEra() {\n    assert(this.isImmortalEra, `Cannot convert '${this.type}' via asImmortalEra`);\n    return this.value;\n  }\n  /**\n   * @description Returns the item as a [[MortalEra]]\n   */\n\n\n  get asMortalEra() {\n    assert(this.isMortalEra, `Cannot convert '${this.type}' via asMortalEra`);\n    return this.value;\n  }\n  /**\n   * @description `true` if Immortal\n   */\n\n\n  get isImmortalEra() {\n    return this.index === 0;\n  }\n  /**\n   * @description `true` if Mortal\n   */\n\n\n  get isMortalEra() {\n    return this.index > 0;\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the parity-codec specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    return this.isMortalEra ? this.asMortalEra.toU8a(isBare) : this.asImmortalEra.toU8a(isBare);\n  }\n\n}","map":{"version":3,"sources":["/Users/bmacer/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/types/extrinsic/ExtrinsicEra.mjs"],"names":["assert","bnToBn","formatNumber","hexToU8a","isHex","isObject","isU8a","u8aToBn","u8aToU8a","Enum","Raw","Tuple","u64","U64","IMMORTAL_ERA","getTrailingZeros","period","binary","toString","index","length","ImmortalEra","constructor","registry","value","MortalEra","phase","_decodeMortalEra","Array","isArray","_decodeMortalU8a","_decodeMortalObject","Error","current","calPeriod","Math","pow","ceil","log2","min","max","quantizeFactor","quantizedPhase","first","subarray","toNumber","second","encoded","encodedLength","toHuman","toJSON","toHex","toU8a","isBare","trailingZeros","Uint8Array","birth","floor","death","GenericExtrinsicEra","_decodeExtrinsicEra","isImmortalEra","asImmortalEra","asMortalEra","type","isMortalEra"],"mappings":"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","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, bnToBn, formatNumber, hexToU8a, isHex, isObject, isU8a, u8aToBn, u8aToU8a } from '@polkadot/util';\nimport { Enum } from \"../codec/Enum.mjs\";\nimport { Raw } from \"../codec/Raw.mjs\";\nimport { Tuple } from \"../codec/Tuple.mjs\";\nimport { u64 as U64 } from \"../primitive/U64.mjs\";\nimport { IMMORTAL_ERA } from \"./constants.mjs\";\n\nfunction getTrailingZeros(period) {\n  const binary = period.toString(2);\n  let index = 0;\n\n  while (binary[binary.length - 1 - index] === '0') {\n    index++;\n  }\n\n  return index;\n}\n/**\n * @name ImmortalEra\n * @description\n * The ImmortalEra for an extrinsic\n */\n\n\nexport class ImmortalEra extends Raw {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  constructor(registry, value) {\n    // For immortals, we always provide the known value (i.e. treated as a\n    // constant no matter how it is constructed - it is a fixed structure)\n    super(registry, IMMORTAL_ERA);\n  }\n\n}\n/**\n * @name MortalEra\n * @description\n * The MortalEra for an extrinsic, indicating period and phase\n */\n\nexport class MortalEra extends Tuple {\n  constructor(registry, value) {\n    super(registry, {\n      period: U64,\n      phase: U64\n    }, MortalEra._decodeMortalEra(registry, value));\n  }\n  /** @internal */\n\n\n  static _decodeMortalEra(registry, value) {\n    if (!value) {\n      return [new U64(registry), new U64(registry)];\n    } else if (isU8a(value) || isHex(value) || Array.isArray(value)) {\n      return MortalEra._decodeMortalU8a(registry, u8aToU8a(value));\n    } else if (isObject(value)) {\n      return MortalEra._decodeMortalObject(registry, value);\n    }\n\n    throw new Error('Invalid data passed to Mortal era');\n  }\n  /** @internal */\n\n\n  static _decodeMortalObject(registry, value) {\n    const {\n      current,\n      period\n    } = value;\n    let calPeriod = Math.pow(2, Math.ceil(Math.log2(period)));\n    calPeriod = Math.min(Math.max(calPeriod, 4), 1 << 16);\n    const phase = current % calPeriod;\n    const quantizeFactor = Math.max(calPeriod >> 12, 1);\n    const quantizedPhase = phase / quantizeFactor * quantizeFactor;\n    return [new U64(registry, calPeriod), new U64(registry, quantizedPhase)];\n  }\n  /** @internal */\n\n\n  static _decodeMortalU8a(registry, value) {\n    if (value.length === 0) {\n      return [new U64(registry), new U64(registry)];\n    }\n\n    const first = u8aToBn(value.subarray(0, 1)).toNumber();\n    const second = u8aToBn(value.subarray(1, 2)).toNumber();\n    const encoded = first + (second << 8);\n    const period = 2 << encoded % (1 << 4);\n    const quantizeFactor = Math.max(period >> 12, 1);\n    const phase = (encoded >> 4) * quantizeFactor;\n    assert(period >= 4 && phase < period, 'Invalid data passed to Mortal era');\n    return [new U64(registry, period), new U64(registry, phase)];\n  }\n  /**\n   * @description Encoded length for mortals occupy 2 bytes, different from the actual Tuple since it is encoded. This is a shortcut fro `toU8a().length`\n   */\n\n\n  get encodedLength() {\n    return 2;\n  }\n  /**\n   * @description The period of this Mortal wraps as a [[U64]]\n   */\n\n\n  get period() {\n    return this[0];\n  }\n  /**\n   * @description The phase of this Mortal wraps as a [[U64]]\n   */\n\n\n  get phase() {\n    return this[1];\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman() {\n    return {\n      period: formatNumber(this.period),\n      phase: formatNumber(this.phase)\n    };\n  }\n  /**\n   * @description Returns a JSON representation of the actual value\n   */\n\n\n  toJSON() {\n    return this.toHex();\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the parity-codec specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   * Period and phase are encoded:\n   *   - The period of validity from the block hash found in the signing material.\n   *   - The phase in the period that this transaction's lifetime begins (and, importantly,\n   *     implies which block hash is included in the signature material). If the `period` is\n   *     greater than 1 << 12, then it will be a factor of the times greater than 1<<12 that\n   *     `period` is.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  toU8a(isBare) {\n    const period = this.period.toNumber();\n    const phase = this.phase.toNumber();\n    const quantizeFactor = Math.max(period >> 12, 1);\n    const trailingZeros = getTrailingZeros(period);\n    const encoded = Math.min(15, Math.max(1, trailingZeros - 1)) + (phase / quantizeFactor << 4);\n    const first = encoded >> 8;\n    const second = encoded & 0xff;\n    return new Uint8Array([second, first]);\n  }\n  /**\n   * @description Get the block number of the start of the era whose properties this object describes that `current` belongs to.\n   */\n\n\n  birth(current) {\n    // FIXME No toNumber() here\n    return Math.floor((Math.max(bnToBn(current).toNumber(), this.phase.toNumber()) - this.phase.toNumber()) / this.period.toNumber()) * this.period.toNumber() + this.phase.toNumber();\n  }\n  /**\n   * @description Get the block number of the first block at which the era has ended.\n   */\n\n\n  death(current) {\n    // FIXME No toNumber() here\n    return this.birth(current) + this.period.toNumber();\n  }\n\n}\n/**\n * @name GenericExtrinsicEra\n * @description\n * The era for an extrinsic, indicating either a mortal or immortal extrinsic\n */\n\nexport class GenericExtrinsicEra extends Enum {\n  constructor(registry, value) {\n    super(registry, {\n      ImmortalEra,\n      MortalEra\n    }, GenericExtrinsicEra._decodeExtrinsicEra(value));\n  }\n  /** @internal */\n  // eslint-disable-next-line @typescript-eslint/ban-types\n\n\n  static _decodeExtrinsicEra(value = new Uint8Array()) {\n    if (value instanceof GenericExtrinsicEra) {\n      return GenericExtrinsicEra._decodeExtrinsicEra(value.toU8a());\n    } else if (isHex(value)) {\n      return GenericExtrinsicEra._decodeExtrinsicEra(hexToU8a(value));\n    } else if (!value || isU8a(value)) {\n      return !(value !== null && value !== void 0 && value.length) || value[0] === 0 ? new Uint8Array([0]) : new Uint8Array([1, value[0], value[1]]);\n    } else if (isObject(value)) {\n      // this is to de-serialize from JSON\n      return value.MortalEra ? {\n        MortalEra: value.MortalEra\n      } : value.ImmortalEra ? {\n        ImmortalEra: value.ImmortalEra\n      } : {\n        MortalEra: value\n      };\n    }\n\n    throw new Error('Invalid data passed to Era');\n  }\n  /**\n   * @description Override the encoded length method\n   */\n\n\n  get encodedLength() {\n    return this.isImmortalEra ? this.asImmortalEra.encodedLength : this.asMortalEra.encodedLength;\n  }\n  /**\n   * @description Returns the item as a [[ImmortalEra]]\n   */\n\n\n  get asImmortalEra() {\n    assert(this.isImmortalEra, `Cannot convert '${this.type}' via asImmortalEra`);\n    return this.value;\n  }\n  /**\n   * @description Returns the item as a [[MortalEra]]\n   */\n\n\n  get asMortalEra() {\n    assert(this.isMortalEra, `Cannot convert '${this.type}' via asMortalEra`);\n    return this.value;\n  }\n  /**\n   * @description `true` if Immortal\n   */\n\n\n  get isImmortalEra() {\n    return this.index === 0;\n  }\n  /**\n   * @description `true` if Mortal\n   */\n\n\n  get isMortalEra() {\n    return this.index > 0;\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the parity-codec specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    return this.isMortalEra ? this.asMortalEra.toU8a(isBare) : this.asImmortalEra.toU8a(isBare);\n  }\n\n}"]},"metadata":{},"sourceType":"module"}