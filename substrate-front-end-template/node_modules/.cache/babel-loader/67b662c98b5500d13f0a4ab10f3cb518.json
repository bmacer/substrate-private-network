{"ast":null,"code":"// Copyright 2017-2021 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n// Original implementation: https://github.com/paritytech/polka-ui/blob/4858c094684769080f5811f32b081dd7780b0880/src/polkadot.js#L34\nimport { assert, u8aConcat } from '@polkadot/util';\nimport { base58Encode } from \"../base58/encode.mjs\";\nimport { decodeAddress } from \"./decode.mjs\";\nimport { defaults } from \"./defaults.mjs\";\nimport { sshash } from \"./sshash.mjs\";\nexport function encodeAddress(_key, ss58Format = defaults.prefix) {\n  // decode it, this means we can re-encode an address\n  const key = decodeAddress(_key);\n  assert(ss58Format >= 0 && ss58Format <= 16383 && ![46, 47].includes(ss58Format), 'Out of range ss58Format specified');\n  assert(defaults.allowedDecodedLengths.includes(key.length), `Expected a valid key to convert, with length ${defaults.allowedDecodedLengths.join(', ')}`);\n  const isPublicKey = [32, 33].includes(key.length);\n  const input = u8aConcat(new Uint8Array(ss58Format < 64 ? [ss58Format] : [(ss58Format & 0b0000000011111100) >> 2 | 0b01000000, ss58Format >> 8 | (ss58Format & 0b0000000000000011) << 6]), key);\n  return base58Encode(u8aConcat(input, sshash(input).subarray(0, isPublicKey ? 2 : 1)));\n}","map":{"version":3,"sources":["/Users/bmacer/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/util-crypto/address/encode.mjs"],"names":["assert","u8aConcat","base58Encode","decodeAddress","defaults","sshash","encodeAddress","_key","ss58Format","prefix","key","includes","allowedDecodedLengths","length","join","isPublicKey","input","Uint8Array","subarray"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,MAAT,EAAiBC,SAAjB,QAAkC,gBAAlC;AACA,SAASC,YAAT,QAA6B,sBAA7B;AACA,SAASC,aAAT,QAA8B,cAA9B;AACA,SAASC,QAAT,QAAyB,gBAAzB;AACA,SAASC,MAAT,QAAuB,cAAvB;AACA,OAAO,SAASC,aAAT,CAAuBC,IAAvB,EAA6BC,UAAU,GAAGJ,QAAQ,CAACK,MAAnD,EAA2D;AAChE;AACA,QAAMC,GAAG,GAAGP,aAAa,CAACI,IAAD,CAAzB;AACAP,EAAAA,MAAM,CAACQ,UAAU,IAAI,CAAd,IAAmBA,UAAU,IAAI,KAAjC,IAA0C,CAAC,CAAC,EAAD,EAAK,EAAL,EAASG,QAAT,CAAkBH,UAAlB,CAA5C,EAA2E,mCAA3E,CAAN;AACAR,EAAAA,MAAM,CAACI,QAAQ,CAACQ,qBAAT,CAA+BD,QAA/B,CAAwCD,GAAG,CAACG,MAA5C,CAAD,EAAuD,gDAA+CT,QAAQ,CAACQ,qBAAT,CAA+BE,IAA/B,CAAoC,IAApC,CAA0C,EAAhJ,CAAN;AACA,QAAMC,WAAW,GAAG,CAAC,EAAD,EAAK,EAAL,EAASJ,QAAT,CAAkBD,GAAG,CAACG,MAAtB,CAApB;AACA,QAAMG,KAAK,GAAGf,SAAS,CAAC,IAAIgB,UAAJ,CAAeT,UAAU,GAAG,EAAb,GAAkB,CAACA,UAAD,CAAlB,GAAiC,CAAC,CAACA,UAAU,GAAG,kBAAd,KAAqC,CAArC,GAAyC,UAA1C,EAAsDA,UAAU,IAAI,CAAd,GAAkB,CAACA,UAAU,GAAG,kBAAd,KAAqC,CAA7G,CAAhD,CAAD,EAAmKE,GAAnK,CAAvB;AACA,SAAOR,YAAY,CAACD,SAAS,CAACe,KAAD,EAAQX,MAAM,CAACW,KAAD,CAAN,CAAcE,QAAd,CAAuB,CAAvB,EAA0BH,WAAW,GAAG,CAAH,GAAO,CAA5C,CAAR,CAAV,CAAnB;AACD","sourcesContent":["// Copyright 2017-2021 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n// Original implementation: https://github.com/paritytech/polka-ui/blob/4858c094684769080f5811f32b081dd7780b0880/src/polkadot.js#L34\nimport { assert, u8aConcat } from '@polkadot/util';\nimport { base58Encode } from \"../base58/encode.mjs\";\nimport { decodeAddress } from \"./decode.mjs\";\nimport { defaults } from \"./defaults.mjs\";\nimport { sshash } from \"./sshash.mjs\";\nexport function encodeAddress(_key, ss58Format = defaults.prefix) {\n  // decode it, this means we can re-encode an address\n  const key = decodeAddress(_key);\n  assert(ss58Format >= 0 && ss58Format <= 16383 && ![46, 47].includes(ss58Format), 'Out of range ss58Format specified');\n  assert(defaults.allowedDecodedLengths.includes(key.length), `Expected a valid key to convert, with length ${defaults.allowedDecodedLengths.join(', ')}`);\n  const isPublicKey = [32, 33].includes(key.length);\n  const input = u8aConcat(new Uint8Array(ss58Format < 64 ? [ss58Format] : [(ss58Format & 0b0000000011111100) >> 2 | 0b01000000, ss58Format >> 8 | (ss58Format & 0b0000000000000011) << 6]), key);\n  return base58Encode(u8aConcat(input, sshash(input).subarray(0, isPublicKey ? 2 : 1)));\n}"]},"metadata":{},"sourceType":"module"}