{"ast":null,"code":"// Copyright 2017-2021 @polkadot/util authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * @description\n * Encoding and decoding of parity-codec compact numbers. The codec is created\n * to take up the least amount of space for a specific number. It performs the\n * same function as Length, however differs in that it uses a variable number of\n * bytes to do the actual encoding. From the Rust implementation for compact\n * encoding:\n *\n *     0b00 00 00 00 / 00 00 00 00 / 00 00 00 00 / 00 00 00 00\n * (0 ... 2**6 - 1)    (u8)\n *     xx xx xx 00\n * (2**6 ... 2**14 - 1)  (u8, u16)  low LH high\n *     yL yL yL 01 / yH yH yH yL\n * (2**14 ... 2**30 - 1)  (u16, u32)  low LMMH high\n *     zL zL zL 10 / zM zM zM zL / zM zM zM zM / zH zH zH zM\n * (2**30 ... 2**536 - 1)  (u32, u64, u128, U256, U512, U520) straight LE-encoded\n *     nn nn nn 11 [ / zz zz zz zz ]{4 + n}\n *\n * Note: we use *LOW BITS* of the LSB in LE encoding to encode the 2 bit key.\n */\nexport { compactAddLength } from \"./addLength.mjs\";\nexport { compactStripLength } from \"./stripLength.mjs\";\nexport { compactFromU8a } from \"./fromU8a.mjs\";\nexport { compactToU8a } from \"./toU8a.mjs\";","map":{"version":3,"sources":["/Users/bmacer/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/util/compact/index.mjs"],"names":["compactAddLength","compactStripLength","compactFromU8a","compactToU8a"],"mappings":"AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,gBAAT,QAAiC,iBAAjC;AACA,SAASC,kBAAT,QAAmC,mBAAnC;AACA,SAASC,cAAT,QAA+B,eAA/B;AACA,SAASC,YAAT,QAA6B,aAA7B","sourcesContent":["// Copyright 2017-2021 @polkadot/util authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * @description\n * Encoding and decoding of parity-codec compact numbers. The codec is created\n * to take up the least amount of space for a specific number. It performs the\n * same function as Length, however differs in that it uses a variable number of\n * bytes to do the actual encoding. From the Rust implementation for compact\n * encoding:\n *\n *     0b00 00 00 00 / 00 00 00 00 / 00 00 00 00 / 00 00 00 00\n * (0 ... 2**6 - 1)    (u8)\n *     xx xx xx 00\n * (2**6 ... 2**14 - 1)  (u8, u16)  low LH high\n *     yL yL yL 01 / yH yH yH yL\n * (2**14 ... 2**30 - 1)  (u16, u32)  low LMMH high\n *     zL zL zL 10 / zM zM zM zL / zM zM zM zM / zH zH zH zM\n * (2**30 ... 2**536 - 1)  (u32, u64, u128, U256, U512, U520) straight LE-encoded\n *     nn nn nn 11 [ / zz zz zz zz ]{4 + n}\n *\n * Note: we use *LOW BITS* of the LSB in LE encoding to encode the 2 bit key.\n */\nexport { compactAddLength } from \"./addLength.mjs\";\nexport { compactStripLength } from \"./stripLength.mjs\";\nexport { compactFromU8a } from \"./fromU8a.mjs\";\nexport { compactToU8a } from \"./toU8a.mjs\";"]},"metadata":{},"sourceType":"module"}