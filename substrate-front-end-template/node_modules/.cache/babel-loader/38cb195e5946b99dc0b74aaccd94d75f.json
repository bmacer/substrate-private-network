{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/api authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport BN from 'bn.js';\nimport { decorateDerive } from '@polkadot/api-derive';\nimport { memo } from '@polkadot/api-derive/util';\nimport { expandMetadata } from '@polkadot/metadata';\nimport { RpcCore } from '@polkadot/rpc-core';\nimport { WsProvider } from '@polkadot/rpc-provider';\nimport { TypeRegistry } from '@polkadot/types/create';\nimport { DEFAULT_VERSION as EXTRINSIC_DEFAULT_VERSION } from '@polkadot/types/extrinsic/constants';\nimport { unwrapStorageType } from '@polkadot/types/primitive/StorageKey';\nimport { arrayChunk, arrayFlatten, assert, compactStripLength, logger, u8aToHex } from '@polkadot/util';\nimport { BehaviorSubject, combineLatest, of } from '@polkadot/x-rxjs';\nimport { map, switchMap, tap, toArray } from '@polkadot/x-rxjs/operators';\nimport { createSubmittable } from \"../submittable/index.mjs\";\nimport { augmentObject } from \"../util/augmentObject.mjs\";\nimport { decorateSections } from \"../util/decorate.mjs\";\nimport { extractStorageArgs } from \"../util/validate.mjs\";\nimport { Events } from \"./Events.mjs\"; // the max amount of keys/values that we will retrieve at once\n\nconst PAGE_SIZE = 384;\nconst l = logger('api/init');\nlet instanceCounter = 0;\n\nvar _instanceId = _classPrivateFieldLooseKey(\"instanceId\");\n\nvar _registry = _classPrivateFieldLooseKey(\"registry\");\n\nexport class Decorate extends Events {\n  // HACK Use BN import so decorateDerive works... yes, wtf.\n\n  /**\n   * This is the one and only method concrete children classes need to implement.\n   * It's a higher-order function, which takes one argument\n   * `method: Method extends (...args: any[]) => Observable<any>`\n   * (and one optional `options`), and should return the user facing method.\n   * For example:\n   * - For ApiRx, `decorateMethod` should just be identity, because the input\n   * function is already an Observable\n   * - For ApiPromise, `decorateMethod` should return a function that takes all\n   * the parameters from `method`, adds an optional `callback` argument, and\n   * returns a Promise.\n   *\n   * We could easily imagine other user-facing interfaces, which are simply\n   * implemented by transforming the Observable to Stream/Iterator/Kefir/Bacon\n   * via `decorateMethod`.\n   */\n\n  /**\n   * @description Create an instance of the class\n   *\n   * @param options Options object to create API instance or a Provider instance\n   *\n   * @example\n   * <BR>\n   *\n   * ```javascript\n   * import Api from '@polkadot/api/promise';\n   *\n   * const api = new Api().isReady();\n   *\n   * api.rpc.subscribeNewHeads((header) => {\n   *   console.log(`new block #${header.number.toNumber()}`);\n   * });\n   * ```\n   */\n  constructor(options, type, decorateMethod) {\n    var _options$source;\n\n    super();\n    Object.defineProperty(this, _instanceId, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _registry, {\n      writable: true,\n      value: void 0\n    });\n    this.__phantom = new BN(0);\n    this._consts = {};\n    this._derive = void 0;\n    this._errors = {};\n    this._events = {};\n    this._extrinsics = void 0;\n    this._extrinsicType = EXTRINSIC_DEFAULT_VERSION;\n    this._genesisHash = void 0;\n    this._isConnected = void 0;\n    this._isReady = false;\n    this._options = void 0;\n    this._query = {};\n    this._queryMulti = void 0;\n    this._rpc = void 0;\n    this._rpcCore = void 0;\n    this._runtimeChain = void 0;\n    this._runtimeMetadata = void 0;\n    this._runtimeVersion = void 0;\n    this._rx = {\n      consts: {},\n      query: {},\n      tx: {}\n    };\n    this._type = void 0;\n    this._decorateMethod = void 0;\n\n    this._rxDecorateMethod = method => {\n      return method;\n    };\n\n    _classPrivateFieldLooseBase(this, _instanceId)[_instanceId] = `${++instanceCounter}`;\n    _classPrivateFieldLooseBase(this, _registry)[_registry] = ((_options$source = options.source) === null || _options$source === void 0 ? void 0 : _options$source.registry) || options.registry || new TypeRegistry();\n    const thisProvider = options.source ? options.source._rpcCore.provider.clone() : options.provider || new WsProvider();\n    this._decorateMethod = decorateMethod;\n    this._options = options;\n    this._type = type;\n    this._rpcCore = new RpcCore(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], _classPrivateFieldLooseBase(this, _registry)[_registry], thisProvider, this._options.rpc);\n    this._isConnected = new BehaviorSubject(this._rpcCore.provider.isConnected);\n    this._rx.hasSubscriptions = this._rpcCore.provider.hasSubscriptions;\n    this._rx.registry = _classPrivateFieldLooseBase(this, _registry)[_registry];\n  }\n  /**\n   * @description Return the current used registry\n   */\n\n\n  get registry() {\n    return _classPrivateFieldLooseBase(this, _registry)[_registry];\n  }\n  /**\n   * @description Creates an instance of a type as registered\n   */\n\n\n  createType(type, ...params) {\n    return _classPrivateFieldLooseBase(this, _registry)[_registry].createType(type, ...params);\n  }\n  /**\n   * @description Register additional user-defined of chain-specific types in the type registry\n   */\n\n\n  registerTypes(types) {\n    types && _classPrivateFieldLooseBase(this, _registry)[_registry].register(types);\n  }\n  /**\n   * @returns `true` if the API operates with subscriptions\n   */\n\n\n  get hasSubscriptions() {\n    return this._rpcCore.provider.hasSubscriptions;\n  }\n  /**\n   * @returns `true` if the API decorate multi-key queries\n   */\n\n\n  get supportMulti() {\n    return this._rpcCore.provider.hasSubscriptions || !!this._rpcCore.state.queryStorageAt;\n  }\n\n  injectMetadata(metadata, fromEmpty, registry) {\n    const decoratedMeta = expandMetadata(registry || _classPrivateFieldLooseBase(this, _registry)[_registry], metadata);\n\n    if (fromEmpty || !this._extrinsics) {\n      this._extrinsics = this._decorateExtrinsics(decoratedMeta, this._decorateMethod);\n      this._rx.tx = this._decorateExtrinsics(decoratedMeta, this._rxDecorateMethod);\n    } else {\n      augmentObject('tx', this._decorateExtrinsics(decoratedMeta, this._decorateMethod), this._extrinsics, false);\n      augmentObject(null, this._decorateExtrinsics(decoratedMeta, this._rxDecorateMethod), this._rx.tx, false);\n    } // this API\n\n\n    augmentObject('query', this._decorateStorage(decoratedMeta, this._decorateMethod), this._query, fromEmpty);\n    augmentObject('consts', decoratedMeta.consts, this._consts, fromEmpty);\n    augmentObject('errors', decoratedMeta.errors, this._errors, fromEmpty);\n    augmentObject('events', decoratedMeta.events, this._events, fromEmpty); // rx\n\n    augmentObject(null, this._decorateStorage(decoratedMeta, this._rxDecorateMethod), this._rx.query, fromEmpty);\n    augmentObject(null, decoratedMeta.consts, this._rx.consts, fromEmpty);\n  }\n\n  _decorateFunctionMeta(input, output) {\n    output.meta = input.meta;\n    output.method = input.method;\n    output.section = input.section;\n    output.toJSON = input.toJSON;\n\n    if (input.callIndex) {\n      output.callIndex = input.callIndex;\n    }\n\n    return output;\n  } // Filter all RPC methods based on the results of the rpc_methods call. We do this in the following\n  // manner to cater for both old and new:\n  //   - when the number of entries are 0, only remove the ones with isOptional (account & contracts)\n  //   - when non-zero, remove anything that is not in the array (we don't do this)\n\n\n  _filterRpc(rpcMethods, additional) {\n    const methods = rpcMethods.methods.map(t => t.toString()); // add any specific user-base RPCs\n\n    if (Object.keys(additional).length !== 0) {\n      this._rpcCore.addUserInterfaces(additional); // re-decorate, only adding any new additional interfaces\n\n\n      this._decorateRpc(this._rpcCore, this._decorateMethod, this._rpc);\n\n      this._decorateRpc(this._rpcCore, this._rxDecorateMethod, this._rx.rpc);\n    }\n\n    this._filterRpcMethods(methods);\n  }\n\n  _filterRpcMethods(exposed) {\n    const hasResults = exposed.length !== 0;\n    const allKnown = [...this._rpcCore.mapping.entries()];\n    const allKeys = allKnown.reduce((allKeys, [, {\n      alias,\n      endpoint,\n      method,\n      pubsub,\n      section\n    }]) => {\n      allKeys.push(`${section}_${method}`);\n\n      if (pubsub) {\n        allKeys.push(`${section}_${pubsub[1]}`);\n        allKeys.push(`${section}_${pubsub[2]}`);\n      }\n\n      if (alias) {\n        allKeys.push(...alias);\n      }\n\n      if (endpoint) {\n        allKeys.push(endpoint);\n      }\n\n      return allKeys;\n    }, []);\n    const unknown = exposed.filter(key => !allKeys.includes(key));\n\n    if (unknown.length) {\n      l.warn(`RPC methods not decorated: ${unknown.join(', ')}`);\n    } // loop through all entries we have (populated in decorate) and filter as required\n    // only remove when we have results and method missing, or with no results if optional\n\n\n    allKnown.filter(([key]) => hasResults ? !exposed.includes(key) && key !== 'rpc_methods' // rpc_methods doesn't appear, v1\n    : key === 'rpc_methods' // we didn't find this one, remove\n    ) // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    .forEach(([_, {\n      method,\n      section\n    }]) => {\n      delete this._rpc[section][method];\n      delete this._rpcCore[section][method];\n      delete this._rx.rpc[section][method];\n    });\n  }\n\n  _decorateRpc(rpc, decorateMethod, input = {}) {\n    return rpc.sections.reduce((out, _sectionName) => {\n      const sectionName = _sectionName;\n\n      if (!out[sectionName]) {\n        // out and section here are horrors to get right from a typing perspective :(\n        out[sectionName] = Object.entries(rpc[sectionName]).reduce((section, [methodName, method]) => {\n          //  skip subscriptions where we have a non-subscribe interface\n          if (this.hasSubscriptions || !(methodName.startsWith('subscribe') || methodName.startsWith('unsubscribe'))) {\n            section[methodName] = decorateMethod(method, {\n              methodName\n            }); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n            section[methodName].json = decorateMethod(method.json, {\n              methodName\n            }); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n            section[methodName].raw = decorateMethod(method.raw, {\n              methodName\n            });\n          }\n\n          return section;\n        }, {});\n      }\n\n      return out;\n    }, input);\n  } // only be called if supportMulti is true\n\n\n  _decorateMulti(decorateMethod) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return decorateMethod(calls => (this.hasSubscriptions ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt)(calls.map(arg => Array.isArray(arg) ? [arg[0].creator, ...arg.slice(1)] : [arg.creator])));\n  }\n\n  _decorateExtrinsics({\n    tx\n  }, decorateMethod) {\n    const creator = createSubmittable(this._type, this._rx, decorateMethod);\n    return Object.entries(tx).reduce((out, [name, section]) => {\n      out[name] = Object.entries(section).reduce((out, [name, method]) => {\n        out[name] = this._decorateExtrinsicEntry(method, creator);\n        return out;\n      }, {});\n      return out;\n    }, creator);\n  }\n\n  _decorateExtrinsicEntry(method, creator) {\n    const decorated = (...params) => creator(method(...params)); // pass through the `.is`\n\n\n    decorated.is = other => method.is(other); // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n\n\n    return this._decorateFunctionMeta(method, decorated);\n  }\n\n  _decorateStorage({\n    query\n  }, decorateMethod) {\n    return Object.entries(query).reduce((out, [name, section]) => {\n      out[name] = Object.entries(section).reduce((out, [name, method]) => {\n        out[name] = this._decorateStorageEntry(method, decorateMethod);\n        return out;\n      }, {});\n      return out;\n    }, {});\n  }\n\n  _decorateStorageEntry(creator, decorateMethod) {\n    // get the storage arguments, with DoubleMap as an array entry, otherwise spread\n    const getArgs = (...args) => extractStorageArgs(creator, args); // Disable this where it occurs for each field we are decorating\n\n    /* eslint-disable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n\n\n    const decorated = this._decorateStorageCall(creator, decorateMethod);\n\n    decorated.creator = creator;\n    decorated.at = decorateMethod((hash, arg1, arg2) => this._rpcCore.state.getStorage(getArgs(arg1, arg2), hash));\n    decorated.hash = decorateMethod((arg1, arg2) => this._rpcCore.state.getStorageHash(getArgs(arg1, arg2)));\n\n    decorated.is = key => key.section === creator.section && key.method === creator.method;\n\n    decorated.key = (arg1, arg2) => u8aToHex(compactStripLength(creator(creator.meta.type.isDoubleMap ? [arg1, arg2] : arg1))[1]);\n\n    decorated.keyPrefix = key1 => u8aToHex(creator.keyPrefix(key1));\n\n    decorated.range = decorateMethod((range, arg1, arg2) => this._decorateStorageRange(decorated, [arg1, arg2], range));\n    decorated.size = decorateMethod((arg1, arg2) => this._rpcCore.state.getStorageSize(getArgs(arg1, arg2)));\n    decorated.sizeAt = decorateMethod((hash, arg1, arg2) => this._rpcCore.state.getStorageSize(getArgs(arg1, arg2), hash)); // .keys() & .entries() only available on map types\n\n    if (creator.iterKey && (creator.meta.type.isMap || creator.meta.type.isDoubleMap)) {\n      decorated.entries = decorateMethod(memo(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], doubleMapArg => this._retrieveMapEntries(creator, null, doubleMapArg)));\n      decorated.entriesAt = decorateMethod(memo(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], (hash, doubleMapArg) => this._retrieveMapEntries(creator, hash, doubleMapArg)));\n      decorated.entriesPaged = decorateMethod(memo(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], opts => this._retrieveMapEntriesPaged(creator, opts)));\n      decorated.keys = decorateMethod(memo(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], doubleMapArg => this._retrieveMapKeys(creator, null, doubleMapArg)));\n      decorated.keysAt = decorateMethod(memo(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], (hash, doubleMapArg) => this._retrieveMapKeys(creator, hash, doubleMapArg)));\n      decorated.keysPaged = decorateMethod(memo(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], opts => this._retrieveMapKeysPaged(creator, opts)));\n    }\n\n    if (this.supportMulti) {\n      // When using double map storage function, user need to pass double map key as an array\n      decorated.multi = decorateMethod(args => this._retrieveMulti(args.map(arg => [creator, arg])));\n    }\n    /* eslint-enable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n\n\n    return this._decorateFunctionMeta(creator, decorated);\n  } // Decorate the base storage call. In the case or rxjs or promise-without-callback (await)\n  // we make a subscription, alternatively we push this through a single-shot query\n\n\n  _decorateStorageCall(creator, decorateMethod) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return decorateMethod((...args) => {\n      return this.hasSubscriptions ? this._rpcCore.state.subscribeStorage([extractStorageArgs(creator, args)]).pipe(map(([data]) => data) // extract first/only result from list\n      ) : this._rpcCore.state.getStorage(extractStorageArgs(creator, args));\n    }, {\n      methodName: creator.method,\n      overrideNoSub: (...args) => this._rpcCore.state.getStorage(extractStorageArgs(creator, args))\n    });\n  }\n\n  _decorateStorageRange(decorated, args, range) {\n    const outputType = unwrapStorageType(decorated.creator.meta.type, decorated.creator.meta.modifier.isOptional);\n    return this._rpcCore.state.queryStorage([decorated.key(...args)], ...range).pipe(map(result => result.map(([blockHash, [value]]) => [blockHash, this.createType(outputType, value.isSome ? value.unwrap().toHex() : undefined)])));\n  } // retrieve a set of values for a specific set of keys - here we chunk the keys into PAGE_SIZE sizes\n\n\n  _retrieveMulti(keys) {\n    if (!keys.length) {\n      return of([]);\n    }\n\n    return combineLatest(arrayChunk(keys, PAGE_SIZE).map(keys => (this.hasSubscriptions ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt)(keys))).pipe(map(valsArr => arrayFlatten(valsArr)));\n  }\n\n  _retrieveMapKeys({\n    iterKey,\n    meta,\n    method,\n    section\n  }, at, arg) {\n    assert(iterKey && (meta.type.isMap || meta.type.isDoubleMap), 'keys can only be retrieved on maps, linked maps and double maps');\n    const headKey = iterKey(arg).toHex();\n    const startSubject = new BehaviorSubject(headKey);\n    const query = at ? startKey => this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE, startKey, at) : startKey => this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE, startKey);\n    return startSubject.pipe(switchMap(startKey => query(startKey).pipe(map(keys => keys.map(key => key.setMeta(meta, section, method))))), tap(keys => {\n      keys.length === PAGE_SIZE ? startSubject.next(keys[PAGE_SIZE - 1].toHex()) : startSubject.complete();\n    }), toArray(), // toArray since we want to startSubject to be completed\n    map(keysArr => arrayFlatten(keysArr)));\n  }\n\n  _retrieveMapKeysPaged({\n    iterKey,\n    meta,\n    method,\n    section\n  }, opts) {\n    assert(iterKey && (meta.type.isMap || meta.type.isDoubleMap), 'keys can only be retrieved on maps, linked maps and double maps');\n    const headKey = iterKey(opts.arg).toHex();\n    return this._rpcCore.state.getKeysPaged(headKey, opts.pageSize, opts.startKey || headKey).pipe(map(keys => keys.map(key => key.setMeta(meta, section, method))));\n  }\n\n  _retrieveMapEntries(entry, at, arg) {\n    const query = at ? keyset => this._rpcCore.state.queryStorageAt(keyset, at) : keyset => this._rpcCore.state.queryStorageAt(keyset);\n    return this._retrieveMapKeys(entry, at, arg).pipe(switchMap(keys => keys.length ? combineLatest(arrayChunk(keys, PAGE_SIZE).map(query)).pipe(map(valsArr => arrayFlatten(valsArr).map((value, index) => [keys[index], value]))) : of([])));\n  }\n\n  _retrieveMapEntriesPaged(entry, opts) {\n    return this._retrieveMapKeysPaged(entry, opts).pipe(switchMap(keys => keys.length ? this._rpcCore.state.queryStorageAt(keys).pipe(map(valsArr => valsArr.map((value, index) => [keys[index], value]))) : of([])));\n  }\n\n  _decorateDeriveRx(decorateMethod) {\n    var _this$_runtimeVersion, _this$_options$typesB, _this$_options$typesB2, _this$_options$typesB3;\n\n    const specName = (_this$_runtimeVersion = this._runtimeVersion) === null || _this$_runtimeVersion === void 0 ? void 0 : _this$_runtimeVersion.specName.toString();\n\n    const derives = _objectSpread(_objectSpread({}, this._options.derives), ((_this$_options$typesB = this._options.typesBundle) === null || _this$_options$typesB === void 0 ? void 0 : (_this$_options$typesB2 = _this$_options$typesB.spec) === null || _this$_options$typesB2 === void 0 ? void 0 : (_this$_options$typesB3 = _this$_options$typesB2[specName !== null && specName !== void 0 ? specName : '']) === null || _this$_options$typesB3 === void 0 ? void 0 : _this$_options$typesB3.derives) || {}); // Pull in derive from api-derive\n\n\n    const derive = decorateDerive(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], this._rx, derives);\n    return decorateSections(derive, decorateMethod);\n  }\n\n  _decorateDerive(decorateMethod) {\n    return decorateSections(this._rx.derive, decorateMethod);\n  }\n  /**\n   * Put the `this.onCall` function of ApiRx here, because it is needed by\n   * `api._rx`.\n   */\n\n\n}","map":{"version":3,"sources":["/Users/bmacer/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/api/base/Decorate.mjs"],"names":["_defineProperty","_classPrivateFieldLooseBase","_classPrivateFieldLooseKey","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","BN","decorateDerive","memo","expandMetadata","RpcCore","WsProvider","TypeRegistry","DEFAULT_VERSION","EXTRINSIC_DEFAULT_VERSION","unwrapStorageType","arrayChunk","arrayFlatten","assert","compactStripLength","logger","u8aToHex","BehaviorSubject","combineLatest","of","map","switchMap","tap","toArray","createSubmittable","augmentObject","decorateSections","extractStorageArgs","Events","PAGE_SIZE","l","instanceCounter","_instanceId","_registry","Decorate","constructor","options","type","decorateMethod","_options$source","writable","value","__phantom","_consts","_derive","_errors","_events","_extrinsics","_extrinsicType","_genesisHash","_isConnected","_isReady","_options","_query","_queryMulti","_rpc","_rpcCore","_runtimeChain","_runtimeMetadata","_runtimeVersion","_rx","consts","query","tx","_type","_decorateMethod","_rxDecorateMethod","method","registry","thisProvider","provider","clone","rpc","isConnected","hasSubscriptions","createType","params","registerTypes","types","register","supportMulti","state","queryStorageAt","injectMetadata","metadata","fromEmpty","decoratedMeta","_decorateExtrinsics","_decorateStorage","errors","events","_decorateFunctionMeta","input","output","meta","section","toJSON","callIndex","_filterRpc","rpcMethods","additional","methods","t","toString","addUserInterfaces","_decorateRpc","_filterRpcMethods","exposed","hasResults","allKnown","mapping","entries","allKeys","reduce","alias","endpoint","pubsub","unknown","includes","warn","join","_","sections","out","_sectionName","sectionName","methodName","startsWith","json","raw","_decorateMulti","calls","subscribeStorage","arg","Array","isArray","creator","slice","name","_decorateExtrinsicEntry","decorated","is","other","_decorateStorageEntry","getArgs","args","_decorateStorageCall","at","hash","arg1","arg2","getStorage","getStorageHash","isDoubleMap","keyPrefix","key1","range","_decorateStorageRange","size","getStorageSize","sizeAt","iterKey","isMap","doubleMapArg","_retrieveMapEntries","entriesAt","entriesPaged","opts","_retrieveMapEntriesPaged","_retrieveMapKeys","keysAt","keysPaged","_retrieveMapKeysPaged","multi","_retrieveMulti","pipe","data","overrideNoSub","outputType","modifier","isOptional","queryStorage","result","blockHash","isSome","unwrap","toHex","undefined","valsArr","headKey","startSubject","startKey","getKeysPaged","setMeta","next","complete","keysArr","pageSize","entry","keyset","index","_decorateDeriveRx","_this$_runtimeVersion","_this$_options$typesB","_this$_options$typesB2","_this$_options$typesB3","specName","derives","typesBundle","spec","derive","_decorateDerive"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/api authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport BN from 'bn.js';\nimport { decorateDerive } from '@polkadot/api-derive';\nimport { memo } from '@polkadot/api-derive/util';\nimport { expandMetadata } from '@polkadot/metadata';\nimport { RpcCore } from '@polkadot/rpc-core';\nimport { WsProvider } from '@polkadot/rpc-provider';\nimport { TypeRegistry } from '@polkadot/types/create';\nimport { DEFAULT_VERSION as EXTRINSIC_DEFAULT_VERSION } from '@polkadot/types/extrinsic/constants';\nimport { unwrapStorageType } from '@polkadot/types/primitive/StorageKey';\nimport { arrayChunk, arrayFlatten, assert, compactStripLength, logger, u8aToHex } from '@polkadot/util';\nimport { BehaviorSubject, combineLatest, of } from '@polkadot/x-rxjs';\nimport { map, switchMap, tap, toArray } from '@polkadot/x-rxjs/operators';\nimport { createSubmittable } from \"../submittable/index.mjs\";\nimport { augmentObject } from \"../util/augmentObject.mjs\";\nimport { decorateSections } from \"../util/decorate.mjs\";\nimport { extractStorageArgs } from \"../util/validate.mjs\";\nimport { Events } from \"./Events.mjs\";\n// the max amount of keys/values that we will retrieve at once\nconst PAGE_SIZE = 384;\nconst l = logger('api/init');\nlet instanceCounter = 0;\n\nvar _instanceId = _classPrivateFieldLooseKey(\"instanceId\");\n\nvar _registry = _classPrivateFieldLooseKey(\"registry\");\n\nexport class Decorate extends Events {\n  // HACK Use BN import so decorateDerive works... yes, wtf.\n\n  /**\n   * This is the one and only method concrete children classes need to implement.\n   * It's a higher-order function, which takes one argument\n   * `method: Method extends (...args: any[]) => Observable<any>`\n   * (and one optional `options`), and should return the user facing method.\n   * For example:\n   * - For ApiRx, `decorateMethod` should just be identity, because the input\n   * function is already an Observable\n   * - For ApiPromise, `decorateMethod` should return a function that takes all\n   * the parameters from `method`, adds an optional `callback` argument, and\n   * returns a Promise.\n   *\n   * We could easily imagine other user-facing interfaces, which are simply\n   * implemented by transforming the Observable to Stream/Iterator/Kefir/Bacon\n   * via `decorateMethod`.\n   */\n\n  /**\n   * @description Create an instance of the class\n   *\n   * @param options Options object to create API instance or a Provider instance\n   *\n   * @example\n   * <BR>\n   *\n   * ```javascript\n   * import Api from '@polkadot/api/promise';\n   *\n   * const api = new Api().isReady();\n   *\n   * api.rpc.subscribeNewHeads((header) => {\n   *   console.log(`new block #${header.number.toNumber()}`);\n   * });\n   * ```\n   */\n  constructor(options, type, decorateMethod) {\n    var _options$source;\n\n    super();\n    Object.defineProperty(this, _instanceId, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _registry, {\n      writable: true,\n      value: void 0\n    });\n    this.__phantom = new BN(0);\n    this._consts = {};\n    this._derive = void 0;\n    this._errors = {};\n    this._events = {};\n    this._extrinsics = void 0;\n    this._extrinsicType = EXTRINSIC_DEFAULT_VERSION;\n    this._genesisHash = void 0;\n    this._isConnected = void 0;\n    this._isReady = false;\n    this._options = void 0;\n    this._query = {};\n    this._queryMulti = void 0;\n    this._rpc = void 0;\n    this._rpcCore = void 0;\n    this._runtimeChain = void 0;\n    this._runtimeMetadata = void 0;\n    this._runtimeVersion = void 0;\n    this._rx = {\n      consts: {},\n      query: {},\n      tx: {}\n    };\n    this._type = void 0;\n    this._decorateMethod = void 0;\n\n    this._rxDecorateMethod = method => {\n      return method;\n    };\n\n    _classPrivateFieldLooseBase(this, _instanceId)[_instanceId] = `${++instanceCounter}`;\n    _classPrivateFieldLooseBase(this, _registry)[_registry] = ((_options$source = options.source) === null || _options$source === void 0 ? void 0 : _options$source.registry) || options.registry || new TypeRegistry();\n    const thisProvider = options.source ? options.source._rpcCore.provider.clone() : options.provider || new WsProvider();\n    this._decorateMethod = decorateMethod;\n    this._options = options;\n    this._type = type;\n    this._rpcCore = new RpcCore(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], _classPrivateFieldLooseBase(this, _registry)[_registry], thisProvider, this._options.rpc);\n    this._isConnected = new BehaviorSubject(this._rpcCore.provider.isConnected);\n    this._rx.hasSubscriptions = this._rpcCore.provider.hasSubscriptions;\n    this._rx.registry = _classPrivateFieldLooseBase(this, _registry)[_registry];\n  }\n  /**\n   * @description Return the current used registry\n   */\n\n\n  get registry() {\n    return _classPrivateFieldLooseBase(this, _registry)[_registry];\n  }\n  /**\n   * @description Creates an instance of a type as registered\n   */\n\n\n  createType(type, ...params) {\n    return _classPrivateFieldLooseBase(this, _registry)[_registry].createType(type, ...params);\n  }\n  /**\n   * @description Register additional user-defined of chain-specific types in the type registry\n   */\n\n\n  registerTypes(types) {\n    types && _classPrivateFieldLooseBase(this, _registry)[_registry].register(types);\n  }\n  /**\n   * @returns `true` if the API operates with subscriptions\n   */\n\n\n  get hasSubscriptions() {\n    return this._rpcCore.provider.hasSubscriptions;\n  }\n  /**\n   * @returns `true` if the API decorate multi-key queries\n   */\n\n\n  get supportMulti() {\n    return this._rpcCore.provider.hasSubscriptions || !!this._rpcCore.state.queryStorageAt;\n  }\n\n  injectMetadata(metadata, fromEmpty, registry) {\n    const decoratedMeta = expandMetadata(registry || _classPrivateFieldLooseBase(this, _registry)[_registry], metadata);\n\n    if (fromEmpty || !this._extrinsics) {\n      this._extrinsics = this._decorateExtrinsics(decoratedMeta, this._decorateMethod);\n      this._rx.tx = this._decorateExtrinsics(decoratedMeta, this._rxDecorateMethod);\n    } else {\n      augmentObject('tx', this._decorateExtrinsics(decoratedMeta, this._decorateMethod), this._extrinsics, false);\n      augmentObject(null, this._decorateExtrinsics(decoratedMeta, this._rxDecorateMethod), this._rx.tx, false);\n    } // this API\n\n\n    augmentObject('query', this._decorateStorage(decoratedMeta, this._decorateMethod), this._query, fromEmpty);\n    augmentObject('consts', decoratedMeta.consts, this._consts, fromEmpty);\n    augmentObject('errors', decoratedMeta.errors, this._errors, fromEmpty);\n    augmentObject('events', decoratedMeta.events, this._events, fromEmpty); // rx\n\n    augmentObject(null, this._decorateStorage(decoratedMeta, this._rxDecorateMethod), this._rx.query, fromEmpty);\n    augmentObject(null, decoratedMeta.consts, this._rx.consts, fromEmpty);\n  }\n\n  _decorateFunctionMeta(input, output) {\n    output.meta = input.meta;\n    output.method = input.method;\n    output.section = input.section;\n    output.toJSON = input.toJSON;\n\n    if (input.callIndex) {\n      output.callIndex = input.callIndex;\n    }\n\n    return output;\n  } // Filter all RPC methods based on the results of the rpc_methods call. We do this in the following\n  // manner to cater for both old and new:\n  //   - when the number of entries are 0, only remove the ones with isOptional (account & contracts)\n  //   - when non-zero, remove anything that is not in the array (we don't do this)\n\n\n  _filterRpc(rpcMethods, additional) {\n    const methods = rpcMethods.methods.map(t => t.toString()); // add any specific user-base RPCs\n\n    if (Object.keys(additional).length !== 0) {\n      this._rpcCore.addUserInterfaces(additional); // re-decorate, only adding any new additional interfaces\n\n\n      this._decorateRpc(this._rpcCore, this._decorateMethod, this._rpc);\n\n      this._decorateRpc(this._rpcCore, this._rxDecorateMethod, this._rx.rpc);\n    }\n\n    this._filterRpcMethods(methods);\n  }\n\n  _filterRpcMethods(exposed) {\n    const hasResults = exposed.length !== 0;\n    const allKnown = [...this._rpcCore.mapping.entries()];\n    const allKeys = allKnown.reduce((allKeys, [, {\n      alias,\n      endpoint,\n      method,\n      pubsub,\n      section\n    }]) => {\n      allKeys.push(`${section}_${method}`);\n\n      if (pubsub) {\n        allKeys.push(`${section}_${pubsub[1]}`);\n        allKeys.push(`${section}_${pubsub[2]}`);\n      }\n\n      if (alias) {\n        allKeys.push(...alias);\n      }\n\n      if (endpoint) {\n        allKeys.push(endpoint);\n      }\n\n      return allKeys;\n    }, []);\n    const unknown = exposed.filter(key => !allKeys.includes(key));\n\n    if (unknown.length) {\n      l.warn(`RPC methods not decorated: ${unknown.join(', ')}`);\n    } // loop through all entries we have (populated in decorate) and filter as required\n    // only remove when we have results and method missing, or with no results if optional\n\n\n    allKnown.filter(([key]) => hasResults ? !exposed.includes(key) && key !== 'rpc_methods' // rpc_methods doesn't appear, v1\n    : key === 'rpc_methods' // we didn't find this one, remove\n    ) // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    .forEach(([_, {\n      method,\n      section\n    }]) => {\n      delete this._rpc[section][method];\n      delete this._rpcCore[section][method];\n      delete this._rx.rpc[section][method];\n    });\n  }\n\n  _decorateRpc(rpc, decorateMethod, input = {}) {\n    return rpc.sections.reduce((out, _sectionName) => {\n      const sectionName = _sectionName;\n\n      if (!out[sectionName]) {\n        // out and section here are horrors to get right from a typing perspective :(\n        out[sectionName] = Object.entries(rpc[sectionName]).reduce((section, [methodName, method]) => {\n          //  skip subscriptions where we have a non-subscribe interface\n          if (this.hasSubscriptions || !(methodName.startsWith('subscribe') || methodName.startsWith('unsubscribe'))) {\n            section[methodName] = decorateMethod(method, {\n              methodName\n            }); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n            section[methodName].json = decorateMethod(method.json, {\n              methodName\n            }); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n            section[methodName].raw = decorateMethod(method.raw, {\n              methodName\n            });\n          }\n\n          return section;\n        }, {});\n      }\n\n      return out;\n    }, input);\n  } // only be called if supportMulti is true\n\n\n  _decorateMulti(decorateMethod) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return decorateMethod(calls => (this.hasSubscriptions ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt)(calls.map(arg => Array.isArray(arg) ? [arg[0].creator, ...arg.slice(1)] : [arg.creator])));\n  }\n\n  _decorateExtrinsics({\n    tx\n  }, decorateMethod) {\n    const creator = createSubmittable(this._type, this._rx, decorateMethod);\n    return Object.entries(tx).reduce((out, [name, section]) => {\n      out[name] = Object.entries(section).reduce((out, [name, method]) => {\n        out[name] = this._decorateExtrinsicEntry(method, creator);\n        return out;\n      }, {});\n      return out;\n    }, creator);\n  }\n\n  _decorateExtrinsicEntry(method, creator) {\n    const decorated = (...params) => creator(method(...params)); // pass through the `.is`\n\n\n    decorated.is = other => method.is(other); // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n\n\n    return this._decorateFunctionMeta(method, decorated);\n  }\n\n  _decorateStorage({\n    query\n  }, decorateMethod) {\n    return Object.entries(query).reduce((out, [name, section]) => {\n      out[name] = Object.entries(section).reduce((out, [name, method]) => {\n        out[name] = this._decorateStorageEntry(method, decorateMethod);\n        return out;\n      }, {});\n      return out;\n    }, {});\n  }\n\n  _decorateStorageEntry(creator, decorateMethod) {\n    // get the storage arguments, with DoubleMap as an array entry, otherwise spread\n    const getArgs = (...args) => extractStorageArgs(creator, args); // Disable this where it occurs for each field we are decorating\n\n    /* eslint-disable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n\n\n    const decorated = this._decorateStorageCall(creator, decorateMethod);\n\n    decorated.creator = creator;\n    decorated.at = decorateMethod((hash, arg1, arg2) => this._rpcCore.state.getStorage(getArgs(arg1, arg2), hash));\n    decorated.hash = decorateMethod((arg1, arg2) => this._rpcCore.state.getStorageHash(getArgs(arg1, arg2)));\n\n    decorated.is = key => key.section === creator.section && key.method === creator.method;\n\n    decorated.key = (arg1, arg2) => u8aToHex(compactStripLength(creator(creator.meta.type.isDoubleMap ? [arg1, arg2] : arg1))[1]);\n\n    decorated.keyPrefix = key1 => u8aToHex(creator.keyPrefix(key1));\n\n    decorated.range = decorateMethod((range, arg1, arg2) => this._decorateStorageRange(decorated, [arg1, arg2], range));\n    decorated.size = decorateMethod((arg1, arg2) => this._rpcCore.state.getStorageSize(getArgs(arg1, arg2)));\n    decorated.sizeAt = decorateMethod((hash, arg1, arg2) => this._rpcCore.state.getStorageSize(getArgs(arg1, arg2), hash)); // .keys() & .entries() only available on map types\n\n    if (creator.iterKey && (creator.meta.type.isMap || creator.meta.type.isDoubleMap)) {\n      decorated.entries = decorateMethod(memo(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], doubleMapArg => this._retrieveMapEntries(creator, null, doubleMapArg)));\n      decorated.entriesAt = decorateMethod(memo(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], (hash, doubleMapArg) => this._retrieveMapEntries(creator, hash, doubleMapArg)));\n      decorated.entriesPaged = decorateMethod(memo(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], opts => this._retrieveMapEntriesPaged(creator, opts)));\n      decorated.keys = decorateMethod(memo(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], doubleMapArg => this._retrieveMapKeys(creator, null, doubleMapArg)));\n      decorated.keysAt = decorateMethod(memo(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], (hash, doubleMapArg) => this._retrieveMapKeys(creator, hash, doubleMapArg)));\n      decorated.keysPaged = decorateMethod(memo(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], opts => this._retrieveMapKeysPaged(creator, opts)));\n    }\n\n    if (this.supportMulti) {\n      // When using double map storage function, user need to pass double map key as an array\n      decorated.multi = decorateMethod(args => this._retrieveMulti(args.map(arg => [creator, arg])));\n    }\n    /* eslint-enable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n\n\n    return this._decorateFunctionMeta(creator, decorated);\n  } // Decorate the base storage call. In the case or rxjs or promise-without-callback (await)\n  // we make a subscription, alternatively we push this through a single-shot query\n\n\n  _decorateStorageCall(creator, decorateMethod) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return decorateMethod((...args) => {\n      return this.hasSubscriptions ? this._rpcCore.state.subscribeStorage([extractStorageArgs(creator, args)]).pipe(map(([data]) => data) // extract first/only result from list\n      ) : this._rpcCore.state.getStorage(extractStorageArgs(creator, args));\n    }, {\n      methodName: creator.method,\n      overrideNoSub: (...args) => this._rpcCore.state.getStorage(extractStorageArgs(creator, args))\n    });\n  }\n\n  _decorateStorageRange(decorated, args, range) {\n    const outputType = unwrapStorageType(decorated.creator.meta.type, decorated.creator.meta.modifier.isOptional);\n    return this._rpcCore.state.queryStorage([decorated.key(...args)], ...range).pipe(map(result => result.map(([blockHash, [value]]) => [blockHash, this.createType(outputType, value.isSome ? value.unwrap().toHex() : undefined)])));\n  } // retrieve a set of values for a specific set of keys - here we chunk the keys into PAGE_SIZE sizes\n\n\n  _retrieveMulti(keys) {\n    if (!keys.length) {\n      return of([]);\n    }\n\n    return combineLatest(arrayChunk(keys, PAGE_SIZE).map(keys => (this.hasSubscriptions ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt)(keys))).pipe(map(valsArr => arrayFlatten(valsArr)));\n  }\n\n  _retrieveMapKeys({\n    iterKey,\n    meta,\n    method,\n    section\n  }, at, arg) {\n    assert(iterKey && (meta.type.isMap || meta.type.isDoubleMap), 'keys can only be retrieved on maps, linked maps and double maps');\n    const headKey = iterKey(arg).toHex();\n    const startSubject = new BehaviorSubject(headKey);\n    const query = at ? startKey => this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE, startKey, at) : startKey => this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE, startKey);\n    return startSubject.pipe(switchMap(startKey => query(startKey).pipe(map(keys => keys.map(key => key.setMeta(meta, section, method))))), tap(keys => {\n      keys.length === PAGE_SIZE ? startSubject.next(keys[PAGE_SIZE - 1].toHex()) : startSubject.complete();\n    }), toArray(), // toArray since we want to startSubject to be completed\n    map(keysArr => arrayFlatten(keysArr)));\n  }\n\n  _retrieveMapKeysPaged({\n    iterKey,\n    meta,\n    method,\n    section\n  }, opts) {\n    assert(iterKey && (meta.type.isMap || meta.type.isDoubleMap), 'keys can only be retrieved on maps, linked maps and double maps');\n    const headKey = iterKey(opts.arg).toHex();\n    return this._rpcCore.state.getKeysPaged(headKey, opts.pageSize, opts.startKey || headKey).pipe(map(keys => keys.map(key => key.setMeta(meta, section, method))));\n  }\n\n  _retrieveMapEntries(entry, at, arg) {\n    const query = at ? keyset => this._rpcCore.state.queryStorageAt(keyset, at) : keyset => this._rpcCore.state.queryStorageAt(keyset);\n    return this._retrieveMapKeys(entry, at, arg).pipe(switchMap(keys => keys.length ? combineLatest(arrayChunk(keys, PAGE_SIZE).map(query)).pipe(map(valsArr => arrayFlatten(valsArr).map((value, index) => [keys[index], value]))) : of([])));\n  }\n\n  _retrieveMapEntriesPaged(entry, opts) {\n    return this._retrieveMapKeysPaged(entry, opts).pipe(switchMap(keys => keys.length ? this._rpcCore.state.queryStorageAt(keys).pipe(map(valsArr => valsArr.map((value, index) => [keys[index], value]))) : of([])));\n  }\n\n  _decorateDeriveRx(decorateMethod) {\n    var _this$_runtimeVersion, _this$_options$typesB, _this$_options$typesB2, _this$_options$typesB3;\n\n    const specName = (_this$_runtimeVersion = this._runtimeVersion) === null || _this$_runtimeVersion === void 0 ? void 0 : _this$_runtimeVersion.specName.toString();\n\n    const derives = _objectSpread(_objectSpread({}, this._options.derives), ((_this$_options$typesB = this._options.typesBundle) === null || _this$_options$typesB === void 0 ? void 0 : (_this$_options$typesB2 = _this$_options$typesB.spec) === null || _this$_options$typesB2 === void 0 ? void 0 : (_this$_options$typesB3 = _this$_options$typesB2[specName !== null && specName !== void 0 ? specName : '']) === null || _this$_options$typesB3 === void 0 ? void 0 : _this$_options$typesB3.derives) || {}); // Pull in derive from api-derive\n\n\n    const derive = decorateDerive(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], this._rx, derives);\n    return decorateSections(derive, decorateMethod);\n  }\n\n  _decorateDerive(decorateMethod) {\n    return decorateSections(this._rx.derive, decorateMethod);\n  }\n  /**\n   * Put the `this.onCall` function of ApiRx here, because it is needed by\n   * `api._rx`.\n   */\n\n\n}"]},"metadata":{},"sourceType":"module"}