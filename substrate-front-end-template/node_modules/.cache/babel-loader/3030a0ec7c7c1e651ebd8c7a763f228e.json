{"ast":null,"code":"// Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { combineLatest, of } from '@polkadot/x-rxjs';\nimport { map, switchMap } from '@polkadot/x-rxjs/operators';\nimport { memo } from \"../util/index.mjs\";\nexport function nextElected(instanceId, api) {\n  return memo(instanceId, () => api.query.staking.erasStakers ? api.derive.session.indexes().pipe( // only populate for next era in the last session, so track both here - entries are not\n  // subscriptions, so we need a trigger - currentIndex acts as that trigger to refresh\n  switchMap(({\n    currentEra\n  }) => api.query.staking.erasStakers.keys(currentEra)), map(keys => keys.map(key => key.args[1]))) : api.query.staking.currentElected());\n}\n/**\n * @description Retrieve latest list of validators\n */\n\nexport function validators(instanceId, api) {\n  return memo(instanceId, () => // Sadly the node-template is (for some obscure reason) not comprehensive, so while the derive works\n  // in all actual real-world deployed chains, it does create some confusion for limited template chains\n  combineLatest([api.query.session ? api.query.session.validators() : of([]), api.query.staking ? api.derive.staking.nextElected() : of([])]).pipe(map(([validators, nextElected]) => ({\n    nextElected: nextElected.length ? nextElected : validators,\n    validators\n  }))));\n}","map":{"version":3,"sources":["/Users/bmacer/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/api-derive/staking/validators.mjs"],"names":["combineLatest","of","map","switchMap","memo","nextElected","instanceId","api","query","staking","erasStakers","derive","session","indexes","pipe","currentEra","keys","key","args","currentElected","validators","length"],"mappings":"AAAA;AACA;AACA,SAASA,aAAT,EAAwBC,EAAxB,QAAkC,kBAAlC;AACA,SAASC,GAAT,EAAcC,SAAd,QAA+B,4BAA/B;AACA,SAASC,IAAT,QAAqB,mBAArB;AACA,OAAO,SAASC,WAAT,CAAqBC,UAArB,EAAiCC,GAAjC,EAAsC;AAC3C,SAAOH,IAAI,CAACE,UAAD,EAAa,MAAMC,GAAG,CAACC,KAAJ,CAAUC,OAAV,CAAkBC,WAAlB,GAAgCH,GAAG,CAACI,MAAJ,CAAWC,OAAX,CAAmBC,OAAnB,GAA6BC,IAA7B,EAAmC;AACjG;AACAX,EAAAA,SAAS,CAAC,CAAC;AACTY,IAAAA;AADS,GAAD,KAEJR,GAAG,CAACC,KAAJ,CAAUC,OAAV,CAAkBC,WAAlB,CAA8BM,IAA9B,CAAmCD,UAAnC,CAFG,CAFqD,EAIPb,GAAG,CAACc,IAAI,IAAIA,IAAI,CAACd,GAAL,CAASe,GAAG,IAAIA,GAAG,CAACC,IAAJ,CAAS,CAAT,CAAhB,CAAT,CAJI,CAAhC,GAIsEX,GAAG,CAACC,KAAJ,CAAUC,OAAV,CAAkBU,cAAlB,EAJzF,CAAX;AAKD;AACD;AACA;AACA;;AAEA,OAAO,SAASC,UAAT,CAAoBd,UAApB,EAAgCC,GAAhC,EAAqC;AAC1C,SAAOH,IAAI,CAACE,UAAD,EAAa,MAAM;AAC9B;AACAN,EAAAA,aAAa,CAAC,CAACO,GAAG,CAACC,KAAJ,CAAUI,OAAV,GAAoBL,GAAG,CAACC,KAAJ,CAAUI,OAAV,CAAkBQ,UAAlB,EAApB,GAAqDnB,EAAE,CAAC,EAAD,CAAxD,EAA8DM,GAAG,CAACC,KAAJ,CAAUC,OAAV,GAAoBF,GAAG,CAACI,MAAJ,CAAWF,OAAX,CAAmBJ,WAAnB,EAApB,GAAuDJ,EAAE,CAAC,EAAD,CAAvH,CAAD,CAAb,CAA4Ia,IAA5I,CAAiJZ,GAAG,CAAC,CAAC,CAACkB,UAAD,EAAaf,WAAb,CAAD,MAAgC;AACnLA,IAAAA,WAAW,EAAEA,WAAW,CAACgB,MAAZ,GAAqBhB,WAArB,GAAmCe,UADmI;AAEnLA,IAAAA;AAFmL,GAAhC,CAAD,CAApJ,CAFW,CAAX;AAMD","sourcesContent":["// Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { combineLatest, of } from '@polkadot/x-rxjs';\nimport { map, switchMap } from '@polkadot/x-rxjs/operators';\nimport { memo } from \"../util/index.mjs\";\nexport function nextElected(instanceId, api) {\n  return memo(instanceId, () => api.query.staking.erasStakers ? api.derive.session.indexes().pipe( // only populate for next era in the last session, so track both here - entries are not\n  // subscriptions, so we need a trigger - currentIndex acts as that trigger to refresh\n  switchMap(({\n    currentEra\n  }) => api.query.staking.erasStakers.keys(currentEra)), map(keys => keys.map(key => key.args[1]))) : api.query.staking.currentElected());\n}\n/**\n * @description Retrieve latest list of validators\n */\n\nexport function validators(instanceId, api) {\n  return memo(instanceId, () => // Sadly the node-template is (for some obscure reason) not comprehensive, so while the derive works\n  // in all actual real-world deployed chains, it does create some confusion for limited template chains\n  combineLatest([api.query.session ? api.query.session.validators() : of([]), api.query.staking ? api.derive.staking.nextElected() : of([])]).pipe(map(([validators, nextElected]) => ({\n    nextElected: nextElected.length ? nextElected : validators,\n    validators\n  }))));\n}"]},"metadata":{},"sourceType":"module"}