{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/rpc-provider authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable camelcase */\n\n\nimport EventEmitter from 'eventemitter3';\nimport { assert, isChildClass, isNull, isUndefined, logger } from '@polkadot/util';\nimport { xglobal } from '@polkadot/x-global';\nimport { WebSocket } from '@polkadot/x-ws';\nimport { RpcCoder } from \"../coder/index.mjs\";\nimport defaults from \"../defaults.mjs\";\nimport { getWSErrorString } from \"./errors.mjs\";\nconst ALIASSES = {\n  chain_finalisedHead: 'chain_finalizedHead',\n  chain_subscribeFinalisedHeads: 'chain_subscribeFinalizedHeads',\n  chain_unsubscribeFinalisedHeads: 'chain_unsubscribeFinalizedHeads'\n};\nconst RETRY_DELAY = 1000;\nconst l = logger('api-ws');\n/**\n * # @polkadot/rpc-provider/ws\n *\n * @name WsProvider\n *\n * @description The WebSocket Provider allows sending requests using WebSocket to a WebSocket RPC server TCP port. Unlike the [[HttpProvider]], it does support subscriptions and allows listening to events such as new blocks or balance changes.\n *\n * @example\n * <BR>\n *\n * ```javascript\n * import Api from '@polkadot/api/promise';\n * import { WsProvider } from '@polkadot/rpc-provider/ws';\n *\n * const provider = new WsProvider('ws://127.0.0.1:9944');\n * const api = new Api(provider);\n * ```\n *\n * @see [[HttpProvider]]\n */\n\nvar _coder = _classPrivateFieldLooseKey(\"coder\");\n\nvar _endpoints = _classPrivateFieldLooseKey(\"endpoints\");\n\nvar _headers = _classPrivateFieldLooseKey(\"headers\");\n\nvar _eventemitter = _classPrivateFieldLooseKey(\"eventemitter\");\n\nvar _handlers = _classPrivateFieldLooseKey(\"handlers\");\n\nvar _isReadyPromise = _classPrivateFieldLooseKey(\"isReadyPromise\");\n\nvar _waitingForId = _classPrivateFieldLooseKey(\"waitingForId\");\n\nvar _autoConnectMs = _classPrivateFieldLooseKey(\"autoConnectMs\");\n\nvar _endpointIndex = _classPrivateFieldLooseKey(\"endpointIndex\");\n\nvar _isConnected = _classPrivateFieldLooseKey(\"isConnected\");\n\nvar _subscriptions = _classPrivateFieldLooseKey(\"subscriptions\");\n\nvar _websocket = _classPrivateFieldLooseKey(\"websocket\");\n\nvar _emit = _classPrivateFieldLooseKey(\"emit\");\n\nvar _onSocketClose = _classPrivateFieldLooseKey(\"onSocketClose\");\n\nvar _onSocketError = _classPrivateFieldLooseKey(\"onSocketError\");\n\nvar _onSocketMessage = _classPrivateFieldLooseKey(\"onSocketMessage\");\n\nvar _onSocketMessageResult = _classPrivateFieldLooseKey(\"onSocketMessageResult\");\n\nvar _onSocketMessageSubscribe = _classPrivateFieldLooseKey(\"onSocketMessageSubscribe\");\n\nvar _onSocketOpen = _classPrivateFieldLooseKey(\"onSocketOpen\");\n\nvar _resubscribe = _classPrivateFieldLooseKey(\"resubscribe\");\n\nexport class WsProvider {\n  /**\n   * @param {string | string[]}  endpoint    The endpoint url. Usually `ws://ip:9944` or `wss://ip:9944`, may provide an array of endpoint strings.\n   * @param {boolean} autoConnect Whether to connect automatically or not.\n   */\n  constructor(endpoint = defaults.WS_URL, autoConnectMs = RETRY_DELAY, headers = {}) {\n    Object.defineProperty(this, _coder, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _endpoints, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _headers, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _eventemitter, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _handlers, {\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, _isReadyPromise, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _waitingForId, {\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, _autoConnectMs, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _endpointIndex, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _isConnected, {\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, _subscriptions, {\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, _websocket, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _emit, {\n      writable: true,\n      value: (type, ...args) => {\n        _classPrivateFieldLooseBase(this, _eventemitter)[_eventemitter].emit(type, ...args);\n      }\n    });\n    Object.defineProperty(this, _onSocketClose, {\n      writable: true,\n      value: event => {\n        if (_classPrivateFieldLooseBase(this, _autoConnectMs)[_autoConnectMs] > 0) {\n          l.error(`disconnected from ${_classPrivateFieldLooseBase(this, _endpoints)[_endpoints][_classPrivateFieldLooseBase(this, _endpointIndex)[_endpointIndex]]}: ${event.code}:: ${event.reason || getWSErrorString(event.code)}`);\n        }\n\n        _classPrivateFieldLooseBase(this, _isConnected)[_isConnected] = false;\n\n        _classPrivateFieldLooseBase(this, _emit)[_emit]('disconnected');\n\n        if (_classPrivateFieldLooseBase(this, _autoConnectMs)[_autoConnectMs] > 0) {\n          setTimeout(() => {\n            this.connectWithRetry().catch(() => {// does not throw\n            });\n          }, _classPrivateFieldLooseBase(this, _autoConnectMs)[_autoConnectMs]);\n        }\n      }\n    });\n    Object.defineProperty(this, _onSocketError, {\n      writable: true,\n      value: error => {\n        l.debug(() => ['socket error', error]);\n\n        _classPrivateFieldLooseBase(this, _emit)[_emit]('error', error);\n      }\n    });\n    Object.defineProperty(this, _onSocketMessage, {\n      writable: true,\n      value: message => {\n        l.debug(() => ['received', message.data]);\n        const response = JSON.parse(message.data);\n        return isUndefined(response.method) ? _classPrivateFieldLooseBase(this, _onSocketMessageResult)[_onSocketMessageResult](response) : _classPrivateFieldLooseBase(this, _onSocketMessageSubscribe)[_onSocketMessageSubscribe](response);\n      }\n    });\n    Object.defineProperty(this, _onSocketMessageResult, {\n      writable: true,\n      value: response => {\n        const handler = _classPrivateFieldLooseBase(this, _handlers)[_handlers][response.id];\n\n        if (!handler) {\n          l.debug(() => `Unable to find handler for id=${response.id}`);\n          return;\n        }\n\n        try {\n          const {\n            method,\n            params,\n            subscription\n          } = handler;\n\n          const result = _classPrivateFieldLooseBase(this, _coder)[_coder].decodeResponse(response); // first send the result - in case of subs, we may have an update\n          // immediately if we have some queued results already\n\n\n          handler.callback(null, result);\n\n          if (subscription) {\n            const subId = `${subscription.type}::${result}`;\n            _classPrivateFieldLooseBase(this, _subscriptions)[_subscriptions][subId] = _objectSpread(_objectSpread({}, subscription), {}, {\n              method,\n              params\n            }); // if we have a result waiting for this subscription already\n\n            if (_classPrivateFieldLooseBase(this, _waitingForId)[_waitingForId][subId]) {\n              _classPrivateFieldLooseBase(this, _onSocketMessageSubscribe)[_onSocketMessageSubscribe](_classPrivateFieldLooseBase(this, _waitingForId)[_waitingForId][subId]);\n            }\n          }\n        } catch (error) {\n          handler.callback(error, undefined);\n        }\n\n        delete _classPrivateFieldLooseBase(this, _handlers)[_handlers][response.id];\n      }\n    });\n    Object.defineProperty(this, _onSocketMessageSubscribe, {\n      writable: true,\n      value: response => {\n        const method = ALIASSES[response.method] || response.method || 'invalid';\n        const subId = `${method}::${response.params.subscription}`;\n\n        const handler = _classPrivateFieldLooseBase(this, _subscriptions)[_subscriptions][subId];\n\n        if (!handler) {\n          // store the JSON, we could have out-of-order subid coming in\n          _classPrivateFieldLooseBase(this, _waitingForId)[_waitingForId][subId] = response;\n          l.debug(() => `Unable to find handler for subscription=${subId}`);\n          return;\n        } // housekeeping\n\n\n        delete _classPrivateFieldLooseBase(this, _waitingForId)[_waitingForId][subId];\n\n        try {\n          const result = _classPrivateFieldLooseBase(this, _coder)[_coder].decodeResponse(response);\n\n          handler.callback(null, result);\n        } catch (error) {\n          handler.callback(error, undefined);\n        }\n      }\n    });\n    Object.defineProperty(this, _onSocketOpen, {\n      writable: true,\n      value: () => {\n        assert(!isNull(_classPrivateFieldLooseBase(this, _websocket)[_websocket]), 'WebSocket cannot be null in onOpen');\n        l.debug(() => ['connected to', _classPrivateFieldLooseBase(this, _endpoints)[_endpoints][_classPrivateFieldLooseBase(this, _endpointIndex)[_endpointIndex]]]);\n        _classPrivateFieldLooseBase(this, _isConnected)[_isConnected] = true;\n\n        _classPrivateFieldLooseBase(this, _emit)[_emit]('connected');\n\n        _classPrivateFieldLooseBase(this, _resubscribe)[_resubscribe]();\n\n        return true;\n      }\n    });\n    Object.defineProperty(this, _resubscribe, {\n      writable: true,\n      value: () => {\n        const subscriptions = _classPrivateFieldLooseBase(this, _subscriptions)[_subscriptions];\n\n        _classPrivateFieldLooseBase(this, _subscriptions)[_subscriptions] = {};\n        Promise.all(Object.keys(subscriptions).map(async id => {\n          const {\n            callback,\n            method,\n            params,\n            type\n          } = subscriptions[id]; // only re-create subscriptions which are not in author (only area where\n          // transactions are created, i.e. submissions such as 'author_submitAndWatchExtrinsic'\n          // are not included (and will not be re-broadcast)\n\n          if (type.startsWith('author_')) {\n            return;\n          }\n\n          try {\n            await this.subscribe(type, method, params, callback);\n          } catch (error) {\n            l.error(error);\n          }\n        })).catch(l.error);\n      }\n    });\n    const endpoints = Array.isArray(endpoint) ? endpoint : [endpoint];\n    assert(endpoints.length !== 0, 'WsProvider requires at least one Endpoint');\n    endpoints.forEach(endpoint => {\n      assert(/^(wss|ws):\\/\\//.test(endpoint), `Endpoint should start with 'ws://', received '${endpoint}'`);\n    });\n    _classPrivateFieldLooseBase(this, _eventemitter)[_eventemitter] = new EventEmitter();\n    _classPrivateFieldLooseBase(this, _autoConnectMs)[_autoConnectMs] = autoConnectMs || 0;\n    _classPrivateFieldLooseBase(this, _coder)[_coder] = new RpcCoder();\n    _classPrivateFieldLooseBase(this, _endpointIndex)[_endpointIndex] = -1;\n    _classPrivateFieldLooseBase(this, _endpoints)[_endpoints] = endpoints;\n    _classPrivateFieldLooseBase(this, _headers)[_headers] = headers;\n    _classPrivateFieldLooseBase(this, _websocket)[_websocket] = null;\n\n    if (autoConnectMs > 0) {\n      this.connectWithRetry().catch(() => {// does not throw\n      });\n    }\n\n    _classPrivateFieldLooseBase(this, _isReadyPromise)[_isReadyPromise] = new Promise(resolve => {\n      _classPrivateFieldLooseBase(this, _eventemitter)[_eventemitter].once('connected', () => {\n        resolve(this);\n      });\n    });\n  }\n  /**\n   * @summary `true` when this provider supports subscriptions\n   */\n\n\n  get hasSubscriptions() {\n    return true;\n  }\n  /**\n   * @summary Whether the node is connected or not.\n   * @return {boolean} true if connected\n   */\n\n\n  get isConnected() {\n    return _classPrivateFieldLooseBase(this, _isConnected)[_isConnected];\n  }\n  /**\n   * @description Promise that resolves the first time we are connected and loaded\n   */\n\n\n  get isReady() {\n    return _classPrivateFieldLooseBase(this, _isReadyPromise)[_isReadyPromise];\n  }\n  /**\n   * @description Returns a clone of the object\n   */\n\n\n  clone() {\n    return new WsProvider(_classPrivateFieldLooseBase(this, _endpoints)[_endpoints]);\n  }\n  /**\n   * @summary Manually connect\n   * @description The [[WsProvider]] connects automatically by default, however if you decided otherwise, you may\n   * connect manually using this method.\n   */\n  // eslint-disable-next-line @typescript-eslint/require-await\n\n\n  async connect() {\n    try {\n      _classPrivateFieldLooseBase(this, _endpointIndex)[_endpointIndex] = (_classPrivateFieldLooseBase(this, _endpointIndex)[_endpointIndex] + 1) % _classPrivateFieldLooseBase(this, _endpoints)[_endpoints].length;\n      _classPrivateFieldLooseBase(this, _websocket)[_websocket] = typeof xglobal.WebSocket !== 'undefined' && isChildClass(xglobal.WebSocket, WebSocket) ? new WebSocket(_classPrivateFieldLooseBase(this, _endpoints)[_endpoints][_classPrivateFieldLooseBase(this, _endpointIndex)[_endpointIndex]]) // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore - WS may be an instance of w3cwebsocket, which supports headers\n      : new WebSocket(_classPrivateFieldLooseBase(this, _endpoints)[_endpoints][_classPrivateFieldLooseBase(this, _endpointIndex)[_endpointIndex]], undefined, undefined, _classPrivateFieldLooseBase(this, _headers)[_headers], undefined, {\n        // default: true\n        fragmentOutgoingMessages: true,\n        // default: 16K\n        fragmentationThreshold: 256 * 1024\n      });\n      _classPrivateFieldLooseBase(this, _websocket)[_websocket].onclose = _classPrivateFieldLooseBase(this, _onSocketClose)[_onSocketClose];\n      _classPrivateFieldLooseBase(this, _websocket)[_websocket].onerror = _classPrivateFieldLooseBase(this, _onSocketError)[_onSocketError];\n      _classPrivateFieldLooseBase(this, _websocket)[_websocket].onmessage = _classPrivateFieldLooseBase(this, _onSocketMessage)[_onSocketMessage];\n      _classPrivateFieldLooseBase(this, _websocket)[_websocket].onopen = _classPrivateFieldLooseBase(this, _onSocketOpen)[_onSocketOpen];\n    } catch (error) {\n      l.error(error);\n\n      _classPrivateFieldLooseBase(this, _emit)[_emit]('error', error);\n\n      throw error;\n    }\n  }\n  /**\n   * @description Connect, never throwing an error, but rather forcing a retry\n   */\n\n\n  async connectWithRetry() {\n    if (_classPrivateFieldLooseBase(this, _autoConnectMs)[_autoConnectMs] > 0) {\n      try {\n        await this.connect();\n      } catch (error) {\n        setTimeout(() => {\n          this.connectWithRetry().catch(() => {// does not throw\n          });\n        }, _classPrivateFieldLooseBase(this, _autoConnectMs)[_autoConnectMs]);\n      }\n    }\n  }\n  /**\n   * @description Manually disconnect from the connection, clearing autoconnect logic\n   */\n  // eslint-disable-next-line @typescript-eslint/require-await\n\n\n  async disconnect() {\n    try {\n      assert(!isNull(_classPrivateFieldLooseBase(this, _websocket)[_websocket]), 'Cannot disconnect on a non-connected websocket'); // switch off autoConnect, we are in manual mode now\n\n      _classPrivateFieldLooseBase(this, _autoConnectMs)[_autoConnectMs] = 0; // 1000 - Normal closure; the connection successfully completed\n\n      _classPrivateFieldLooseBase(this, _websocket)[_websocket].close(1000);\n\n      _classPrivateFieldLooseBase(this, _websocket)[_websocket] = null;\n    } catch (error) {\n      l.error(error);\n\n      _classPrivateFieldLooseBase(this, _emit)[_emit]('error', error);\n\n      throw error;\n    }\n  }\n  /**\n   * @summary Listens on events after having subscribed using the [[subscribe]] function.\n   * @param  {ProviderInterfaceEmitted} type Event\n   * @param  {ProviderInterfaceEmitCb}  sub  Callback\n   * @return unsubscribe function\n   */\n\n\n  on(type, sub) {\n    _classPrivateFieldLooseBase(this, _eventemitter)[_eventemitter].on(type, sub);\n\n    return () => {\n      _classPrivateFieldLooseBase(this, _eventemitter)[_eventemitter].removeListener(type, sub);\n    };\n  }\n  /**\n   * @summary Send JSON data using WebSockets to configured HTTP Endpoint or queue.\n   * @param method The RPC methods to execute\n   * @param params Encoded parameters as applicable for the method\n   * @param subscription Subscription details (internally used)\n   */\n\n\n  send(method, params, subscription) {\n    return new Promise((resolve, reject) => {\n      try {\n        assert(this.isConnected && !isNull(_classPrivateFieldLooseBase(this, _websocket)[_websocket]), 'WebSocket is not connected');\n\n        const json = _classPrivateFieldLooseBase(this, _coder)[_coder].encodeJson(method, params);\n\n        const id = _classPrivateFieldLooseBase(this, _coder)[_coder].getId();\n\n        const callback = (error, result) => {\n          error ? reject(error) : resolve(result);\n        };\n\n        l.debug(() => ['calling', method, json]);\n        _classPrivateFieldLooseBase(this, _handlers)[_handlers][id] = {\n          callback,\n          method,\n          params,\n          subscription\n        };\n\n        _classPrivateFieldLooseBase(this, _websocket)[_websocket].send(json);\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n  /**\n   * @name subscribe\n   * @summary Allows subscribing to a specific event.\n   * @param  {string}                     type     Subscription type\n   * @param  {string}                     method   Subscription method\n   * @param  {any[]}                 params   Parameters\n   * @param  {ProviderInterfaceCallback} callback Callback\n   * @return {Promise<number>}                     Promise resolving to the dd of the subscription you can use with [[unsubscribe]].\n   *\n   * @example\n   * <BR>\n   *\n   * ```javascript\n   * const provider = new WsProvider('ws://127.0.0.1:9944');\n   * const rpc = new Rpc(provider);\n   *\n   * rpc.state.subscribeStorage([[storage.system.account, <Address>]], (_, values) => {\n   *   console.log(values)\n   * }).then((subscriptionId) => {\n   *   console.log('balance changes subscription id: ', subscriptionId)\n   * })\n   * ```\n   */\n\n\n  async subscribe(type, method, params, callback) {\n    const id = await this.send(method, params, {\n      callback,\n      type\n    });\n    return id;\n  }\n  /**\n   * @summary Allows unsubscribing to subscriptions made with [[subscribe]].\n   */\n\n\n  async unsubscribe(type, method, id) {\n    const subscription = `${type}::${id}`; // FIXME This now could happen with re-subscriptions. The issue is that with a re-sub\n    // the assigned id now does not match what the API user originally received. It has\n    // a slight complication in solving - since we cannot rely on the send id, but rather\n    // need to find the actual subscription id to map it\n\n    if (isUndefined(_classPrivateFieldLooseBase(this, _subscriptions)[_subscriptions][subscription])) {\n      l.debug(() => `Unable to find active subscription=${subscription}`);\n      return false;\n    }\n\n    delete _classPrivateFieldLooseBase(this, _subscriptions)[_subscriptions][subscription];\n    const result = await this.send(method, [id]);\n    return result;\n  }\n\n}","map":{"version":3,"sources":["/Users/bmacer/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/rpc-provider/ws/index.mjs"],"names":["_defineProperty","_classPrivateFieldLooseBase","_classPrivateFieldLooseKey","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","EventEmitter","assert","isChildClass","isNull","isUndefined","logger","xglobal","WebSocket","RpcCoder","defaults","getWSErrorString","ALIASSES","chain_finalisedHead","chain_subscribeFinalisedHeads","chain_unsubscribeFinalisedHeads","RETRY_DELAY","l","_coder","_endpoints","_headers","_eventemitter","_handlers","_isReadyPromise","_waitingForId","_autoConnectMs","_endpointIndex","_isConnected","_subscriptions","_websocket","_emit","_onSocketClose","_onSocketError","_onSocketMessage","_onSocketMessageResult","_onSocketMessageSubscribe","_onSocketOpen","_resubscribe","WsProvider","constructor","endpoint","WS_URL","autoConnectMs","headers","writable","value","type","args","emit","event","error","code","reason","setTimeout","connectWithRetry","catch","debug","message","data","response","JSON","parse","method","handler","id","params","subscription","result","decodeResponse","callback","subId","undefined","subscriptions","Promise","all","map","startsWith","subscribe","endpoints","Array","isArray","test","resolve","once","hasSubscriptions","isConnected","isReady","clone","connect","fragmentOutgoingMessages","fragmentationThreshold","onclose","onerror","onmessage","onopen","disconnect","close","on","sub","removeListener","send","reject","json","encodeJson","getId","unsubscribe"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/rpc-provider authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable camelcase */\nimport EventEmitter from 'eventemitter3';\nimport { assert, isChildClass, isNull, isUndefined, logger } from '@polkadot/util';\nimport { xglobal } from '@polkadot/x-global';\nimport { WebSocket } from '@polkadot/x-ws';\nimport { RpcCoder } from \"../coder/index.mjs\";\nimport defaults from \"../defaults.mjs\";\nimport { getWSErrorString } from \"./errors.mjs\";\nconst ALIASSES = {\n  chain_finalisedHead: 'chain_finalizedHead',\n  chain_subscribeFinalisedHeads: 'chain_subscribeFinalizedHeads',\n  chain_unsubscribeFinalisedHeads: 'chain_unsubscribeFinalizedHeads'\n};\nconst RETRY_DELAY = 1000;\nconst l = logger('api-ws');\n/**\n * # @polkadot/rpc-provider/ws\n *\n * @name WsProvider\n *\n * @description The WebSocket Provider allows sending requests using WebSocket to a WebSocket RPC server TCP port. Unlike the [[HttpProvider]], it does support subscriptions and allows listening to events such as new blocks or balance changes.\n *\n * @example\n * <BR>\n *\n * ```javascript\n * import Api from '@polkadot/api/promise';\n * import { WsProvider } from '@polkadot/rpc-provider/ws';\n *\n * const provider = new WsProvider('ws://127.0.0.1:9944');\n * const api = new Api(provider);\n * ```\n *\n * @see [[HttpProvider]]\n */\n\nvar _coder = _classPrivateFieldLooseKey(\"coder\");\n\nvar _endpoints = _classPrivateFieldLooseKey(\"endpoints\");\n\nvar _headers = _classPrivateFieldLooseKey(\"headers\");\n\nvar _eventemitter = _classPrivateFieldLooseKey(\"eventemitter\");\n\nvar _handlers = _classPrivateFieldLooseKey(\"handlers\");\n\nvar _isReadyPromise = _classPrivateFieldLooseKey(\"isReadyPromise\");\n\nvar _waitingForId = _classPrivateFieldLooseKey(\"waitingForId\");\n\nvar _autoConnectMs = _classPrivateFieldLooseKey(\"autoConnectMs\");\n\nvar _endpointIndex = _classPrivateFieldLooseKey(\"endpointIndex\");\n\nvar _isConnected = _classPrivateFieldLooseKey(\"isConnected\");\n\nvar _subscriptions = _classPrivateFieldLooseKey(\"subscriptions\");\n\nvar _websocket = _classPrivateFieldLooseKey(\"websocket\");\n\nvar _emit = _classPrivateFieldLooseKey(\"emit\");\n\nvar _onSocketClose = _classPrivateFieldLooseKey(\"onSocketClose\");\n\nvar _onSocketError = _classPrivateFieldLooseKey(\"onSocketError\");\n\nvar _onSocketMessage = _classPrivateFieldLooseKey(\"onSocketMessage\");\n\nvar _onSocketMessageResult = _classPrivateFieldLooseKey(\"onSocketMessageResult\");\n\nvar _onSocketMessageSubscribe = _classPrivateFieldLooseKey(\"onSocketMessageSubscribe\");\n\nvar _onSocketOpen = _classPrivateFieldLooseKey(\"onSocketOpen\");\n\nvar _resubscribe = _classPrivateFieldLooseKey(\"resubscribe\");\n\nexport class WsProvider {\n  /**\n   * @param {string | string[]}  endpoint    The endpoint url. Usually `ws://ip:9944` or `wss://ip:9944`, may provide an array of endpoint strings.\n   * @param {boolean} autoConnect Whether to connect automatically or not.\n   */\n  constructor(endpoint = defaults.WS_URL, autoConnectMs = RETRY_DELAY, headers = {}) {\n    Object.defineProperty(this, _coder, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _endpoints, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _headers, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _eventemitter, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _handlers, {\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, _isReadyPromise, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _waitingForId, {\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, _autoConnectMs, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _endpointIndex, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _isConnected, {\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, _subscriptions, {\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, _websocket, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _emit, {\n      writable: true,\n      value: (type, ...args) => {\n        _classPrivateFieldLooseBase(this, _eventemitter)[_eventemitter].emit(type, ...args);\n      }\n    });\n    Object.defineProperty(this, _onSocketClose, {\n      writable: true,\n      value: event => {\n        if (_classPrivateFieldLooseBase(this, _autoConnectMs)[_autoConnectMs] > 0) {\n          l.error(`disconnected from ${_classPrivateFieldLooseBase(this, _endpoints)[_endpoints][_classPrivateFieldLooseBase(this, _endpointIndex)[_endpointIndex]]}: ${event.code}:: ${event.reason || getWSErrorString(event.code)}`);\n        }\n\n        _classPrivateFieldLooseBase(this, _isConnected)[_isConnected] = false;\n\n        _classPrivateFieldLooseBase(this, _emit)[_emit]('disconnected');\n\n        if (_classPrivateFieldLooseBase(this, _autoConnectMs)[_autoConnectMs] > 0) {\n          setTimeout(() => {\n            this.connectWithRetry().catch(() => {// does not throw\n            });\n          }, _classPrivateFieldLooseBase(this, _autoConnectMs)[_autoConnectMs]);\n        }\n      }\n    });\n    Object.defineProperty(this, _onSocketError, {\n      writable: true,\n      value: error => {\n        l.debug(() => ['socket error', error]);\n\n        _classPrivateFieldLooseBase(this, _emit)[_emit]('error', error);\n      }\n    });\n    Object.defineProperty(this, _onSocketMessage, {\n      writable: true,\n      value: message => {\n        l.debug(() => ['received', message.data]);\n        const response = JSON.parse(message.data);\n        return isUndefined(response.method) ? _classPrivateFieldLooseBase(this, _onSocketMessageResult)[_onSocketMessageResult](response) : _classPrivateFieldLooseBase(this, _onSocketMessageSubscribe)[_onSocketMessageSubscribe](response);\n      }\n    });\n    Object.defineProperty(this, _onSocketMessageResult, {\n      writable: true,\n      value: response => {\n        const handler = _classPrivateFieldLooseBase(this, _handlers)[_handlers][response.id];\n\n        if (!handler) {\n          l.debug(() => `Unable to find handler for id=${response.id}`);\n          return;\n        }\n\n        try {\n          const {\n            method,\n            params,\n            subscription\n          } = handler;\n\n          const result = _classPrivateFieldLooseBase(this, _coder)[_coder].decodeResponse(response); // first send the result - in case of subs, we may have an update\n          // immediately if we have some queued results already\n\n\n          handler.callback(null, result);\n\n          if (subscription) {\n            const subId = `${subscription.type}::${result}`;\n            _classPrivateFieldLooseBase(this, _subscriptions)[_subscriptions][subId] = _objectSpread(_objectSpread({}, subscription), {}, {\n              method,\n              params\n            }); // if we have a result waiting for this subscription already\n\n            if (_classPrivateFieldLooseBase(this, _waitingForId)[_waitingForId][subId]) {\n              _classPrivateFieldLooseBase(this, _onSocketMessageSubscribe)[_onSocketMessageSubscribe](_classPrivateFieldLooseBase(this, _waitingForId)[_waitingForId][subId]);\n            }\n          }\n        } catch (error) {\n          handler.callback(error, undefined);\n        }\n\n        delete _classPrivateFieldLooseBase(this, _handlers)[_handlers][response.id];\n      }\n    });\n    Object.defineProperty(this, _onSocketMessageSubscribe, {\n      writable: true,\n      value: response => {\n        const method = ALIASSES[response.method] || response.method || 'invalid';\n        const subId = `${method}::${response.params.subscription}`;\n\n        const handler = _classPrivateFieldLooseBase(this, _subscriptions)[_subscriptions][subId];\n\n        if (!handler) {\n          // store the JSON, we could have out-of-order subid coming in\n          _classPrivateFieldLooseBase(this, _waitingForId)[_waitingForId][subId] = response;\n          l.debug(() => `Unable to find handler for subscription=${subId}`);\n          return;\n        } // housekeeping\n\n\n        delete _classPrivateFieldLooseBase(this, _waitingForId)[_waitingForId][subId];\n\n        try {\n          const result = _classPrivateFieldLooseBase(this, _coder)[_coder].decodeResponse(response);\n\n          handler.callback(null, result);\n        } catch (error) {\n          handler.callback(error, undefined);\n        }\n      }\n    });\n    Object.defineProperty(this, _onSocketOpen, {\n      writable: true,\n      value: () => {\n        assert(!isNull(_classPrivateFieldLooseBase(this, _websocket)[_websocket]), 'WebSocket cannot be null in onOpen');\n        l.debug(() => ['connected to', _classPrivateFieldLooseBase(this, _endpoints)[_endpoints][_classPrivateFieldLooseBase(this, _endpointIndex)[_endpointIndex]]]);\n        _classPrivateFieldLooseBase(this, _isConnected)[_isConnected] = true;\n\n        _classPrivateFieldLooseBase(this, _emit)[_emit]('connected');\n\n        _classPrivateFieldLooseBase(this, _resubscribe)[_resubscribe]();\n\n        return true;\n      }\n    });\n    Object.defineProperty(this, _resubscribe, {\n      writable: true,\n      value: () => {\n        const subscriptions = _classPrivateFieldLooseBase(this, _subscriptions)[_subscriptions];\n\n        _classPrivateFieldLooseBase(this, _subscriptions)[_subscriptions] = {};\n        Promise.all(Object.keys(subscriptions).map(async id => {\n          const {\n            callback,\n            method,\n            params,\n            type\n          } = subscriptions[id]; // only re-create subscriptions which are not in author (only area where\n          // transactions are created, i.e. submissions such as 'author_submitAndWatchExtrinsic'\n          // are not included (and will not be re-broadcast)\n\n          if (type.startsWith('author_')) {\n            return;\n          }\n\n          try {\n            await this.subscribe(type, method, params, callback);\n          } catch (error) {\n            l.error(error);\n          }\n        })).catch(l.error);\n      }\n    });\n    const endpoints = Array.isArray(endpoint) ? endpoint : [endpoint];\n    assert(endpoints.length !== 0, 'WsProvider requires at least one Endpoint');\n    endpoints.forEach(endpoint => {\n      assert(/^(wss|ws):\\/\\//.test(endpoint), `Endpoint should start with 'ws://', received '${endpoint}'`);\n    });\n    _classPrivateFieldLooseBase(this, _eventemitter)[_eventemitter] = new EventEmitter();\n    _classPrivateFieldLooseBase(this, _autoConnectMs)[_autoConnectMs] = autoConnectMs || 0;\n    _classPrivateFieldLooseBase(this, _coder)[_coder] = new RpcCoder();\n    _classPrivateFieldLooseBase(this, _endpointIndex)[_endpointIndex] = -1;\n    _classPrivateFieldLooseBase(this, _endpoints)[_endpoints] = endpoints;\n    _classPrivateFieldLooseBase(this, _headers)[_headers] = headers;\n    _classPrivateFieldLooseBase(this, _websocket)[_websocket] = null;\n\n    if (autoConnectMs > 0) {\n      this.connectWithRetry().catch(() => {// does not throw\n      });\n    }\n\n    _classPrivateFieldLooseBase(this, _isReadyPromise)[_isReadyPromise] = new Promise(resolve => {\n      _classPrivateFieldLooseBase(this, _eventemitter)[_eventemitter].once('connected', () => {\n        resolve(this);\n      });\n    });\n  }\n  /**\n   * @summary `true` when this provider supports subscriptions\n   */\n\n\n  get hasSubscriptions() {\n    return true;\n  }\n  /**\n   * @summary Whether the node is connected or not.\n   * @return {boolean} true if connected\n   */\n\n\n  get isConnected() {\n    return _classPrivateFieldLooseBase(this, _isConnected)[_isConnected];\n  }\n  /**\n   * @description Promise that resolves the first time we are connected and loaded\n   */\n\n\n  get isReady() {\n    return _classPrivateFieldLooseBase(this, _isReadyPromise)[_isReadyPromise];\n  }\n  /**\n   * @description Returns a clone of the object\n   */\n\n\n  clone() {\n    return new WsProvider(_classPrivateFieldLooseBase(this, _endpoints)[_endpoints]);\n  }\n  /**\n   * @summary Manually connect\n   * @description The [[WsProvider]] connects automatically by default, however if you decided otherwise, you may\n   * connect manually using this method.\n   */\n  // eslint-disable-next-line @typescript-eslint/require-await\n\n\n  async connect() {\n    try {\n      _classPrivateFieldLooseBase(this, _endpointIndex)[_endpointIndex] = (_classPrivateFieldLooseBase(this, _endpointIndex)[_endpointIndex] + 1) % _classPrivateFieldLooseBase(this, _endpoints)[_endpoints].length;\n      _classPrivateFieldLooseBase(this, _websocket)[_websocket] = typeof xglobal.WebSocket !== 'undefined' && isChildClass(xglobal.WebSocket, WebSocket) ? new WebSocket(_classPrivateFieldLooseBase(this, _endpoints)[_endpoints][_classPrivateFieldLooseBase(this, _endpointIndex)[_endpointIndex]]) // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore - WS may be an instance of w3cwebsocket, which supports headers\n      : new WebSocket(_classPrivateFieldLooseBase(this, _endpoints)[_endpoints][_classPrivateFieldLooseBase(this, _endpointIndex)[_endpointIndex]], undefined, undefined, _classPrivateFieldLooseBase(this, _headers)[_headers], undefined, {\n        // default: true\n        fragmentOutgoingMessages: true,\n        // default: 16K\n        fragmentationThreshold: 256 * 1024\n      });\n      _classPrivateFieldLooseBase(this, _websocket)[_websocket].onclose = _classPrivateFieldLooseBase(this, _onSocketClose)[_onSocketClose];\n      _classPrivateFieldLooseBase(this, _websocket)[_websocket].onerror = _classPrivateFieldLooseBase(this, _onSocketError)[_onSocketError];\n      _classPrivateFieldLooseBase(this, _websocket)[_websocket].onmessage = _classPrivateFieldLooseBase(this, _onSocketMessage)[_onSocketMessage];\n      _classPrivateFieldLooseBase(this, _websocket)[_websocket].onopen = _classPrivateFieldLooseBase(this, _onSocketOpen)[_onSocketOpen];\n    } catch (error) {\n      l.error(error);\n\n      _classPrivateFieldLooseBase(this, _emit)[_emit]('error', error);\n\n      throw error;\n    }\n  }\n  /**\n   * @description Connect, never throwing an error, but rather forcing a retry\n   */\n\n\n  async connectWithRetry() {\n    if (_classPrivateFieldLooseBase(this, _autoConnectMs)[_autoConnectMs] > 0) {\n      try {\n        await this.connect();\n      } catch (error) {\n        setTimeout(() => {\n          this.connectWithRetry().catch(() => {// does not throw\n          });\n        }, _classPrivateFieldLooseBase(this, _autoConnectMs)[_autoConnectMs]);\n      }\n    }\n  }\n  /**\n   * @description Manually disconnect from the connection, clearing autoconnect logic\n   */\n  // eslint-disable-next-line @typescript-eslint/require-await\n\n\n  async disconnect() {\n    try {\n      assert(!isNull(_classPrivateFieldLooseBase(this, _websocket)[_websocket]), 'Cannot disconnect on a non-connected websocket'); // switch off autoConnect, we are in manual mode now\n\n      _classPrivateFieldLooseBase(this, _autoConnectMs)[_autoConnectMs] = 0; // 1000 - Normal closure; the connection successfully completed\n\n      _classPrivateFieldLooseBase(this, _websocket)[_websocket].close(1000);\n\n      _classPrivateFieldLooseBase(this, _websocket)[_websocket] = null;\n    } catch (error) {\n      l.error(error);\n\n      _classPrivateFieldLooseBase(this, _emit)[_emit]('error', error);\n\n      throw error;\n    }\n  }\n  /**\n   * @summary Listens on events after having subscribed using the [[subscribe]] function.\n   * @param  {ProviderInterfaceEmitted} type Event\n   * @param  {ProviderInterfaceEmitCb}  sub  Callback\n   * @return unsubscribe function\n   */\n\n\n  on(type, sub) {\n    _classPrivateFieldLooseBase(this, _eventemitter)[_eventemitter].on(type, sub);\n\n    return () => {\n      _classPrivateFieldLooseBase(this, _eventemitter)[_eventemitter].removeListener(type, sub);\n    };\n  }\n  /**\n   * @summary Send JSON data using WebSockets to configured HTTP Endpoint or queue.\n   * @param method The RPC methods to execute\n   * @param params Encoded parameters as applicable for the method\n   * @param subscription Subscription details (internally used)\n   */\n\n\n  send(method, params, subscription) {\n    return new Promise((resolve, reject) => {\n      try {\n        assert(this.isConnected && !isNull(_classPrivateFieldLooseBase(this, _websocket)[_websocket]), 'WebSocket is not connected');\n\n        const json = _classPrivateFieldLooseBase(this, _coder)[_coder].encodeJson(method, params);\n\n        const id = _classPrivateFieldLooseBase(this, _coder)[_coder].getId();\n\n        const callback = (error, result) => {\n          error ? reject(error) : resolve(result);\n        };\n\n        l.debug(() => ['calling', method, json]);\n        _classPrivateFieldLooseBase(this, _handlers)[_handlers][id] = {\n          callback,\n          method,\n          params,\n          subscription\n        };\n\n        _classPrivateFieldLooseBase(this, _websocket)[_websocket].send(json);\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n  /**\n   * @name subscribe\n   * @summary Allows subscribing to a specific event.\n   * @param  {string}                     type     Subscription type\n   * @param  {string}                     method   Subscription method\n   * @param  {any[]}                 params   Parameters\n   * @param  {ProviderInterfaceCallback} callback Callback\n   * @return {Promise<number>}                     Promise resolving to the dd of the subscription you can use with [[unsubscribe]].\n   *\n   * @example\n   * <BR>\n   *\n   * ```javascript\n   * const provider = new WsProvider('ws://127.0.0.1:9944');\n   * const rpc = new Rpc(provider);\n   *\n   * rpc.state.subscribeStorage([[storage.system.account, <Address>]], (_, values) => {\n   *   console.log(values)\n   * }).then((subscriptionId) => {\n   *   console.log('balance changes subscription id: ', subscriptionId)\n   * })\n   * ```\n   */\n\n\n  async subscribe(type, method, params, callback) {\n    const id = await this.send(method, params, {\n      callback,\n      type\n    });\n    return id;\n  }\n  /**\n   * @summary Allows unsubscribing to subscriptions made with [[subscribe]].\n   */\n\n\n  async unsubscribe(type, method, id) {\n    const subscription = `${type}::${id}`; // FIXME This now could happen with re-subscriptions. The issue is that with a re-sub\n    // the assigned id now does not match what the API user originally received. It has\n    // a slight complication in solving - since we cannot rely on the send id, but rather\n    // need to find the actual subscription id to map it\n\n    if (isUndefined(_classPrivateFieldLooseBase(this, _subscriptions)[_subscriptions][subscription])) {\n      l.debug(() => `Unable to find active subscription=${subscription}`);\n      return false;\n    }\n\n    delete _classPrivateFieldLooseBase(this, _subscriptions)[_subscriptions][subscription];\n    const result = await this.send(method, [id]);\n    return result;\n  }\n\n}"]},"metadata":{},"sourceType":"module"}