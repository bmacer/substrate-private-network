{"ast":null,"code":"// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, compactFromU8a, compactToU8a, isString, u8aConcat, u8aToU8a } from '@polkadot/util';\nimport { Raw } from \"../codec/Raw.mjs\";\n/** @internal */\n\nfunction decodeBitVecU8a(value) {\n  if (!value || !value.length) {\n    return new Uint8Array();\n  } // handle all other Uint8Array inputs, these do have a length prefix which is the number of bits encoded\n\n\n  const [offset, length] = compactFromU8a(value);\n  const total = offset + Math.ceil(length.toNumber() / 8);\n  assert(total <= value.length, `BitVec: required length less than remainder, expected at least ${total}, found ${value.length}`);\n  return value.subarray(offset, total);\n}\n/** @internal */\n\n\nfunction decodeBitVec(value) {\n  if (Array.isArray(value) || isString(value)) {\n    return u8aToU8a(value);\n  }\n\n  return decodeBitVecU8a(value);\n}\n/**\n * @name BitVec\n * @description\n * A BitVec that represents an array of bits. The bits are however stored encoded. The difference between this\n * and a normal Bytes would be that the length prefix indicates the number of bits encoded, not the bytes\n */\n\n\nexport class BitVec extends Raw {\n  constructor(registry, value) {\n    super(registry, decodeBitVec(value));\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return this.length + compactToU8a(this.bitLength()).length;\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return 'BitVec';\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    const bitVec = super.toU8a();\n    return isBare ? bitVec : u8aConcat(compactToU8a(this.bitLength()), bitVec);\n  }\n\n}","map":{"version":3,"sources":["/Users/bmacer/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/types/primitive/BitVec.mjs"],"names":["assert","compactFromU8a","compactToU8a","isString","u8aConcat","u8aToU8a","Raw","decodeBitVecU8a","value","length","Uint8Array","offset","total","Math","ceil","toNumber","subarray","decodeBitVec","Array","isArray","BitVec","constructor","registry","encodedLength","bitLength","toRawType","toU8a","isBare","bitVec"],"mappings":"AAAA;AACA;AACA,SAASA,MAAT,EAAiBC,cAAjB,EAAiCC,YAAjC,EAA+CC,QAA/C,EAAyDC,SAAzD,EAAoEC,QAApE,QAAoF,gBAApF;AACA,SAASC,GAAT,QAAoB,kBAApB;AACA;;AAEA,SAASC,eAAT,CAAyBC,KAAzB,EAAgC;AAC9B,MAAI,CAACA,KAAD,IAAU,CAACA,KAAK,CAACC,MAArB,EAA6B;AAC3B,WAAO,IAAIC,UAAJ,EAAP;AACD,GAH6B,CAG5B;;;AAGF,QAAM,CAACC,MAAD,EAASF,MAAT,IAAmBR,cAAc,CAACO,KAAD,CAAvC;AACA,QAAMI,KAAK,GAAGD,MAAM,GAAGE,IAAI,CAACC,IAAL,CAAUL,MAAM,CAACM,QAAP,KAAoB,CAA9B,CAAvB;AACAf,EAAAA,MAAM,CAACY,KAAK,IAAIJ,KAAK,CAACC,MAAhB,EAAyB,kEAAiEG,KAAM,WAAUJ,KAAK,CAACC,MAAO,EAAvH,CAAN;AACA,SAAOD,KAAK,CAACQ,QAAN,CAAeL,MAAf,EAAuBC,KAAvB,CAAP;AACD;AACD;;;AAGA,SAASK,YAAT,CAAsBT,KAAtB,EAA6B;AAC3B,MAAIU,KAAK,CAACC,OAAN,CAAcX,KAAd,KAAwBL,QAAQ,CAACK,KAAD,CAApC,EAA6C;AAC3C,WAAOH,QAAQ,CAACG,KAAD,CAAf;AACD;;AAED,SAAOD,eAAe,CAACC,KAAD,CAAtB;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;;AAGA,OAAO,MAAMY,MAAN,SAAqBd,GAArB,CAAyB;AAC9Be,EAAAA,WAAW,CAACC,QAAD,EAAWd,KAAX,EAAkB;AAC3B,UAAMc,QAAN,EAAgBL,YAAY,CAACT,KAAD,CAA5B;AACD;AACD;AACF;AACA;;;AAGmB,MAAbe,aAAa,GAAG;AAClB,WAAO,KAAKd,MAAL,GAAcP,YAAY,CAAC,KAAKsB,SAAL,EAAD,CAAZ,CAA+Bf,MAApD;AACD;AACD;AACF;AACA;;;AAGEgB,EAAAA,SAAS,GAAG;AACV,WAAO,QAAP;AACD;AACD;AACF;AACA;AACA;;;AAGEC,EAAAA,KAAK,CAACC,MAAD,EAAS;AACZ,UAAMC,MAAM,GAAG,MAAMF,KAAN,EAAf;AACA,WAAOC,MAAM,GAAGC,MAAH,GAAYxB,SAAS,CAACF,YAAY,CAAC,KAAKsB,SAAL,EAAD,CAAb,EAAiCI,MAAjC,CAAlC;AACD;;AA7B6B","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, compactFromU8a, compactToU8a, isString, u8aConcat, u8aToU8a } from '@polkadot/util';\nimport { Raw } from \"../codec/Raw.mjs\";\n/** @internal */\n\nfunction decodeBitVecU8a(value) {\n  if (!value || !value.length) {\n    return new Uint8Array();\n  } // handle all other Uint8Array inputs, these do have a length prefix which is the number of bits encoded\n\n\n  const [offset, length] = compactFromU8a(value);\n  const total = offset + Math.ceil(length.toNumber() / 8);\n  assert(total <= value.length, `BitVec: required length less than remainder, expected at least ${total}, found ${value.length}`);\n  return value.subarray(offset, total);\n}\n/** @internal */\n\n\nfunction decodeBitVec(value) {\n  if (Array.isArray(value) || isString(value)) {\n    return u8aToU8a(value);\n  }\n\n  return decodeBitVecU8a(value);\n}\n/**\n * @name BitVec\n * @description\n * A BitVec that represents an array of bits. The bits are however stored encoded. The difference between this\n * and a normal Bytes would be that the length prefix indicates the number of bits encoded, not the bytes\n */\n\n\nexport class BitVec extends Raw {\n  constructor(registry, value) {\n    super(registry, decodeBitVec(value));\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return this.length + compactToU8a(this.bitLength()).length;\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return 'BitVec';\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    const bitVec = super.toU8a();\n    return isBare ? bitVec : u8aConcat(compactToU8a(this.bitLength()), bitVec);\n  }\n\n}"]},"metadata":{},"sourceType":"module"}