{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/keyring authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { assert, u8aConcat, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { blake2AsU8a, ethereumEncode, keccakAsU8a, keyExtractPath, keyFromPath, naclKeypairFromSeed as naclFromSeed, naclSign, schnorrkelKeypairFromSeed as schnorrkelFromSeed, schnorrkelSign, schnorrkelVrfSign, schnorrkelVrfVerify, secp256k1Compress, secp256k1Expand, secp256k1KeypairFromSeed as secp256k1FromSeed, secp256k1Sign, signatureVerify } from '@polkadot/util-crypto';\nimport { decodePair } from \"./decode.mjs\";\nimport { encodePair } from \"./encode.mjs\";\nimport { pairToJson } from \"./toJson.mjs\";\nconst SIG_TYPE_NONE = new Uint8Array();\nconst TYPE_FROM_SEED = {\n  ecdsa: secp256k1FromSeed,\n  ed25519: naclFromSeed,\n  ethereum: secp256k1FromSeed,\n  sr25519: schnorrkelFromSeed\n};\nconst TYPE_PREFIX = {\n  ecdsa: new Uint8Array([2]),\n  ed25519: new Uint8Array([0]),\n  ethereum: new Uint8Array([2]),\n  sr25519: new Uint8Array([1])\n};\nconst TYPE_SIGNATURE = {\n  ecdsa: (m, p) => secp256k1Sign(m, p, 'blake2'),\n  ed25519: naclSign,\n  ethereum: (m, p) => secp256k1Sign(m, p, 'keccak'),\n  sr25519: schnorrkelSign\n};\nconst TYPE_ADDRESS = {\n  ecdsa: p => p.length > 32 ? blake2AsU8a(p) : p,\n  ed25519: p => p,\n  ethereum: p => keccakAsU8a(secp256k1Expand(p)),\n  sr25519: p => p\n}; // Not 100% correct, since it can be a Uint8Array, but an invalid one - just say \"undefined\" is anything non-valid\n\nfunction isLocked(secretKey) {\n  return !secretKey || secretKey.length === 0 || secretKey.every(b => b === 0);\n}\n\nfunction vrfHash(proof, context, extra) {\n  return blake2AsU8a(u8aConcat(context || '', extra || '', proof));\n}\n/**\n * @name createPair\n * @summary Creates a keyring pair object\n * @description Creates a keyring pair object with provided account public key, metadata, and encoded arguments.\n * The keyring pair stores the account state including the encoded address and associated metadata.\n *\n * It has properties whose values are functions that may be called to perform account actions:\n *\n * - `address` function retrieves the address associated with the account.\n * - `decodedPkcs8` function is called with the account passphrase and account encoded public key.\n * It decodes the encoded public key using the passphrase provided to obtain the decoded account public key\n * and associated secret key that are then available in memory, and changes the account address stored in the\n * state of the pair to correspond to the address of the decoded public key.\n * - `encodePkcs8` function when provided with the correct passphrase associated with the account pair\n * and when the secret key is in memory (when the account pair is not locked) it returns an encoded\n * public key of the account.\n * - `meta` is the metadata that is stored in the state of the pair, either when it was originally\n * created or set via `setMeta`.\n * - `publicKey` returns the public key stored in memory for the pair.\n * - `sign` may be used to return a signature by signing a provided message with the secret\n * key (if it is in memory) using Nacl.\n * - `toJson` calls another `toJson` function and provides the state of the pair,\n * it generates arguments to be passed to the other `toJson` function including an encoded public key of the account\n * that it generates using the secret key from memory (if it has been made available in memory)\n * and the optionally provided passphrase argument. It passes a third boolean argument to `toJson`\n * indicating whether the public key has been encoded or not (if a passphrase argument was provided then it is encoded).\n * The `toJson` function that it calls returns a JSON object with properties including the `address`\n * and `meta` that are assigned with the values stored in the corresponding state variables of the account pair,\n * an `encoded` property that is assigned with the encoded public key in hex format, and an `encoding`\n * property that indicates whether the public key value of the `encoded` property is encoded or not.\n */\n\n\nexport function createPair({\n  toSS58,\n  type\n}, {\n  publicKey,\n  secretKey\n}, meta = {}, encoded = null, encTypes) {\n  const decodePkcs8 = (passphrase, userEncoded) => {\n    const decoded = decodePair(passphrase, userEncoded || encoded, encTypes);\n\n    if (decoded.secretKey.length === 64) {\n      publicKey = decoded.publicKey;\n      secretKey = decoded.secretKey;\n    } else {\n      const pair = TYPE_FROM_SEED[type](decoded.secretKey);\n      publicKey = pair.publicKey;\n      secretKey = pair.secretKey;\n    }\n  };\n\n  const recode = passphrase => {\n    isLocked(secretKey) && encoded && decodePkcs8(passphrase, encoded);\n    encoded = encodePair({\n      publicKey,\n      secretKey\n    }, passphrase); // re-encode, latest version\n\n    encTypes = undefined; // swap to defaults, latest version follows\n\n    return encoded;\n  };\n\n  const encodeAddress = () => {\n    const raw = TYPE_ADDRESS[type](publicKey);\n    return type === 'ethereum' ? ethereumEncode(raw) : toSS58(raw);\n  };\n\n  return {\n    get address() {\n      return encodeAddress();\n    },\n\n    get addressRaw() {\n      const raw = TYPE_ADDRESS[type](publicKey);\n      return type === 'ethereum' ? raw.slice(-20) : raw;\n    },\n\n    get isLocked() {\n      return isLocked(secretKey);\n    },\n\n    get meta() {\n      return meta;\n    },\n\n    get publicKey() {\n      return publicKey;\n    },\n\n    get type() {\n      return type;\n    },\n\n    // eslint-disable-next-line sort-keys\n    decodePkcs8,\n    derive: (suri, meta) => {\n      assert(!isLocked(secretKey), 'Cannot derive on a locked keypair');\n      const {\n        path\n      } = keyExtractPath(suri);\n      const derived = keyFromPath({\n        publicKey,\n        secretKey\n      }, path, type);\n      return createPair({\n        toSS58,\n        type\n      }, derived, meta, null);\n    },\n    encodePkcs8: passphrase => {\n      return recode(passphrase);\n    },\n    lock: () => {\n      secretKey = new Uint8Array();\n    },\n    setMeta: additional => {\n      meta = _objectSpread(_objectSpread({}, meta), additional);\n    },\n    sign: (message, options = {}) => {\n      assert(!isLocked(secretKey), 'Cannot sign with a locked key pair');\n      return u8aConcat(options.withType ? TYPE_PREFIX[type] : SIG_TYPE_NONE, TYPE_SIGNATURE[type](u8aToU8a(message), {\n        publicKey,\n        secretKey\n      }));\n    },\n    toJson: passphrase => {\n      const address = ['ecdsa', 'ethereum'].includes(type) ? u8aToHex(secp256k1Compress(publicKey)) : encodeAddress();\n      return pairToJson(type, {\n        address,\n        meta\n      }, recode(passphrase), !!passphrase);\n    },\n    verify: (message, signature) => {\n      return signatureVerify(message, signature, TYPE_ADDRESS[type](publicKey)).isValid;\n    },\n    vrfSign: (message, context, extra) => {\n      assert(!isLocked(secretKey), 'Cannot sign with a locked key pair');\n\n      if (type === 'sr25519') {\n        return schnorrkelVrfSign(message, {\n          secretKey\n        }, context, extra);\n      }\n\n      const proof = TYPE_SIGNATURE[type](u8aToU8a(message), {\n        publicKey,\n        secretKey\n      });\n      return u8aConcat(vrfHash(proof, context, extra), proof);\n    },\n    vrfVerify: (message, vrfResult, context, extra) => {\n      return type === 'sr25519' ? schnorrkelVrfVerify(message, vrfResult, publicKey, context, extra) : signatureVerify(message, u8aConcat(TYPE_PREFIX[type], vrfResult.subarray(32)), TYPE_ADDRESS[type](publicKey)).isValid && u8aEq(vrfResult.subarray(0, 32), vrfHash(vrfResult.subarray(32), context, extra));\n    }\n  };\n}","map":{"version":3,"sources":["/Users/bmacer/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/keyring/pair/index.mjs"],"names":["_defineProperty","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","assert","u8aConcat","u8aEq","u8aToHex","u8aToU8a","blake2AsU8a","ethereumEncode","keccakAsU8a","keyExtractPath","keyFromPath","naclKeypairFromSeed","naclFromSeed","naclSign","schnorrkelKeypairFromSeed","schnorrkelFromSeed","schnorrkelSign","schnorrkelVrfSign","schnorrkelVrfVerify","secp256k1Compress","secp256k1Expand","secp256k1KeypairFromSeed","secp256k1FromSeed","secp256k1Sign","signatureVerify","decodePair","encodePair","pairToJson","SIG_TYPE_NONE","Uint8Array","TYPE_FROM_SEED","ecdsa","ed25519","ethereum","sr25519","TYPE_PREFIX","TYPE_SIGNATURE","m","p","TYPE_ADDRESS","isLocked","secretKey","every","b","vrfHash","proof","context","extra","createPair","toSS58","type","publicKey","meta","encoded","encTypes","decodePkcs8","passphrase","userEncoded","decoded","pair","recode","undefined","encodeAddress","raw","address","addressRaw","slice","derive","suri","path","derived","encodePkcs8","lock","setMeta","additional","sign","message","options","withType","toJson","includes","verify","signature","isValid","vrfSign","vrfVerify","vrfResult","subarray"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/keyring authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, u8aConcat, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { blake2AsU8a, ethereumEncode, keccakAsU8a, keyExtractPath, keyFromPath, naclKeypairFromSeed as naclFromSeed, naclSign, schnorrkelKeypairFromSeed as schnorrkelFromSeed, schnorrkelSign, schnorrkelVrfSign, schnorrkelVrfVerify, secp256k1Compress, secp256k1Expand, secp256k1KeypairFromSeed as secp256k1FromSeed, secp256k1Sign, signatureVerify } from '@polkadot/util-crypto';\nimport { decodePair } from \"./decode.mjs\";\nimport { encodePair } from \"./encode.mjs\";\nimport { pairToJson } from \"./toJson.mjs\";\nconst SIG_TYPE_NONE = new Uint8Array();\nconst TYPE_FROM_SEED = {\n  ecdsa: secp256k1FromSeed,\n  ed25519: naclFromSeed,\n  ethereum: secp256k1FromSeed,\n  sr25519: schnorrkelFromSeed\n};\nconst TYPE_PREFIX = {\n  ecdsa: new Uint8Array([2]),\n  ed25519: new Uint8Array([0]),\n  ethereum: new Uint8Array([2]),\n  sr25519: new Uint8Array([1])\n};\nconst TYPE_SIGNATURE = {\n  ecdsa: (m, p) => secp256k1Sign(m, p, 'blake2'),\n  ed25519: naclSign,\n  ethereum: (m, p) => secp256k1Sign(m, p, 'keccak'),\n  sr25519: schnorrkelSign\n};\nconst TYPE_ADDRESS = {\n  ecdsa: p => p.length > 32 ? blake2AsU8a(p) : p,\n  ed25519: p => p,\n  ethereum: p => keccakAsU8a(secp256k1Expand(p)),\n  sr25519: p => p\n}; // Not 100% correct, since it can be a Uint8Array, but an invalid one - just say \"undefined\" is anything non-valid\n\nfunction isLocked(secretKey) {\n  return !secretKey || secretKey.length === 0 || secretKey.every(b => b === 0);\n}\n\nfunction vrfHash(proof, context, extra) {\n  return blake2AsU8a(u8aConcat(context || '', extra || '', proof));\n}\n/**\n * @name createPair\n * @summary Creates a keyring pair object\n * @description Creates a keyring pair object with provided account public key, metadata, and encoded arguments.\n * The keyring pair stores the account state including the encoded address and associated metadata.\n *\n * It has properties whose values are functions that may be called to perform account actions:\n *\n * - `address` function retrieves the address associated with the account.\n * - `decodedPkcs8` function is called with the account passphrase and account encoded public key.\n * It decodes the encoded public key using the passphrase provided to obtain the decoded account public key\n * and associated secret key that are then available in memory, and changes the account address stored in the\n * state of the pair to correspond to the address of the decoded public key.\n * - `encodePkcs8` function when provided with the correct passphrase associated with the account pair\n * and when the secret key is in memory (when the account pair is not locked) it returns an encoded\n * public key of the account.\n * - `meta` is the metadata that is stored in the state of the pair, either when it was originally\n * created or set via `setMeta`.\n * - `publicKey` returns the public key stored in memory for the pair.\n * - `sign` may be used to return a signature by signing a provided message with the secret\n * key (if it is in memory) using Nacl.\n * - `toJson` calls another `toJson` function and provides the state of the pair,\n * it generates arguments to be passed to the other `toJson` function including an encoded public key of the account\n * that it generates using the secret key from memory (if it has been made available in memory)\n * and the optionally provided passphrase argument. It passes a third boolean argument to `toJson`\n * indicating whether the public key has been encoded or not (if a passphrase argument was provided then it is encoded).\n * The `toJson` function that it calls returns a JSON object with properties including the `address`\n * and `meta` that are assigned with the values stored in the corresponding state variables of the account pair,\n * an `encoded` property that is assigned with the encoded public key in hex format, and an `encoding`\n * property that indicates whether the public key value of the `encoded` property is encoded or not.\n */\n\n\nexport function createPair({\n  toSS58,\n  type\n}, {\n  publicKey,\n  secretKey\n}, meta = {}, encoded = null, encTypes) {\n  const decodePkcs8 = (passphrase, userEncoded) => {\n    const decoded = decodePair(passphrase, userEncoded || encoded, encTypes);\n\n    if (decoded.secretKey.length === 64) {\n      publicKey = decoded.publicKey;\n      secretKey = decoded.secretKey;\n    } else {\n      const pair = TYPE_FROM_SEED[type](decoded.secretKey);\n      publicKey = pair.publicKey;\n      secretKey = pair.secretKey;\n    }\n  };\n\n  const recode = passphrase => {\n    isLocked(secretKey) && encoded && decodePkcs8(passphrase, encoded);\n    encoded = encodePair({\n      publicKey,\n      secretKey\n    }, passphrase); // re-encode, latest version\n\n    encTypes = undefined; // swap to defaults, latest version follows\n\n    return encoded;\n  };\n\n  const encodeAddress = () => {\n    const raw = TYPE_ADDRESS[type](publicKey);\n    return type === 'ethereum' ? ethereumEncode(raw) : toSS58(raw);\n  };\n\n  return {\n    get address() {\n      return encodeAddress();\n    },\n\n    get addressRaw() {\n      const raw = TYPE_ADDRESS[type](publicKey);\n      return type === 'ethereum' ? raw.slice(-20) : raw;\n    },\n\n    get isLocked() {\n      return isLocked(secretKey);\n    },\n\n    get meta() {\n      return meta;\n    },\n\n    get publicKey() {\n      return publicKey;\n    },\n\n    get type() {\n      return type;\n    },\n\n    // eslint-disable-next-line sort-keys\n    decodePkcs8,\n    derive: (suri, meta) => {\n      assert(!isLocked(secretKey), 'Cannot derive on a locked keypair');\n      const {\n        path\n      } = keyExtractPath(suri);\n      const derived = keyFromPath({\n        publicKey,\n        secretKey\n      }, path, type);\n      return createPair({\n        toSS58,\n        type\n      }, derived, meta, null);\n    },\n    encodePkcs8: passphrase => {\n      return recode(passphrase);\n    },\n    lock: () => {\n      secretKey = new Uint8Array();\n    },\n    setMeta: additional => {\n      meta = _objectSpread(_objectSpread({}, meta), additional);\n    },\n    sign: (message, options = {}) => {\n      assert(!isLocked(secretKey), 'Cannot sign with a locked key pair');\n      return u8aConcat(options.withType ? TYPE_PREFIX[type] : SIG_TYPE_NONE, TYPE_SIGNATURE[type](u8aToU8a(message), {\n        publicKey,\n        secretKey\n      }));\n    },\n    toJson: passphrase => {\n      const address = ['ecdsa', 'ethereum'].includes(type) ? u8aToHex(secp256k1Compress(publicKey)) : encodeAddress();\n      return pairToJson(type, {\n        address,\n        meta\n      }, recode(passphrase), !!passphrase);\n    },\n    verify: (message, signature) => {\n      return signatureVerify(message, signature, TYPE_ADDRESS[type](publicKey)).isValid;\n    },\n    vrfSign: (message, context, extra) => {\n      assert(!isLocked(secretKey), 'Cannot sign with a locked key pair');\n\n      if (type === 'sr25519') {\n        return schnorrkelVrfSign(message, {\n          secretKey\n        }, context, extra);\n      }\n\n      const proof = TYPE_SIGNATURE[type](u8aToU8a(message), {\n        publicKey,\n        secretKey\n      });\n      return u8aConcat(vrfHash(proof, context, extra), proof);\n    },\n    vrfVerify: (message, vrfResult, context, extra) => {\n      return type === 'sr25519' ? schnorrkelVrfVerify(message, vrfResult, publicKey, context, extra) : signatureVerify(message, u8aConcat(TYPE_PREFIX[type], vrfResult.subarray(32)), TYPE_ADDRESS[type](publicKey)).isValid && u8aEq(vrfResult.subarray(0, 32), vrfHash(vrfResult.subarray(32), context, extra));\n    }\n  };\n}"]},"metadata":{},"sourceType":"module"}