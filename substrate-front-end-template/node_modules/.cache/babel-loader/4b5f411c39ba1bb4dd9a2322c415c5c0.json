{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/api authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { Metadata } from '@polkadot/metadata';\nimport { TypeRegistry } from '@polkadot/types/create';\nimport { LATEST_EXTRINSIC_VERSION } from '@polkadot/types/extrinsic/Extrinsic';\nimport { getSpecAlias, getSpecExtensions, getSpecRpc, getSpecTypes, getUpgradeVersion } from '@polkadot/types-known';\nimport { assert, BN_ZERO, logger, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\nimport { of } from '@polkadot/x-rxjs';\nimport { map, switchMap } from '@polkadot/x-rxjs/operators';\nimport { Decorate } from \"./Decorate.mjs\";\nimport { detectedCapabilities } from \"./util.mjs\";\nconst KEEPALIVE_INTERVAL = 15000;\nconst DEFAULT_BLOCKNUMBER = {\n  unwrap: () => BN_ZERO\n};\nconst l = logger('api/init');\n\nvar _healthTimer = _classPrivateFieldLooseKey(\"healthTimer\");\n\nvar _registries = _classPrivateFieldLooseKey(\"registries\");\n\nvar _updateSub = _classPrivateFieldLooseKey(\"updateSub\");\n\nvar _onProviderConnect = _classPrivateFieldLooseKey(\"onProviderConnect\");\n\nvar _onProviderDisconnect = _classPrivateFieldLooseKey(\"onProviderDisconnect\");\n\nvar _onProviderError = _classPrivateFieldLooseKey(\"onProviderError\");\n\nexport class Init extends Decorate {\n  constructor(options, type, decorateMethod) {\n    super(options, type, decorateMethod); // all injected types added to the registry for overrides\n\n    Object.defineProperty(this, _healthTimer, {\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, _registries, {\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, _updateSub, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _onProviderConnect, {\n      writable: true,\n      value: async () => {\n        this.emit('connected');\n\n        this._isConnected.next(true);\n\n        try {\n          const [hasMeta, cryptoReady] = await Promise.all([this._loadMeta(), this._options.initWasm === false ? Promise.resolve(true) : cryptoWaitReady()]);\n\n          if (hasMeta && !this._isReady && cryptoReady) {\n            this._isReady = true;\n            this.emit('ready', this);\n          }\n\n          _classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer] = setInterval(() => {\n            this._rpcCore.system.health().toPromise().catch(() => null);\n          }, KEEPALIVE_INTERVAL);\n        } catch (_error) {\n          const error = new Error(`FATAL: Unable to initialize the API: ${_error.message}`);\n          l.error(error);\n          l.error(_error);\n          this.emit('error', error);\n        }\n      }\n    });\n    Object.defineProperty(this, _onProviderDisconnect, {\n      writable: true,\n      value: () => {\n        this.emit('disconnected');\n\n        this._isConnected.next(false);\n\n        if (_classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer]) {\n          clearInterval(_classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer]);\n          _classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer] = null;\n        }\n      }\n    });\n    Object.defineProperty(this, _onProviderError, {\n      writable: true,\n      value: error => {\n        this.emit('error', error);\n      }\n    });\n    this.registry.setKnownTypes(options); // We only register the types (global) if this is not a cloned instance.\n    // Do right up-front, so we get in the user types before we are actually\n    // doing anything on-chain, this ensures we have the overrides in-place\n\n    if (!options.source) {\n      this.registerTypes(options.types);\n    } else {\n      _classPrivateFieldLooseBase(this, _registries)[_registries] = _classPrivateFieldLooseBase(options.source, _registries)[_registries];\n    }\n\n    this._rpc = this._decorateRpc(this._rpcCore, this._decorateMethod);\n    this._rx.rpc = this._decorateRpc(this._rpcCore, this._rxDecorateMethod);\n\n    if (this.supportMulti) {\n      this._queryMulti = this._decorateMulti(this._decorateMethod);\n      this._rx.queryMulti = this._decorateMulti(this._rxDecorateMethod);\n    }\n\n    this._rx.signer = options.signer;\n\n    this._rpcCore.setRegistrySwap(hash => this.getBlockRegistry(hash));\n\n    if (this.hasSubscriptions) {\n      this._rpcCore.provider.on('disconnected', _classPrivateFieldLooseBase(this, _onProviderDisconnect)[_onProviderDisconnect]);\n\n      this._rpcCore.provider.on('error', _classPrivateFieldLooseBase(this, _onProviderError)[_onProviderError]);\n\n      this._rpcCore.provider.on('connected', _classPrivateFieldLooseBase(this, _onProviderConnect)[_onProviderConnect]);\n    } else {\n      l.warn('Api will be available in a limited mode since the provider does not support subscriptions');\n    } // If the provider was instantiated earlier, and has already emitted a\n    // 'connected' event, then the `on('connected')` won't fire anymore. To\n    // cater for this case, we call manually `this._onProviderConnect`.\n\n\n    if (this._rpcCore.provider.isConnected) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      _classPrivateFieldLooseBase(this, _onProviderConnect)[_onProviderConnect]();\n    }\n  }\n  /**\n   * @description Decorates a registry based on the runtime version\n   */\n\n\n  _initRegistry(registry, chain, version, metadata, chainProps) {\n    registry.setChainProperties(chainProps || this.registry.getChainProperties());\n    registry.setKnownTypes(this._options);\n    registry.register(getSpecTypes(registry, chain, version.specName, version.specVersion)); // for bundled types, pull through the aliases defined\n\n    if (registry.knownTypes.typesBundle) {\n      registry.knownTypes.typesAlias = getSpecAlias(registry, chain, version.specName);\n    }\n\n    registry.setMetadata(metadata, undefined, _objectSpread(_objectSpread({}, getSpecExtensions(registry, chain, version.specName)), this._options.signedExtensions || {}));\n    return registry;\n  }\n  /**\n   * @description Sets up a registry based on the block hash defined\n   */\n\n\n  async getBlockRegistry(blockHash) {\n    // shortcut in the case where we have an immediate-same request\n    const lastBlockHash = u8aToU8a(blockHash);\n\n    const existingViaHash = _classPrivateFieldLooseBase(this, _registries)[_registries].find(r => r.lastBlockHash && u8aEq(lastBlockHash, r.lastBlockHash));\n\n    if (existingViaHash) {\n      return existingViaHash;\n    } // ensure we have everything required\n\n\n    assert(this._genesisHash && this._runtimeVersion, 'Cannot retrieve data on an uninitialized chain'); // We have to assume that on the RPC layer the calls used here does not call back into\n    // the registry swap, so getHeader & getRuntimeVersion should not be historic\n\n    const header = this._genesisHash.eq(blockHash) ? {\n      number: DEFAULT_BLOCKNUMBER,\n      parentHash: this._genesisHash\n    } : await this._rpcCore.chain.getHeader(blockHash).toPromise();\n    assert((header === null || header === void 0 ? void 0 : header.parentHash) && !header.parentHash.isEmpty, 'Unable to retrieve header and parent from supplied hash'); // get the runtime version, either on-chain or via an known upgrade history\n\n    const [firstVersion, lastVersion] = getUpgradeVersion(this._genesisHash, header.number.unwrap());\n    const version = firstVersion && (lastVersion || firstVersion.specVersion.eq(this._runtimeVersion.specVersion)) ? {\n      specName: this._runtimeVersion.specName,\n      specVersion: firstVersion.specVersion\n    } : await this._rpcCore.state.getRuntimeVersion(header.parentHash).toPromise(); // check for pre-existing registries\n\n    const existingViaVersion = _classPrivateFieldLooseBase(this, _registries)[_registries].find(r => r.specVersion.eq(version.specVersion));\n\n    if (existingViaVersion) {\n      existingViaVersion.lastBlockHash = lastBlockHash;\n      return existingViaVersion;\n    } // nothing has been found, construct new\n\n\n    const metadata = await this._rpcCore.state.getMetadata(header.parentHash).toPromise();\n\n    const registry = this._initRegistry(new TypeRegistry(), this._runtimeChain, version, metadata); // For now, since this is new we ignore the capability lookups (this could be useful once proven)\n    // this._detectCapabilities(registry, blockHash);\n    // add our new registry\n\n\n    const result = {\n      isDefault: false,\n      lastBlockHash,\n      metadata,\n      metadataConsts: null,\n      registry,\n      specVersion: version.specVersion\n    };\n\n    _classPrivateFieldLooseBase(this, _registries)[_registries].push(result);\n\n    return result;\n  }\n\n  async _loadMeta() {\n    var _this$_options$source; // on re-connection to the same chain, we don't want to re-do everything from chain again\n\n\n    if (this._isReady) {\n      return true;\n    } else if (_classPrivateFieldLooseBase(this, _updateSub)[_updateSub]) {\n      _classPrivateFieldLooseBase(this, _updateSub)[_updateSub].unsubscribe();\n    } // only load from on-chain if we are not a clone (default path), alternatively\n    // just use the values from the source instance provided\n\n\n    [this._genesisHash, this._runtimeMetadata] = (_this$_options$source = this._options.source) !== null && _this$_options$source !== void 0 && _this$_options$source._isReady ? await this._metaFromSource(this._options.source) : await this._metaFromChain(this._options.metadata);\n    return this._initFromMeta(this._runtimeMetadata);\n  } // eslint-disable-next-line @typescript-eslint/require-await\n\n\n  async _metaFromSource(source) {\n    this._extrinsicType = source.extrinsicVersion;\n    this._runtimeChain = source.runtimeChain;\n    this._runtimeVersion = source.runtimeVersion;\n    const methods = []; // manually build a list of all available methods in this RPC, we are\n    // going to filter on it to align the cloned RPC without making a call\n\n    Object.keys(source.rpc).forEach(section => {\n      Object.keys(source.rpc[section]).forEach(method => {\n        methods.push(`${section}_${method}`);\n      });\n    });\n\n    this._filterRpcMethods(methods);\n\n    return [source.genesisHash, source.runtimeMetadata];\n  }\n\n  _detectCapabilities(registry, blockHash) {\n    detectedCapabilities(this._rx, blockHash).toPromise().then(types => {\n      if (Object.keys(types).length) {\n        (registry || this.registry).register(types);\n        l.debug(`Capabilities detected${blockHash ? ` (${u8aToHex(u8aToU8a(blockHash))})` : ''}: ${JSON.stringify(types)}`);\n      }\n    }).catch(l.error);\n  } // subscribe to metadata updates, inject the types on changes\n\n\n  _subscribeUpdates() {\n    if (_classPrivateFieldLooseBase(this, _updateSub)[_updateSub] || !this.hasSubscriptions) {\n      return;\n    }\n\n    _classPrivateFieldLooseBase(this, _updateSub)[_updateSub] = this._rpcCore.state.subscribeRuntimeVersion().pipe(switchMap(version => {\n      var _this$_runtimeVersion;\n\n      return (// only retrieve the metadata when the on-chain version has been changed\n        (_this$_runtimeVersion = this._runtimeVersion) !== null && _this$_runtimeVersion !== void 0 && _this$_runtimeVersion.specVersion.eq(version.specVersion) ? of(false) : this._rpcCore.state.getMetadata().pipe(map(metadata => {\n          l.log(`Runtime version updated to spec=${version.specVersion.toString()}, tx=${version.transactionVersion.toString()}`);\n          this._runtimeMetadata = metadata;\n          this._runtimeVersion = version;\n          this._rx.runtimeVersion = version; // update the default registry version\n\n          const thisRegistry = _classPrivateFieldLooseBase(this, _registries)[_registries].find(({\n            isDefault\n          }) => isDefault);\n\n          assert(thisRegistry, 'Initialization error, cannot find the default registry'); // setup the data as per the current versions\n\n          thisRegistry.metadata = metadata;\n          thisRegistry.metadataConsts = null;\n          thisRegistry.specVersion = version.specVersion; // clear the registry types to ensure that we override correctly\n\n          this._initRegistry(thisRegistry.registry.init(), this._runtimeChain, version, metadata);\n\n          this.injectMetadata(metadata, false, thisRegistry.registry);\n\n          this._detectCapabilities(thisRegistry.registry);\n\n          return true;\n        }))\n      );\n    })).subscribe();\n  }\n\n  async _metaFromChain(optMetadata) {\n    const [genesisHash, runtimeVersion, chain, chainProps, rpcMethods, chainMetadata] = await Promise.all([this._rpcCore.chain.getBlockHash(0).toPromise(), this._rpcCore.state.getRuntimeVersion().toPromise(), this._rpcCore.system.chain().toPromise(), this._rpcCore.system.properties().toPromise(), this._rpcCore.rpc.methods().toPromise(), optMetadata ? Promise.resolve(null) : this._rpcCore.state.getMetadata().toPromise()]); // set our chain version & genesisHash as returned\n\n    this._runtimeChain = chain;\n    this._runtimeVersion = runtimeVersion;\n    this._rx.runtimeVersion = runtimeVersion; // retrieve metadata, either from chain  or as pass-in via options\n\n    const metadataKey = `${genesisHash.toHex() || '0x'}-${runtimeVersion.specVersion.toString()}`;\n    const metadata = chainMetadata || (optMetadata && optMetadata[metadataKey] ? new Metadata(this.registry, optMetadata[metadataKey]) : await this._rpcCore.state.getMetadata().toPromise()); // initializes the registry & RPC\n\n    this._initRegistry(this.registry, chain, runtimeVersion, metadata, chainProps);\n\n    this._filterRpc(rpcMethods, getSpecRpc(this.registry, chain, runtimeVersion.specName));\n\n    this._subscribeUpdates(); // setup the initial registry, when we have none\n\n\n    if (!_classPrivateFieldLooseBase(this, _registries)[_registries].length) {\n      _classPrivateFieldLooseBase(this, _registries)[_registries].push({\n        isDefault: true,\n        lastBlockHash: null,\n        metadata,\n        metadataConsts: null,\n        registry: this.registry,\n        specVersion: runtimeVersion.specVersion\n      });\n    } // get unique types & validate\n\n\n    metadata.getUniqTypes(false);\n    return [genesisHash, metadata];\n  }\n\n  async _initFromMeta(metadata) {\n    const metaExtrinsic = metadata.asLatest.extrinsic; // only inject if we are not a clone (global init)\n\n    if (metaExtrinsic.version.gt(BN_ZERO)) {\n      this._extrinsicType = metaExtrinsic.version.toNumber();\n    } else if (!this._options.source) {\n      // detect the extrinsic version in-use based on the last block\n      const {\n        block: {\n          extrinsics: [firstTx]\n        }\n      } = await this._rpcCore.chain.getBlock().toPromise(); // If we haven't sync-ed to 1 yes, this won't have any values\n\n      this._extrinsicType = firstTx ? firstTx.type : LATEST_EXTRINSIC_VERSION;\n    }\n\n    this._rx.extrinsicType = this._extrinsicType;\n    this._rx.genesisHash = this._genesisHash;\n    this._rx.runtimeVersion = this._runtimeVersion; // must be set here\n    // inject metadata and adjust the types as detected\n\n    this.injectMetadata(metadata, true);\n\n    this._detectCapabilities(); // derive is last, since it uses the decorated rx\n\n\n    this._rx.derive = this._decorateDeriveRx(this._rxDecorateMethod);\n    this._derive = this._decorateDerive(this._decorateMethod);\n    return true;\n  }\n\n}","map":{"version":3,"sources":["/Users/bmacer/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/api/base/Init.mjs"],"names":["_defineProperty","_classPrivateFieldLooseBase","_classPrivateFieldLooseKey","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","Metadata","TypeRegistry","LATEST_EXTRINSIC_VERSION","getSpecAlias","getSpecExtensions","getSpecRpc","getSpecTypes","getUpgradeVersion","assert","BN_ZERO","logger","u8aEq","u8aToHex","u8aToU8a","cryptoWaitReady","of","map","switchMap","Decorate","detectedCapabilities","KEEPALIVE_INTERVAL","DEFAULT_BLOCKNUMBER","unwrap","l","_healthTimer","_registries","_updateSub","_onProviderConnect","_onProviderDisconnect","_onProviderError","Init","constructor","options","type","decorateMethod","writable","value","emit","_isConnected","next","hasMeta","cryptoReady","Promise","all","_loadMeta","_options","initWasm","resolve","_isReady","setInterval","_rpcCore","system","health","toPromise","catch","_error","error","Error","message","clearInterval","registry","setKnownTypes","registerTypes","types","_rpc","_decorateRpc","_decorateMethod","_rx","rpc","_rxDecorateMethod","supportMulti","_queryMulti","_decorateMulti","queryMulti","signer","setRegistrySwap","hash","getBlockRegistry","hasSubscriptions","provider","on","warn","isConnected","_initRegistry","chain","version","metadata","chainProps","setChainProperties","getChainProperties","register","specName","specVersion","knownTypes","typesBundle","typesAlias","setMetadata","undefined","signedExtensions","blockHash","lastBlockHash","existingViaHash","find","r","_genesisHash","_runtimeVersion","header","eq","number","parentHash","getHeader","isEmpty","firstVersion","lastVersion","state","getRuntimeVersion","existingViaVersion","getMetadata","_runtimeChain","result","isDefault","metadataConsts","_this$_options$source","unsubscribe","_runtimeMetadata","_metaFromSource","_metaFromChain","_initFromMeta","_extrinsicType","extrinsicVersion","runtimeChain","runtimeVersion","methods","section","method","_filterRpcMethods","genesisHash","runtimeMetadata","_detectCapabilities","then","debug","JSON","stringify","_subscribeUpdates","subscribeRuntimeVersion","pipe","_this$_runtimeVersion","log","toString","transactionVersion","thisRegistry","init","injectMetadata","subscribe","optMetadata","rpcMethods","chainMetadata","getBlockHash","properties","metadataKey","toHex","_filterRpc","getUniqTypes","metaExtrinsic","asLatest","extrinsic","gt","toNumber","block","extrinsics","firstTx","getBlock","extrinsicType","derive","_decorateDeriveRx","_derive","_decorateDerive"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/api authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { Metadata } from '@polkadot/metadata';\nimport { TypeRegistry } from '@polkadot/types/create';\nimport { LATEST_EXTRINSIC_VERSION } from '@polkadot/types/extrinsic/Extrinsic';\nimport { getSpecAlias, getSpecExtensions, getSpecRpc, getSpecTypes, getUpgradeVersion } from '@polkadot/types-known';\nimport { assert, BN_ZERO, logger, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\nimport { of } from '@polkadot/x-rxjs';\nimport { map, switchMap } from '@polkadot/x-rxjs/operators';\nimport { Decorate } from \"./Decorate.mjs\";\nimport { detectedCapabilities } from \"./util.mjs\";\nconst KEEPALIVE_INTERVAL = 15000;\nconst DEFAULT_BLOCKNUMBER = {\n  unwrap: () => BN_ZERO\n};\nconst l = logger('api/init');\n\nvar _healthTimer = _classPrivateFieldLooseKey(\"healthTimer\");\n\nvar _registries = _classPrivateFieldLooseKey(\"registries\");\n\nvar _updateSub = _classPrivateFieldLooseKey(\"updateSub\");\n\nvar _onProviderConnect = _classPrivateFieldLooseKey(\"onProviderConnect\");\n\nvar _onProviderDisconnect = _classPrivateFieldLooseKey(\"onProviderDisconnect\");\n\nvar _onProviderError = _classPrivateFieldLooseKey(\"onProviderError\");\n\nexport class Init extends Decorate {\n  constructor(options, type, decorateMethod) {\n    super(options, type, decorateMethod); // all injected types added to the registry for overrides\n\n    Object.defineProperty(this, _healthTimer, {\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, _registries, {\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, _updateSub, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _onProviderConnect, {\n      writable: true,\n      value: async () => {\n        this.emit('connected');\n\n        this._isConnected.next(true);\n\n        try {\n          const [hasMeta, cryptoReady] = await Promise.all([this._loadMeta(), this._options.initWasm === false ? Promise.resolve(true) : cryptoWaitReady()]);\n\n          if (hasMeta && !this._isReady && cryptoReady) {\n            this._isReady = true;\n            this.emit('ready', this);\n          }\n\n          _classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer] = setInterval(() => {\n            this._rpcCore.system.health().toPromise().catch(() => null);\n          }, KEEPALIVE_INTERVAL);\n        } catch (_error) {\n          const error = new Error(`FATAL: Unable to initialize the API: ${_error.message}`);\n          l.error(error);\n          l.error(_error);\n          this.emit('error', error);\n        }\n      }\n    });\n    Object.defineProperty(this, _onProviderDisconnect, {\n      writable: true,\n      value: () => {\n        this.emit('disconnected');\n\n        this._isConnected.next(false);\n\n        if (_classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer]) {\n          clearInterval(_classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer]);\n          _classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer] = null;\n        }\n      }\n    });\n    Object.defineProperty(this, _onProviderError, {\n      writable: true,\n      value: error => {\n        this.emit('error', error);\n      }\n    });\n    this.registry.setKnownTypes(options); // We only register the types (global) if this is not a cloned instance.\n    // Do right up-front, so we get in the user types before we are actually\n    // doing anything on-chain, this ensures we have the overrides in-place\n\n    if (!options.source) {\n      this.registerTypes(options.types);\n    } else {\n      _classPrivateFieldLooseBase(this, _registries)[_registries] = _classPrivateFieldLooseBase(options.source, _registries)[_registries];\n    }\n\n    this._rpc = this._decorateRpc(this._rpcCore, this._decorateMethod);\n    this._rx.rpc = this._decorateRpc(this._rpcCore, this._rxDecorateMethod);\n\n    if (this.supportMulti) {\n      this._queryMulti = this._decorateMulti(this._decorateMethod);\n      this._rx.queryMulti = this._decorateMulti(this._rxDecorateMethod);\n    }\n\n    this._rx.signer = options.signer;\n\n    this._rpcCore.setRegistrySwap(hash => this.getBlockRegistry(hash));\n\n    if (this.hasSubscriptions) {\n      this._rpcCore.provider.on('disconnected', _classPrivateFieldLooseBase(this, _onProviderDisconnect)[_onProviderDisconnect]);\n\n      this._rpcCore.provider.on('error', _classPrivateFieldLooseBase(this, _onProviderError)[_onProviderError]);\n\n      this._rpcCore.provider.on('connected', _classPrivateFieldLooseBase(this, _onProviderConnect)[_onProviderConnect]);\n    } else {\n      l.warn('Api will be available in a limited mode since the provider does not support subscriptions');\n    } // If the provider was instantiated earlier, and has already emitted a\n    // 'connected' event, then the `on('connected')` won't fire anymore. To\n    // cater for this case, we call manually `this._onProviderConnect`.\n\n\n    if (this._rpcCore.provider.isConnected) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      _classPrivateFieldLooseBase(this, _onProviderConnect)[_onProviderConnect]();\n    }\n  }\n  /**\n   * @description Decorates a registry based on the runtime version\n   */\n\n\n  _initRegistry(registry, chain, version, metadata, chainProps) {\n    registry.setChainProperties(chainProps || this.registry.getChainProperties());\n    registry.setKnownTypes(this._options);\n    registry.register(getSpecTypes(registry, chain, version.specName, version.specVersion)); // for bundled types, pull through the aliases defined\n\n    if (registry.knownTypes.typesBundle) {\n      registry.knownTypes.typesAlias = getSpecAlias(registry, chain, version.specName);\n    }\n\n    registry.setMetadata(metadata, undefined, _objectSpread(_objectSpread({}, getSpecExtensions(registry, chain, version.specName)), this._options.signedExtensions || {}));\n    return registry;\n  }\n  /**\n   * @description Sets up a registry based on the block hash defined\n   */\n\n\n  async getBlockRegistry(blockHash) {\n    // shortcut in the case where we have an immediate-same request\n    const lastBlockHash = u8aToU8a(blockHash);\n\n    const existingViaHash = _classPrivateFieldLooseBase(this, _registries)[_registries].find(r => r.lastBlockHash && u8aEq(lastBlockHash, r.lastBlockHash));\n\n    if (existingViaHash) {\n      return existingViaHash;\n    } // ensure we have everything required\n\n\n    assert(this._genesisHash && this._runtimeVersion, 'Cannot retrieve data on an uninitialized chain'); // We have to assume that on the RPC layer the calls used here does not call back into\n    // the registry swap, so getHeader & getRuntimeVersion should not be historic\n\n    const header = this._genesisHash.eq(blockHash) ? {\n      number: DEFAULT_BLOCKNUMBER,\n      parentHash: this._genesisHash\n    } : await this._rpcCore.chain.getHeader(blockHash).toPromise();\n    assert((header === null || header === void 0 ? void 0 : header.parentHash) && !header.parentHash.isEmpty, 'Unable to retrieve header and parent from supplied hash'); // get the runtime version, either on-chain or via an known upgrade history\n\n    const [firstVersion, lastVersion] = getUpgradeVersion(this._genesisHash, header.number.unwrap());\n    const version = firstVersion && (lastVersion || firstVersion.specVersion.eq(this._runtimeVersion.specVersion)) ? {\n      specName: this._runtimeVersion.specName,\n      specVersion: firstVersion.specVersion\n    } : await this._rpcCore.state.getRuntimeVersion(header.parentHash).toPromise(); // check for pre-existing registries\n\n    const existingViaVersion = _classPrivateFieldLooseBase(this, _registries)[_registries].find(r => r.specVersion.eq(version.specVersion));\n\n    if (existingViaVersion) {\n      existingViaVersion.lastBlockHash = lastBlockHash;\n      return existingViaVersion;\n    } // nothing has been found, construct new\n\n\n    const metadata = await this._rpcCore.state.getMetadata(header.parentHash).toPromise();\n\n    const registry = this._initRegistry(new TypeRegistry(), this._runtimeChain, version, metadata); // For now, since this is new we ignore the capability lookups (this could be useful once proven)\n    // this._detectCapabilities(registry, blockHash);\n    // add our new registry\n\n\n    const result = {\n      isDefault: false,\n      lastBlockHash,\n      metadata,\n      metadataConsts: null,\n      registry,\n      specVersion: version.specVersion\n    };\n\n    _classPrivateFieldLooseBase(this, _registries)[_registries].push(result);\n\n    return result;\n  }\n\n  async _loadMeta() {\n    var _this$_options$source;\n\n    // on re-connection to the same chain, we don't want to re-do everything from chain again\n    if (this._isReady) {\n      return true;\n    } else if (_classPrivateFieldLooseBase(this, _updateSub)[_updateSub]) {\n      _classPrivateFieldLooseBase(this, _updateSub)[_updateSub].unsubscribe();\n    } // only load from on-chain if we are not a clone (default path), alternatively\n    // just use the values from the source instance provided\n\n\n    [this._genesisHash, this._runtimeMetadata] = (_this$_options$source = this._options.source) !== null && _this$_options$source !== void 0 && _this$_options$source._isReady ? await this._metaFromSource(this._options.source) : await this._metaFromChain(this._options.metadata);\n    return this._initFromMeta(this._runtimeMetadata);\n  } // eslint-disable-next-line @typescript-eslint/require-await\n\n\n  async _metaFromSource(source) {\n    this._extrinsicType = source.extrinsicVersion;\n    this._runtimeChain = source.runtimeChain;\n    this._runtimeVersion = source.runtimeVersion;\n    const methods = []; // manually build a list of all available methods in this RPC, we are\n    // going to filter on it to align the cloned RPC without making a call\n\n    Object.keys(source.rpc).forEach(section => {\n      Object.keys(source.rpc[section]).forEach(method => {\n        methods.push(`${section}_${method}`);\n      });\n    });\n\n    this._filterRpcMethods(methods);\n\n    return [source.genesisHash, source.runtimeMetadata];\n  }\n\n  _detectCapabilities(registry, blockHash) {\n    detectedCapabilities(this._rx, blockHash).toPromise().then(types => {\n      if (Object.keys(types).length) {\n        (registry || this.registry).register(types);\n        l.debug(`Capabilities detected${blockHash ? ` (${u8aToHex(u8aToU8a(blockHash))})` : ''}: ${JSON.stringify(types)}`);\n      }\n    }).catch(l.error);\n  } // subscribe to metadata updates, inject the types on changes\n\n\n  _subscribeUpdates() {\n    if (_classPrivateFieldLooseBase(this, _updateSub)[_updateSub] || !this.hasSubscriptions) {\n      return;\n    }\n\n    _classPrivateFieldLooseBase(this, _updateSub)[_updateSub] = this._rpcCore.state.subscribeRuntimeVersion().pipe(switchMap(version => {\n      var _this$_runtimeVersion;\n\n      return (// only retrieve the metadata when the on-chain version has been changed\n        (_this$_runtimeVersion = this._runtimeVersion) !== null && _this$_runtimeVersion !== void 0 && _this$_runtimeVersion.specVersion.eq(version.specVersion) ? of(false) : this._rpcCore.state.getMetadata().pipe(map(metadata => {\n          l.log(`Runtime version updated to spec=${version.specVersion.toString()}, tx=${version.transactionVersion.toString()}`);\n          this._runtimeMetadata = metadata;\n          this._runtimeVersion = version;\n          this._rx.runtimeVersion = version; // update the default registry version\n\n          const thisRegistry = _classPrivateFieldLooseBase(this, _registries)[_registries].find(({\n            isDefault\n          }) => isDefault);\n\n          assert(thisRegistry, 'Initialization error, cannot find the default registry'); // setup the data as per the current versions\n\n          thisRegistry.metadata = metadata;\n          thisRegistry.metadataConsts = null;\n          thisRegistry.specVersion = version.specVersion; // clear the registry types to ensure that we override correctly\n\n          this._initRegistry(thisRegistry.registry.init(), this._runtimeChain, version, metadata);\n\n          this.injectMetadata(metadata, false, thisRegistry.registry);\n\n          this._detectCapabilities(thisRegistry.registry);\n\n          return true;\n        }))\n      );\n    })).subscribe();\n  }\n\n  async _metaFromChain(optMetadata) {\n    const [genesisHash, runtimeVersion, chain, chainProps, rpcMethods, chainMetadata] = await Promise.all([this._rpcCore.chain.getBlockHash(0).toPromise(), this._rpcCore.state.getRuntimeVersion().toPromise(), this._rpcCore.system.chain().toPromise(), this._rpcCore.system.properties().toPromise(), this._rpcCore.rpc.methods().toPromise(), optMetadata ? Promise.resolve(null) : this._rpcCore.state.getMetadata().toPromise()]); // set our chain version & genesisHash as returned\n\n    this._runtimeChain = chain;\n    this._runtimeVersion = runtimeVersion;\n    this._rx.runtimeVersion = runtimeVersion; // retrieve metadata, either from chain  or as pass-in via options\n\n    const metadataKey = `${genesisHash.toHex() || '0x'}-${runtimeVersion.specVersion.toString()}`;\n    const metadata = chainMetadata || (optMetadata && optMetadata[metadataKey] ? new Metadata(this.registry, optMetadata[metadataKey]) : await this._rpcCore.state.getMetadata().toPromise()); // initializes the registry & RPC\n\n    this._initRegistry(this.registry, chain, runtimeVersion, metadata, chainProps);\n\n    this._filterRpc(rpcMethods, getSpecRpc(this.registry, chain, runtimeVersion.specName));\n\n    this._subscribeUpdates(); // setup the initial registry, when we have none\n\n\n    if (!_classPrivateFieldLooseBase(this, _registries)[_registries].length) {\n      _classPrivateFieldLooseBase(this, _registries)[_registries].push({\n        isDefault: true,\n        lastBlockHash: null,\n        metadata,\n        metadataConsts: null,\n        registry: this.registry,\n        specVersion: runtimeVersion.specVersion\n      });\n    } // get unique types & validate\n\n\n    metadata.getUniqTypes(false);\n    return [genesisHash, metadata];\n  }\n\n  async _initFromMeta(metadata) {\n    const metaExtrinsic = metadata.asLatest.extrinsic; // only inject if we are not a clone (global init)\n\n    if (metaExtrinsic.version.gt(BN_ZERO)) {\n      this._extrinsicType = metaExtrinsic.version.toNumber();\n    } else if (!this._options.source) {\n      // detect the extrinsic version in-use based on the last block\n      const {\n        block: {\n          extrinsics: [firstTx]\n        }\n      } = await this._rpcCore.chain.getBlock().toPromise(); // If we haven't sync-ed to 1 yes, this won't have any values\n\n      this._extrinsicType = firstTx ? firstTx.type : LATEST_EXTRINSIC_VERSION;\n    }\n\n    this._rx.extrinsicType = this._extrinsicType;\n    this._rx.genesisHash = this._genesisHash;\n    this._rx.runtimeVersion = this._runtimeVersion; // must be set here\n    // inject metadata and adjust the types as detected\n\n    this.injectMetadata(metadata, true);\n\n    this._detectCapabilities(); // derive is last, since it uses the decorated rx\n\n\n    this._rx.derive = this._decorateDeriveRx(this._rxDecorateMethod);\n    this._derive = this._decorateDerive(this._decorateMethod);\n    return true;\n  }\n\n}"]},"metadata":{},"sourceType":"module"}