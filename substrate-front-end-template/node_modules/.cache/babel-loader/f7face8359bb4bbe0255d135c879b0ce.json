{"ast":null,"code":"var _jsxFileName = \"/Users/bmacer/substrate-node-template/substrate-front-end-template/src/substrate-lib/SubstrateContext.js\",\n    _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nimport React, { useReducer, useContext } from 'react';\nimport PropTypes from 'prop-types';\nimport jsonrpc from '@polkadot/types/interfaces/jsonrpc';\nimport queryString from 'query-string';\nimport { ApiPromise, WsProvider } from '@polkadot/api';\nimport { web3Accounts, web3Enable } from '@polkadot/extension-dapp';\nimport keyring from '@polkadot/ui-keyring';\nimport config from '../config';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst parsedQuery = queryString.parse(window.location.search);\nconst connectedSocket = parsedQuery.rpc || config.PROVIDER_SOCKET;\nconsole.log(`Connected socket: ${connectedSocket}`); ///\n// Initial state for `useReducer`\n\nconst INIT_STATE = {\n  socket: connectedSocket,\n  jsonrpc: { ...jsonrpc,\n    ...config.RPC\n  },\n  types: config.types,\n  keyring: null,\n  keyringState: null,\n  api: null,\n  apiError: null,\n  apiState: null\n}; ///\n// Reducer function for `useReducer`\n\nconst reducer = (state, action) => {\n  switch (action.type) {\n    case 'CONNECT_INIT':\n      return { ...state,\n        apiState: 'CONNECT_INIT'\n      };\n\n    case 'CONNECT':\n      return { ...state,\n        api: action.payload,\n        apiState: 'CONNECTING'\n      };\n\n    case 'CONNECT_SUCCESS':\n      return { ...state,\n        apiState: 'READY'\n      };\n\n    case 'CONNECT_ERROR':\n      return { ...state,\n        apiState: 'ERROR',\n        apiError: action.payload\n      };\n\n    case 'LOAD_KEYRING':\n      return { ...state,\n        keyringState: 'LOADING'\n      };\n\n    case 'SET_KEYRING':\n      return { ...state,\n        keyring: action.payload,\n        keyringState: 'READY'\n      };\n\n    case 'KEYRING_ERROR':\n      return { ...state,\n        keyring: null,\n        keyringState: 'ERROR'\n      };\n\n    default:\n      throw new Error(`Unknown type: ${action.type}`);\n  }\n}; ///\n// Connecting to the Substrate node\n\n\nconst connect = (state, dispatch) => {\n  const {\n    apiState,\n    socket,\n    jsonrpc,\n    types\n  } = state; // We only want this function to be performed once\n\n  if (apiState) return;\n  dispatch({\n    type: 'CONNECT_INIT'\n  });\n  const provider = new WsProvider(socket);\n\n  const _api = new ApiPromise({\n    provider,\n    types,\n    rpc: jsonrpc\n  }); // Set listeners for disconnection and reconnection event.\n\n\n  _api.on('connected', () => {\n    dispatch({\n      type: 'CONNECT',\n      payload: _api\n    }); // `ready` event is not emitted upon reconnection and is checked explicitly here.\n\n    _api.isReady.then(_api => dispatch({\n      type: 'CONNECT_SUCCESS'\n    }));\n  });\n\n  _api.on('ready', () => dispatch({\n    type: 'CONNECT_SUCCESS'\n  }));\n\n  _api.on('error', err => dispatch({\n    type: 'CONNECT_ERROR',\n    payload: err\n  }));\n}; ///\n// Loading accounts from dev and polkadot-js extension\n\n\nlet loadAccts = false;\n\nconst loadAccounts = (state, dispatch) => {\n  const asyncLoadAccounts = async () => {\n    dispatch({\n      type: 'LOAD_KEYRING'\n    });\n\n    try {\n      await web3Enable(config.APP_NAME);\n      let allAccounts = await web3Accounts();\n      allAccounts = allAccounts.map(({\n        address,\n        meta\n      }) => ({\n        address,\n        meta: { ...meta,\n          name: `${meta.name} (${meta.source})`\n        }\n      }));\n      keyring.loadAll({\n        isDevelopment: config.DEVELOPMENT_KEYRING\n      }, allAccounts);\n      dispatch({\n        type: 'SET_KEYRING',\n        payload: keyring\n      });\n    } catch (e) {\n      console.error(e);\n      dispatch({\n        type: 'KEYRING_ERROR'\n      });\n    }\n  };\n\n  const {\n    keyringState\n  } = state; // If `keyringState` is not null `asyncLoadAccounts` is running.\n\n  if (keyringState) return; // If `loadAccts` is true, the `asyncLoadAccounts` has been run once.\n\n  if (loadAccts) return dispatch({\n    type: 'SET_KEYRING',\n    payload: keyring\n  }); // This is the heavy duty work\n\n  loadAccts = true;\n  asyncLoadAccounts();\n};\n\nconst SubstrateContext = /*#__PURE__*/React.createContext();\n\nconst SubstrateContextProvider = props => {\n  _s();\n\n  // filtering props and merge with default param value\n  const initState = { ...INIT_STATE\n  };\n  const neededPropNames = ['socket', 'types'];\n  neededPropNames.forEach(key => {\n    initState[key] = typeof props[key] === 'undefined' ? initState[key] : props[key];\n  });\n  const [state, dispatch] = useReducer(reducer, initState);\n  connect(state, dispatch);\n  loadAccounts(state, dispatch);\n  return /*#__PURE__*/_jsxDEV(SubstrateContext.Provider, {\n    value: state,\n    children: props.children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 129,\n    columnNumber: 10\n  }, this);\n}; // prop typechecking\n\n\n_s(SubstrateContextProvider, \"ivzsx5aR9qRFuEtyOcndflQiQ1Q=\");\n\n_c = SubstrateContextProvider;\nSubstrateContextProvider.propTypes = {\n  socket: PropTypes.string,\n  types: PropTypes.object\n};\n\nconst useSubstrate = () => {\n  _s2();\n\n  return { ...useContext(SubstrateContext)\n  };\n};\n\n_s2(useSubstrate, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n\nexport { SubstrateContextProvider, useSubstrate };\n\nvar _c;\n\n$RefreshReg$(_c, \"SubstrateContextProvider\");","map":{"version":3,"sources":["/Users/bmacer/substrate-node-template/substrate-front-end-template/src/substrate-lib/SubstrateContext.js"],"names":["React","useReducer","useContext","PropTypes","jsonrpc","queryString","ApiPromise","WsProvider","web3Accounts","web3Enable","keyring","config","parsedQuery","parse","window","location","search","connectedSocket","rpc","PROVIDER_SOCKET","console","log","INIT_STATE","socket","RPC","types","keyringState","api","apiError","apiState","reducer","state","action","type","payload","Error","connect","dispatch","provider","_api","on","isReady","then","err","loadAccts","loadAccounts","asyncLoadAccounts","APP_NAME","allAccounts","map","address","meta","name","source","loadAll","isDevelopment","DEVELOPMENT_KEYRING","e","error","SubstrateContext","createContext","SubstrateContextProvider","props","initState","neededPropNames","forEach","key","children","propTypes","string","object","useSubstrate"],"mappings":"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","sourcesContent":["import React, { useReducer, useContext } from 'react';\nimport PropTypes from 'prop-types';\nimport jsonrpc from '@polkadot/types/interfaces/jsonrpc';\nimport queryString from 'query-string';\n\nimport { ApiPromise, WsProvider } from '@polkadot/api';\nimport { web3Accounts, web3Enable } from '@polkadot/extension-dapp';\nimport keyring from '@polkadot/ui-keyring';\n\nimport config from '../config';\n\nconst parsedQuery = queryString.parse(window.location.search);\nconst connectedSocket = parsedQuery.rpc || config.PROVIDER_SOCKET;\nconsole.log(`Connected socket: ${connectedSocket}`);\n\n///\n// Initial state for `useReducer`\n\nconst INIT_STATE = {\n  socket: connectedSocket,\n  jsonrpc: { ...jsonrpc, ...config.RPC },\n  types: config.types,\n  keyring: null,\n  keyringState: null,\n  api: null,\n  apiError: null,\n  apiState: null\n};\n\n///\n// Reducer function for `useReducer`\n\nconst reducer = (state, action) => {\n  switch (action.type) {\n    case 'CONNECT_INIT':\n      return { ...state, apiState: 'CONNECT_INIT' };\n\n    case 'CONNECT':\n      return { ...state, api: action.payload, apiState: 'CONNECTING' };\n\n    case 'CONNECT_SUCCESS':\n      return { ...state, apiState: 'READY' };\n\n    case 'CONNECT_ERROR':\n      return { ...state, apiState: 'ERROR', apiError: action.payload };\n\n    case 'LOAD_KEYRING':\n      return { ...state, keyringState: 'LOADING' };\n\n    case 'SET_KEYRING':\n      return { ...state, keyring: action.payload, keyringState: 'READY' };\n\n    case 'KEYRING_ERROR':\n      return { ...state, keyring: null, keyringState: 'ERROR' };\n\n    default:\n      throw new Error(`Unknown type: ${action.type}`);\n  }\n};\n\n///\n// Connecting to the Substrate node\n\nconst connect = (state, dispatch) => {\n  const { apiState, socket, jsonrpc, types } = state;\n  // We only want this function to be performed once\n  if (apiState) return;\n\n  dispatch({ type: 'CONNECT_INIT' });\n\n  const provider = new WsProvider(socket);\n  const _api = new ApiPromise({ provider, types, rpc: jsonrpc });\n\n  // Set listeners for disconnection and reconnection event.\n  _api.on('connected', () => {\n    dispatch({ type: 'CONNECT', payload: _api });\n    // `ready` event is not emitted upon reconnection and is checked explicitly here.\n    _api.isReady.then((_api) => dispatch({ type: 'CONNECT_SUCCESS' }));\n  });\n  _api.on('ready', () => dispatch({ type: 'CONNECT_SUCCESS' }));\n  _api.on('error', err => dispatch({ type: 'CONNECT_ERROR', payload: err }));\n};\n\n///\n// Loading accounts from dev and polkadot-js extension\n\nlet loadAccts = false;\nconst loadAccounts = (state, dispatch) => {\n  const asyncLoadAccounts = async () => {\n    dispatch({ type: 'LOAD_KEYRING' });\n    try {\n      await web3Enable(config.APP_NAME);\n      let allAccounts = await web3Accounts();\n      allAccounts = allAccounts.map(({ address, meta }) =>\n        ({ address, meta: { ...meta, name: `${meta.name} (${meta.source})` } }));\n      keyring.loadAll({ isDevelopment: config.DEVELOPMENT_KEYRING }, allAccounts);\n      dispatch({ type: 'SET_KEYRING', payload: keyring });\n    } catch (e) {\n      console.error(e);\n      dispatch({ type: 'KEYRING_ERROR' });\n    }\n  };\n\n  const { keyringState } = state;\n  // If `keyringState` is not null `asyncLoadAccounts` is running.\n  if (keyringState) return;\n  // If `loadAccts` is true, the `asyncLoadAccounts` has been run once.\n  if (loadAccts) return dispatch({ type: 'SET_KEYRING', payload: keyring });\n\n  // This is the heavy duty work\n  loadAccts = true;\n  asyncLoadAccounts();\n};\n\nconst SubstrateContext = React.createContext();\n\nconst SubstrateContextProvider = (props) => {\n  // filtering props and merge with default param value\n  const initState = { ...INIT_STATE };\n  const neededPropNames = ['socket', 'types'];\n  neededPropNames.forEach(key => {\n    initState[key] = (typeof props[key] === 'undefined' ? initState[key] : props[key]);\n  });\n\n  const [state, dispatch] = useReducer(reducer, initState);\n  connect(state, dispatch);\n  loadAccounts(state, dispatch);\n\n  return <SubstrateContext.Provider value={state}>\n    {props.children}\n  </SubstrateContext.Provider>;\n};\n\n// prop typechecking\nSubstrateContextProvider.propTypes = {\n  socket: PropTypes.string,\n  types: PropTypes.object\n};\n\nconst useSubstrate = () => ({ ...useContext(SubstrateContext) });\n\nexport { SubstrateContextProvider, useSubstrate };\n"]},"metadata":{},"sourceType":"module"}