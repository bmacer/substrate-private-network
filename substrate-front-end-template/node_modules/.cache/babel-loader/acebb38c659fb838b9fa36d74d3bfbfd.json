{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport BN from 'bn.js';\nimport { BN_BILLION, BN_ZERO, isFunction } from '@polkadot/util';\nimport { combineLatest, of } from '@polkadot/x-rxjs';\nimport { map, switchMap } from '@polkadot/x-rxjs/operators';\nimport { memo } from \"../util/index.mjs\";\nconst MIN_ONE = new BN(-1);\n\nfunction parseRewards(api, stashId, [, erasPoints, erasPrefs, erasRewards], exposures) {\n  return exposures.map(({\n    era,\n    isEmpty,\n    isValidator,\n    nominating,\n    validators: eraValidators\n  }) => {\n    const {\n      eraPoints,\n      validators: allValPoints\n    } = erasPoints.find(p => p.era.eq(era)) || {\n      eraPoints: BN_ZERO,\n      validators: {}\n    };\n    const {\n      eraReward\n    } = erasRewards.find(r => r.era.eq(era)) || {\n      eraReward: api.registry.createType('Balance')\n    };\n    const {\n      validators: allValPrefs\n    } = erasPrefs.find(p => p.era.eq(era)) || {\n      validators: {}\n    };\n    const validators = {};\n    const stakerId = stashId.toString();\n    Object.entries(eraValidators).forEach(([validatorId, exposure]) => {\n      var _allValPrefs$validato;\n\n      const valPoints = allValPoints[validatorId] || BN_ZERO;\n      const valComm = ((_allValPrefs$validato = allValPrefs[validatorId]) === null || _allValPrefs$validato === void 0 ? void 0 : _allValPrefs$validato.commission.unwrap()) || BN_ZERO;\n      const expTotal = exposure.total.unwrap();\n      let avail = BN_ZERO;\n      let value;\n\n      if (!(expTotal.isZero() || valPoints.isZero() || eraPoints.isZero())) {\n        avail = eraReward.mul(valPoints).div(eraPoints);\n        const valCut = valComm.mul(avail).div(BN_BILLION);\n        let staked;\n\n        if (validatorId === stakerId) {\n          staked = exposure.own.unwrap();\n        } else {\n          const stakerExp = exposure.others.find(({\n            who\n          }) => who.eq(stakerId));\n          staked = stakerExp ? stakerExp.value.unwrap() : BN_ZERO;\n        }\n\n        value = avail.sub(valCut).imul(staked).div(expTotal).iadd(validatorId === stakerId ? valCut : BN_ZERO);\n      }\n\n      validators[validatorId] = {\n        total: api.registry.createType('Balance', avail),\n        value: api.registry.createType('Balance', value)\n      };\n    });\n    return {\n      era,\n      eraReward,\n      isEmpty,\n      isValidator,\n      nominating,\n      validators\n    };\n  });\n}\n\nfunction uniqValidators(rewards) {\n  const uniq = [];\n  rewards.forEach(({\n    validators\n  }) => {\n    Object.keys(validators).forEach(validatorId => {\n      if (!uniq.includes(validatorId)) {\n        uniq.push(validatorId);\n      }\n    });\n  });\n  return uniq;\n}\n\nfunction isOldLedger(ledger) {\n  return !!(ledger !== null && ledger !== void 0 && ledger.lastReward);\n}\n\nfunction filterEra(era, stakingLedger) {\n  return isOldLedger(stakingLedger) ? era.gt(stakingLedger.lastReward.unwrapOr(MIN_ONE)) : !stakingLedger.claimedRewards.some(e => e.eq(era));\n}\n\nfunction filterEras(eras, stakingLedger) {\n  return eras.filter(era => filterEra(era, stakingLedger));\n}\n\nfunction removeClaimed(validators, queryValidators, reward) {\n  const rm = [];\n  Object.keys(reward.validators).forEach(validatorId => {\n    const index = validators.indexOf(validatorId);\n\n    if (index !== -1) {\n      const valLedger = queryValidators[index].stakingLedger;\n\n      if (valLedger !== null && valLedger !== void 0 && valLedger.claimedRewards.some(era => reward.era.eq(era))) {\n        rm.push(validatorId);\n      }\n    }\n  });\n  rm.forEach(validatorId => {\n    delete reward.validators[validatorId];\n  });\n}\n\nfunction filterRewards(api, eras, {\n  migrateEra,\n  rewards,\n  stakingLedger\n}) {\n  const validators = uniqValidators(rewards);\n  const filter = filterEras(eras, stakingLedger);\n  return api.derive.staking.queryMulti(validators, {\n    withLedger: true\n  }).pipe(map(queryValidators => rewards.filter(({\n    isEmpty\n  }) => !isEmpty).filter(reward => {\n    if (!filter.some(filter => reward.era.eq(filter))) {\n      return false;\n    } else if (reward.era.lt(migrateEra)) {\n      // we filter again here, the actual ledger may have changed, e.g. something has been claimed\n      return filterEra(reward.era, stakingLedger);\n    }\n\n    reward.isStakerPayout = true;\n    removeClaimed(validators, queryValidators, reward);\n    return true;\n  }).filter(({\n    validators\n  }) => Object.keys(validators).length !== 0).map(reward => _objectSpread(_objectSpread({}, reward), {}, {\n    nominators: reward.nominating.filter(n => reward.validators[n.validatorId])\n  }))));\n}\n\nexport function _stakerRewardsEras(instanceId, api) {\n  return memo(instanceId, (eras, withActive) => combineLatest([isFunction(api.query.staking.migrateEra) ? api.query.staking.migrateEra() : of(api.registry.createType('Option<EraIndex>')), api.derive.staking._erasPoints(eras, withActive), api.derive.staking._erasPrefs(eras, withActive), api.derive.staking._erasRewards(eras, withActive)]));\n}\nexport function _stakerRewards(instanceId, api) {\n  return memo(instanceId, (accountId, eras, withActive) => combineLatest([api.derive.staking.query(accountId, {\n    withLedger: true\n  }), api.derive.staking._stakerExposure(accountId, eras, withActive), api.derive.staking._stakerRewardsEras(eras, withActive)]).pipe(switchMap(([{\n    stakingLedger,\n    stashId\n  }, exposures, erasResult]) => {\n    if (!stashId || !stakingLedger) {\n      return of([]);\n    }\n\n    const rewards = parseRewards(api, stashId, erasResult, exposures);\n    return withActive ? of(rewards) : filterRewards(api, eras, {\n      migrateEra: erasResult[0].unwrapOr(BN_ZERO),\n      rewards,\n      stakingLedger\n    });\n  })));\n}\nexport function stakerRewards(instanceId, api) {\n  return memo(instanceId, (accountId, withActive = false) => api.derive.staking.erasHistoric(withActive).pipe(switchMap(eras => api.derive.staking._stakerRewards(accountId, eras, withActive))));\n}\nexport function stakerRewardsMultiEras(instanceId, api) {\n  return memo(instanceId, (accountIds, eras) => accountIds.length && eras.length ? combineLatest(accountIds.map(acc => api.derive.staking._stakerRewards(acc, eras, false))) : of([]));\n}\nexport function stakerRewardsMulti(instanceId, api) {\n  return memo(instanceId, (accountIds, withActive = false) => api.derive.staking.erasHistoric(withActive).pipe(switchMap(eras => api.derive.staking.stakerRewardsMultiEras(accountIds, eras))));\n}","map":{"version":3,"sources":["/Users/bmacer/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/api-derive/staking/stakerRewards.mjs"],"names":["_defineProperty","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","BN","BN_BILLION","BN_ZERO","isFunction","combineLatest","of","map","switchMap","memo","MIN_ONE","parseRewards","api","stashId","erasPoints","erasPrefs","erasRewards","exposures","era","isEmpty","isValidator","nominating","validators","eraValidators","eraPoints","allValPoints","find","p","eq","eraReward","r","registry","createType","allValPrefs","stakerId","toString","entries","validatorId","exposure","_allValPrefs$validato","valPoints","valComm","commission","unwrap","expTotal","total","avail","value","isZero","mul","div","valCut","staked","own","stakerExp","others","who","sub","imul","iadd","uniqValidators","rewards","uniq","includes","isOldLedger","ledger","lastReward","filterEra","stakingLedger","gt","unwrapOr","claimedRewards","some","e","filterEras","eras","removeClaimed","queryValidators","reward","rm","index","indexOf","valLedger","filterRewards","migrateEra","derive","staking","queryMulti","withLedger","pipe","lt","isStakerPayout","nominators","n","_stakerRewardsEras","instanceId","withActive","query","_erasPoints","_erasPrefs","_erasRewards","_stakerRewards","accountId","_stakerExposure","erasResult","stakerRewards","erasHistoric","stakerRewardsMultiEras","accountIds","acc","stakerRewardsMulti"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport BN from 'bn.js';\nimport { BN_BILLION, BN_ZERO, isFunction } from '@polkadot/util';\nimport { combineLatest, of } from '@polkadot/x-rxjs';\nimport { map, switchMap } from '@polkadot/x-rxjs/operators';\nimport { memo } from \"../util/index.mjs\";\nconst MIN_ONE = new BN(-1);\n\nfunction parseRewards(api, stashId, [, erasPoints, erasPrefs, erasRewards], exposures) {\n  return exposures.map(({\n    era,\n    isEmpty,\n    isValidator,\n    nominating,\n    validators: eraValidators\n  }) => {\n    const {\n      eraPoints,\n      validators: allValPoints\n    } = erasPoints.find(p => p.era.eq(era)) || {\n      eraPoints: BN_ZERO,\n      validators: {}\n    };\n    const {\n      eraReward\n    } = erasRewards.find(r => r.era.eq(era)) || {\n      eraReward: api.registry.createType('Balance')\n    };\n    const {\n      validators: allValPrefs\n    } = erasPrefs.find(p => p.era.eq(era)) || {\n      validators: {}\n    };\n    const validators = {};\n    const stakerId = stashId.toString();\n    Object.entries(eraValidators).forEach(([validatorId, exposure]) => {\n      var _allValPrefs$validato;\n\n      const valPoints = allValPoints[validatorId] || BN_ZERO;\n      const valComm = ((_allValPrefs$validato = allValPrefs[validatorId]) === null || _allValPrefs$validato === void 0 ? void 0 : _allValPrefs$validato.commission.unwrap()) || BN_ZERO;\n      const expTotal = exposure.total.unwrap();\n      let avail = BN_ZERO;\n      let value;\n\n      if (!(expTotal.isZero() || valPoints.isZero() || eraPoints.isZero())) {\n        avail = eraReward.mul(valPoints).div(eraPoints);\n        const valCut = valComm.mul(avail).div(BN_BILLION);\n        let staked;\n\n        if (validatorId === stakerId) {\n          staked = exposure.own.unwrap();\n        } else {\n          const stakerExp = exposure.others.find(({\n            who\n          }) => who.eq(stakerId));\n          staked = stakerExp ? stakerExp.value.unwrap() : BN_ZERO;\n        }\n\n        value = avail.sub(valCut).imul(staked).div(expTotal).iadd(validatorId === stakerId ? valCut : BN_ZERO);\n      }\n\n      validators[validatorId] = {\n        total: api.registry.createType('Balance', avail),\n        value: api.registry.createType('Balance', value)\n      };\n    });\n    return {\n      era,\n      eraReward,\n      isEmpty,\n      isValidator,\n      nominating,\n      validators\n    };\n  });\n}\n\nfunction uniqValidators(rewards) {\n  const uniq = [];\n  rewards.forEach(({\n    validators\n  }) => {\n    Object.keys(validators).forEach(validatorId => {\n      if (!uniq.includes(validatorId)) {\n        uniq.push(validatorId);\n      }\n    });\n  });\n  return uniq;\n}\n\nfunction isOldLedger(ledger) {\n  return !!(ledger !== null && ledger !== void 0 && ledger.lastReward);\n}\n\nfunction filterEra(era, stakingLedger) {\n  return isOldLedger(stakingLedger) ? era.gt(stakingLedger.lastReward.unwrapOr(MIN_ONE)) : !stakingLedger.claimedRewards.some(e => e.eq(era));\n}\n\nfunction filterEras(eras, stakingLedger) {\n  return eras.filter(era => filterEra(era, stakingLedger));\n}\n\nfunction removeClaimed(validators, queryValidators, reward) {\n  const rm = [];\n  Object.keys(reward.validators).forEach(validatorId => {\n    const index = validators.indexOf(validatorId);\n\n    if (index !== -1) {\n      const valLedger = queryValidators[index].stakingLedger;\n\n      if (valLedger !== null && valLedger !== void 0 && valLedger.claimedRewards.some(era => reward.era.eq(era))) {\n        rm.push(validatorId);\n      }\n    }\n  });\n  rm.forEach(validatorId => {\n    delete reward.validators[validatorId];\n  });\n}\n\nfunction filterRewards(api, eras, {\n  migrateEra,\n  rewards,\n  stakingLedger\n}) {\n  const validators = uniqValidators(rewards);\n  const filter = filterEras(eras, stakingLedger);\n  return api.derive.staking.queryMulti(validators, {\n    withLedger: true\n  }).pipe(map(queryValidators => rewards.filter(({\n    isEmpty\n  }) => !isEmpty).filter(reward => {\n    if (!filter.some(filter => reward.era.eq(filter))) {\n      return false;\n    } else if (reward.era.lt(migrateEra)) {\n      // we filter again here, the actual ledger may have changed, e.g. something has been claimed\n      return filterEra(reward.era, stakingLedger);\n    }\n\n    reward.isStakerPayout = true;\n    removeClaimed(validators, queryValidators, reward);\n    return true;\n  }).filter(({\n    validators\n  }) => Object.keys(validators).length !== 0).map(reward => _objectSpread(_objectSpread({}, reward), {}, {\n    nominators: reward.nominating.filter(n => reward.validators[n.validatorId])\n  }))));\n}\n\nexport function _stakerRewardsEras(instanceId, api) {\n  return memo(instanceId, (eras, withActive) => combineLatest([isFunction(api.query.staking.migrateEra) ? api.query.staking.migrateEra() : of(api.registry.createType('Option<EraIndex>')), api.derive.staking._erasPoints(eras, withActive), api.derive.staking._erasPrefs(eras, withActive), api.derive.staking._erasRewards(eras, withActive)]));\n}\nexport function _stakerRewards(instanceId, api) {\n  return memo(instanceId, (accountId, eras, withActive) => combineLatest([api.derive.staking.query(accountId, {\n    withLedger: true\n  }), api.derive.staking._stakerExposure(accountId, eras, withActive), api.derive.staking._stakerRewardsEras(eras, withActive)]).pipe(switchMap(([{\n    stakingLedger,\n    stashId\n  }, exposures, erasResult]) => {\n    if (!stashId || !stakingLedger) {\n      return of([]);\n    }\n\n    const rewards = parseRewards(api, stashId, erasResult, exposures);\n    return withActive ? of(rewards) : filterRewards(api, eras, {\n      migrateEra: erasResult[0].unwrapOr(BN_ZERO),\n      rewards,\n      stakingLedger\n    });\n  })));\n}\nexport function stakerRewards(instanceId, api) {\n  return memo(instanceId, (accountId, withActive = false) => api.derive.staking.erasHistoric(withActive).pipe(switchMap(eras => api.derive.staking._stakerRewards(accountId, eras, withActive))));\n}\nexport function stakerRewardsMultiEras(instanceId, api) {\n  return memo(instanceId, (accountIds, eras) => accountIds.length && eras.length ? combineLatest(accountIds.map(acc => api.derive.staking._stakerRewards(acc, eras, false))) : of([]));\n}\nexport function stakerRewardsMulti(instanceId, api) {\n  return memo(instanceId, (accountIds, withActive = false) => api.derive.staking.erasHistoric(withActive).pipe(switchMap(eras => api.derive.staking.stakerRewardsMultiEras(accountIds, eras))));\n}"]},"metadata":{},"sourceType":"module"}