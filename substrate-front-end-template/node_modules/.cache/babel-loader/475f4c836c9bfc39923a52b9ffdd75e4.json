{"ast":null,"code":"import _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\"; // Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\nimport { assert, hexToU8a, isHex, isNumber, isObject, isString, isU8a, isUndefined, stringCamelCase, stringUpperFirst, u8aConcat, u8aToHex } from '@polkadot/util';\nimport { Null } from \"../primitive/Null.mjs\";\nimport { Struct } from \"./Struct.mjs\";\nimport { mapToTypeMap } from \"./utils/index.mjs\"; // export interface, this is used in Enum.with, so required as public by TS\n\nfunction extractDef(registry, _def) {\n  if (!Array.isArray(_def)) {\n    const def = mapToTypeMap(registry, _def);\n    const isBasic = !Object.values(def).some(type => type !== Null);\n    return {\n      def,\n      isBasic\n    };\n  }\n\n  return {\n    def: _def.reduce((def, key) => {\n      def[key] = Null;\n      return def;\n    }, {}),\n    isBasic: true\n  };\n}\n\nfunction createFromValue(registry, def, index = 0, value) {\n  const Clazz = Object.values(def)[index];\n  assert(!isUndefined(Clazz), `Unable to create Enum via index ${index}, in ${Object.keys(def).join(', ')}`);\n  return {\n    index,\n    value: value instanceof Clazz ? value : new Clazz(registry, value)\n  };\n}\n\nfunction decodeFromJSON(registry, def, key, value) {\n  // JSON comes in the form of { \"<type (lowercased)>\": \"<value for type>\" }, here we\n  // additionally force to lower to ensure forward compat\n  const keys = Object.keys(def).map(k => k.toLowerCase());\n  const keyLower = key.toLowerCase();\n  const index = keys.indexOf(keyLower);\n  assert(index !== -1, `Cannot map Enum JSON, unable to find '${key}' in ${keys.join(', ')}`);\n\n  try {\n    return createFromValue(registry, def, index, value);\n  } catch (error) {\n    throw new Error(`Enum(${key}):: ${error.message}`);\n  }\n}\n\nfunction decodeFromString(registry, def, value) {\n  return isHex(value) // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  ? decodeFromValue(registry, def, hexToU8a(value)) : decodeFromJSON(registry, def, value);\n}\n\nfunction decodeFromValue(registry, def, value) {\n  if (isU8a(value)) {\n    return createFromValue(registry, def, value[0], value.subarray(1));\n  } else if (isNumber(value)) {\n    return createFromValue(registry, def, value);\n  } else if (isString(value)) {\n    return decodeFromString(registry, def, value.toString());\n  } else if (isObject(value)) {\n    const key = Object.keys(value)[0];\n    return decodeFromJSON(registry, def, key, value[key]);\n  } // Worst-case scenario, return the first with default\n\n\n  return createFromValue(registry, def, 0);\n}\n\nfunction decodeEnum(registry, def, value, index) {\n  // NOTE We check the index path first, before looking at values - this allows treating\n  // the optional indexes before anything else, more-specific > less-specific\n  if (isNumber(index)) {\n    return createFromValue(registry, def, index, value); // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  } else if (value instanceof Enum) {\n    return createFromValue(registry, def, value.index, value.value);\n  } // Or else, we just look at `value`\n\n\n  return decodeFromValue(registry, def, value);\n}\n/**\n * @name Enum\n * @description\n * This implements an enum, that based on the value wraps a different type. It is effectively\n * an extension to enum where the value type is determined by the actual index.\n */\n// TODO:\n//   - As per Enum, actually use TS enum\n//   - It should rather probably extend Enum instead of copying code\n\n\nvar _def2 = _classPrivateFieldLooseKey(\"def\");\n\nvar _index = _classPrivateFieldLooseKey(\"index\");\n\nvar _indexes = _classPrivateFieldLooseKey(\"indexes\");\n\nvar _isBasic = _classPrivateFieldLooseKey(\"isBasic\");\n\nvar _raw = _classPrivateFieldLooseKey(\"raw\");\n\nexport class Enum {\n  constructor(registry, def, value, index) {\n    this.registry = void 0;\n    Object.defineProperty(this, _def2, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _index, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _indexes, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _isBasic, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _raw, {\n      writable: true,\n      value: void 0\n    });\n    const defInfo = extractDef(registry, def);\n    const decoded = decodeEnum(registry, defInfo.def, value, index);\n    this.registry = registry;\n    _classPrivateFieldLooseBase(this, _def2)[_def2] = defInfo.def;\n    _classPrivateFieldLooseBase(this, _isBasic)[_isBasic] = defInfo.isBasic;\n    _classPrivateFieldLooseBase(this, _indexes)[_indexes] = Object.keys(defInfo.def).map((_, index) => index);\n    _classPrivateFieldLooseBase(this, _index)[_index] = _classPrivateFieldLooseBase(this, _indexes)[_indexes].indexOf(decoded.index) || 0;\n    _classPrivateFieldLooseBase(this, _raw)[_raw] = decoded.value;\n  }\n\n  static with(Types) {\n    return class extends Enum {\n      constructor(registry, value, index) {\n        super(registry, Types, value, index);\n        Object.keys(_classPrivateFieldLooseBase(this, _def2)[_def2]).forEach(_key => {\n          const name = stringUpperFirst(stringCamelCase(_key.replace(' ', '_')));\n          const askey = `as${name}`;\n          const iskey = `is${name}`;\n          isUndefined(this[iskey]) && Object.defineProperty(this, iskey, {\n            enumerable: true,\n            get: () => this.type === _key\n          });\n          isUndefined(this[askey]) && Object.defineProperty(this, askey, {\n            enumerable: true,\n            get: () => {\n              assert(this[iskey], `Cannot convert '${this.type}' via ${askey}`);\n              return this.value;\n            }\n          });\n        });\n      }\n\n    };\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return 1 + _classPrivateFieldLooseBase(this, _raw)[_raw].encodedLength;\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n\n\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description The index of the metadata value\n   */\n\n\n  get index() {\n    return _classPrivateFieldLooseBase(this, _index)[_index];\n  }\n  /**\n   * @description true if this is a basic enum (no values)\n   */\n\n\n  get isBasic() {\n    return _classPrivateFieldLooseBase(this, _isBasic)[_isBasic];\n  }\n  /**\n   * @description Checks if the value is an empty value\n   */\n\n\n  get isEmpty() {\n    return _classPrivateFieldLooseBase(this, _raw)[_raw].isEmpty;\n  }\n  /**\n   * @description Checks if the Enum points to a [[Null]] type\n   */\n\n\n  get isNone() {\n    return this.isNull;\n  }\n  /**\n   * @description Checks if the Enum points to a [[Null]] type (deprecated, use isNone)\n   */\n\n\n  get isNull() {\n    return _classPrivateFieldLooseBase(this, _raw)[_raw] instanceof Null;\n  }\n  /**\n   * @description The available keys for this enum\n   */\n\n\n  get defEntries() {\n    return Object.keys(_classPrivateFieldLooseBase(this, _def2)[_def2]);\n  }\n  /**\n   * @description The available keys for this enum\n   */\n\n\n  get defKeys() {\n    return Object.keys(_classPrivateFieldLooseBase(this, _def2)[_def2]);\n  }\n  /**\n   * @description The name of the type this enum value represents\n   */\n\n\n  get type() {\n    return this.defKeys[_classPrivateFieldLooseBase(this, _index)[_index]];\n  }\n  /**\n   * @description The value of the enum\n   */\n\n\n  get value() {\n    return _classPrivateFieldLooseBase(this, _raw)[_raw];\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n\n\n  eq(other) {\n    // cater for the case where we only pass the enum index\n    if (isNumber(other)) {\n      return this.toNumber() === other;\n    } else if (_classPrivateFieldLooseBase(this, _isBasic)[_isBasic] && isString(other)) {\n      return this.type === other;\n    } else if (isU8a(other)) {\n      return !this.toU8a().some((entry, index) => entry !== other[index]);\n    } else if (isHex(other)) {\n      return this.toHex() === other;\n    } else if (other instanceof Enum) {\n      return this.index === other.index && this.value.eq(other.value);\n    } else if (isObject(other)) {\n      return this.value.eq(other[this.type]);\n    } // compare the actual wrapper value\n\n\n    return this.value.eq(other);\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n\n\n  toHex() {\n    return u8aToHex(this.toU8a());\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman(isExtended) {\n    return _classPrivateFieldLooseBase(this, _isBasic)[_isBasic] ? this.type : {\n      [this.type]: _classPrivateFieldLooseBase(this, _raw)[_raw].toHuman(isExtended)\n    };\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n\n\n  toJSON() {\n    return _classPrivateFieldLooseBase(this, _isBasic)[_isBasic] ? this.type : {\n      [this.type]: _classPrivateFieldLooseBase(this, _raw)[_raw].toJSON()\n    };\n  }\n  /**\n   * @description Returns the number representation for the value\n   */\n\n\n  toNumber() {\n    return _classPrivateFieldLooseBase(this, _index)[_index];\n  }\n  /**\n   * @description Returns a raw struct representation of the enum types\n   */\n\n\n  _toRawStruct() {\n    return _classPrivateFieldLooseBase(this, _isBasic)[_isBasic] ? this.defKeys : Struct.typesToMap(this.registry, _classPrivateFieldLooseBase(this, _def2)[_def2]);\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return JSON.stringify({\n      _enum: this._toRawStruct()\n    });\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n\n\n  toString() {\n    return this.isNull ? this.type : JSON.stringify(this.toJSON());\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    return u8aConcat(new Uint8Array(isBare ? [] : [_classPrivateFieldLooseBase(this, _indexes)[_indexes][_classPrivateFieldLooseBase(this, _index)[_index]]]), _classPrivateFieldLooseBase(this, _raw)[_raw].toU8a(isBare));\n  }\n\n}","map":{"version":3,"sources":["/Users/bmacer/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/types/codec/Enum.mjs"],"names":["_classPrivateFieldLooseBase","_classPrivateFieldLooseKey","assert","hexToU8a","isHex","isNumber","isObject","isString","isU8a","isUndefined","stringCamelCase","stringUpperFirst","u8aConcat","u8aToHex","Null","Struct","mapToTypeMap","extractDef","registry","_def","Array","isArray","def","isBasic","Object","values","some","type","reduce","key","createFromValue","index","value","Clazz","keys","join","decodeFromJSON","map","k","toLowerCase","keyLower","indexOf","error","Error","message","decodeFromString","decodeFromValue","subarray","toString","decodeEnum","Enum","_def2","_index","_indexes","_isBasic","_raw","constructor","defineProperty","writable","defInfo","decoded","_","with","Types","forEach","_key","name","replace","askey","iskey","enumerable","get","encodedLength","hash","toU8a","isEmpty","isNone","isNull","defEntries","defKeys","eq","other","toNumber","entry","toHex","toHuman","isExtended","toJSON","_toRawStruct","typesToMap","toRawType","JSON","stringify","_enum","isBare","Uint8Array"],"mappings":"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","sourcesContent":["import _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, hexToU8a, isHex, isNumber, isObject, isString, isU8a, isUndefined, stringCamelCase, stringUpperFirst, u8aConcat, u8aToHex } from '@polkadot/util';\nimport { Null } from \"../primitive/Null.mjs\";\nimport { Struct } from \"./Struct.mjs\";\nimport { mapToTypeMap } from \"./utils/index.mjs\"; // export interface, this is used in Enum.with, so required as public by TS\n\nfunction extractDef(registry, _def) {\n  if (!Array.isArray(_def)) {\n    const def = mapToTypeMap(registry, _def);\n    const isBasic = !Object.values(def).some(type => type !== Null);\n    return {\n      def,\n      isBasic\n    };\n  }\n\n  return {\n    def: _def.reduce((def, key) => {\n      def[key] = Null;\n      return def;\n    }, {}),\n    isBasic: true\n  };\n}\n\nfunction createFromValue(registry, def, index = 0, value) {\n  const Clazz = Object.values(def)[index];\n  assert(!isUndefined(Clazz), `Unable to create Enum via index ${index}, in ${Object.keys(def).join(', ')}`);\n  return {\n    index,\n    value: value instanceof Clazz ? value : new Clazz(registry, value)\n  };\n}\n\nfunction decodeFromJSON(registry, def, key, value) {\n  // JSON comes in the form of { \"<type (lowercased)>\": \"<value for type>\" }, here we\n  // additionally force to lower to ensure forward compat\n  const keys = Object.keys(def).map(k => k.toLowerCase());\n  const keyLower = key.toLowerCase();\n  const index = keys.indexOf(keyLower);\n  assert(index !== -1, `Cannot map Enum JSON, unable to find '${key}' in ${keys.join(', ')}`);\n\n  try {\n    return createFromValue(registry, def, index, value);\n  } catch (error) {\n    throw new Error(`Enum(${key}):: ${error.message}`);\n  }\n}\n\nfunction decodeFromString(registry, def, value) {\n  return isHex(value) // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  ? decodeFromValue(registry, def, hexToU8a(value)) : decodeFromJSON(registry, def, value);\n}\n\nfunction decodeFromValue(registry, def, value) {\n  if (isU8a(value)) {\n    return createFromValue(registry, def, value[0], value.subarray(1));\n  } else if (isNumber(value)) {\n    return createFromValue(registry, def, value);\n  } else if (isString(value)) {\n    return decodeFromString(registry, def, value.toString());\n  } else if (isObject(value)) {\n    const key = Object.keys(value)[0];\n    return decodeFromJSON(registry, def, key, value[key]);\n  } // Worst-case scenario, return the first with default\n\n\n  return createFromValue(registry, def, 0);\n}\n\nfunction decodeEnum(registry, def, value, index) {\n  // NOTE We check the index path first, before looking at values - this allows treating\n  // the optional indexes before anything else, more-specific > less-specific\n  if (isNumber(index)) {\n    return createFromValue(registry, def, index, value); // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  } else if (value instanceof Enum) {\n    return createFromValue(registry, def, value.index, value.value);\n  } // Or else, we just look at `value`\n\n\n  return decodeFromValue(registry, def, value);\n}\n/**\n * @name Enum\n * @description\n * This implements an enum, that based on the value wraps a different type. It is effectively\n * an extension to enum where the value type is determined by the actual index.\n */\n// TODO:\n//   - As per Enum, actually use TS enum\n//   - It should rather probably extend Enum instead of copying code\n\n\nvar _def2 = _classPrivateFieldLooseKey(\"def\");\n\nvar _index = _classPrivateFieldLooseKey(\"index\");\n\nvar _indexes = _classPrivateFieldLooseKey(\"indexes\");\n\nvar _isBasic = _classPrivateFieldLooseKey(\"isBasic\");\n\nvar _raw = _classPrivateFieldLooseKey(\"raw\");\n\nexport class Enum {\n  constructor(registry, def, value, index) {\n    this.registry = void 0;\n    Object.defineProperty(this, _def2, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _index, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _indexes, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _isBasic, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _raw, {\n      writable: true,\n      value: void 0\n    });\n    const defInfo = extractDef(registry, def);\n    const decoded = decodeEnum(registry, defInfo.def, value, index);\n    this.registry = registry;\n    _classPrivateFieldLooseBase(this, _def2)[_def2] = defInfo.def;\n    _classPrivateFieldLooseBase(this, _isBasic)[_isBasic] = defInfo.isBasic;\n    _classPrivateFieldLooseBase(this, _indexes)[_indexes] = Object.keys(defInfo.def).map((_, index) => index);\n    _classPrivateFieldLooseBase(this, _index)[_index] = _classPrivateFieldLooseBase(this, _indexes)[_indexes].indexOf(decoded.index) || 0;\n    _classPrivateFieldLooseBase(this, _raw)[_raw] = decoded.value;\n  }\n\n  static with(Types) {\n    return class extends Enum {\n      constructor(registry, value, index) {\n        super(registry, Types, value, index);\n        Object.keys(_classPrivateFieldLooseBase(this, _def2)[_def2]).forEach(_key => {\n          const name = stringUpperFirst(stringCamelCase(_key.replace(' ', '_')));\n          const askey = `as${name}`;\n          const iskey = `is${name}`;\n          isUndefined(this[iskey]) && Object.defineProperty(this, iskey, {\n            enumerable: true,\n            get: () => this.type === _key\n          });\n          isUndefined(this[askey]) && Object.defineProperty(this, askey, {\n            enumerable: true,\n            get: () => {\n              assert(this[iskey], `Cannot convert '${this.type}' via ${askey}`);\n              return this.value;\n            }\n          });\n        });\n      }\n\n    };\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    return 1 + _classPrivateFieldLooseBase(this, _raw)[_raw].encodedLength;\n  }\n  /**\n   * @description returns a hash of the contents\n   */\n\n\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description The index of the metadata value\n   */\n\n\n  get index() {\n    return _classPrivateFieldLooseBase(this, _index)[_index];\n  }\n  /**\n   * @description true if this is a basic enum (no values)\n   */\n\n\n  get isBasic() {\n    return _classPrivateFieldLooseBase(this, _isBasic)[_isBasic];\n  }\n  /**\n   * @description Checks if the value is an empty value\n   */\n\n\n  get isEmpty() {\n    return _classPrivateFieldLooseBase(this, _raw)[_raw].isEmpty;\n  }\n  /**\n   * @description Checks if the Enum points to a [[Null]] type\n   */\n\n\n  get isNone() {\n    return this.isNull;\n  }\n  /**\n   * @description Checks if the Enum points to a [[Null]] type (deprecated, use isNone)\n   */\n\n\n  get isNull() {\n    return _classPrivateFieldLooseBase(this, _raw)[_raw] instanceof Null;\n  }\n  /**\n   * @description The available keys for this enum\n   */\n\n\n  get defEntries() {\n    return Object.keys(_classPrivateFieldLooseBase(this, _def2)[_def2]);\n  }\n  /**\n   * @description The available keys for this enum\n   */\n\n\n  get defKeys() {\n    return Object.keys(_classPrivateFieldLooseBase(this, _def2)[_def2]);\n  }\n  /**\n   * @description The name of the type this enum value represents\n   */\n\n\n  get type() {\n    return this.defKeys[_classPrivateFieldLooseBase(this, _index)[_index]];\n  }\n  /**\n   * @description The value of the enum\n   */\n\n\n  get value() {\n    return _classPrivateFieldLooseBase(this, _raw)[_raw];\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n\n\n  eq(other) {\n    // cater for the case where we only pass the enum index\n    if (isNumber(other)) {\n      return this.toNumber() === other;\n    } else if (_classPrivateFieldLooseBase(this, _isBasic)[_isBasic] && isString(other)) {\n      return this.type === other;\n    } else if (isU8a(other)) {\n      return !this.toU8a().some((entry, index) => entry !== other[index]);\n    } else if (isHex(other)) {\n      return this.toHex() === other;\n    } else if (other instanceof Enum) {\n      return this.index === other.index && this.value.eq(other.value);\n    } else if (isObject(other)) {\n      return this.value.eq(other[this.type]);\n    } // compare the actual wrapper value\n\n\n    return this.value.eq(other);\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n\n\n  toHex() {\n    return u8aToHex(this.toU8a());\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman(isExtended) {\n    return _classPrivateFieldLooseBase(this, _isBasic)[_isBasic] ? this.type : {\n      [this.type]: _classPrivateFieldLooseBase(this, _raw)[_raw].toHuman(isExtended)\n    };\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n\n\n  toJSON() {\n    return _classPrivateFieldLooseBase(this, _isBasic)[_isBasic] ? this.type : {\n      [this.type]: _classPrivateFieldLooseBase(this, _raw)[_raw].toJSON()\n    };\n  }\n  /**\n   * @description Returns the number representation for the value\n   */\n\n\n  toNumber() {\n    return _classPrivateFieldLooseBase(this, _index)[_index];\n  }\n  /**\n   * @description Returns a raw struct representation of the enum types\n   */\n\n\n  _toRawStruct() {\n    return _classPrivateFieldLooseBase(this, _isBasic)[_isBasic] ? this.defKeys : Struct.typesToMap(this.registry, _classPrivateFieldLooseBase(this, _def2)[_def2]);\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return JSON.stringify({\n      _enum: this._toRawStruct()\n    });\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n\n\n  toString() {\n    return this.isNull ? this.type : JSON.stringify(this.toJSON());\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    return u8aConcat(new Uint8Array(isBare ? [] : [_classPrivateFieldLooseBase(this, _indexes)[_indexes][_classPrivateFieldLooseBase(this, _index)[_index]]]), _classPrivateFieldLooseBase(this, _raw)[_raw].toU8a(isBare));\n  }\n\n}"]},"metadata":{},"sourceType":"module"}