{"ast":null,"code":"// Copyright 2017-2021 @polkadot/keyring authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, stringToU8a, u8aFixLength } from '@polkadot/util';\nimport { naclDecrypt, scryptEncode, scryptFromU8a } from '@polkadot/util-crypto';\nimport { ENCODING, NONCE_LENGTH, PKCS8_DIVIDER, PKCS8_HEADER, PUB_LENGTH, SCRYPT_LENGTH, SEC_LENGTH, SEED_LENGTH } from \"./defaults.mjs\";\nconst SEED_OFFSET = PKCS8_HEADER.length;\n\nfunction decodePkcs8(encoded) {\n  const header = encoded.subarray(0, PKCS8_HEADER.length);\n  assert(header.toString() === PKCS8_HEADER.toString(), 'Invalid Pkcs8 header found in body');\n  let secretKey = encoded.subarray(SEED_OFFSET, SEED_OFFSET + SEC_LENGTH);\n  let divOffset = SEED_OFFSET + SEC_LENGTH;\n  let divider = encoded.subarray(divOffset, divOffset + PKCS8_DIVIDER.length); // old-style, we have the seed here\n\n  if (divider.toString() !== PKCS8_DIVIDER.toString()) {\n    divOffset = SEED_OFFSET + SEED_LENGTH;\n    secretKey = encoded.subarray(SEED_OFFSET, divOffset);\n    divider = encoded.subarray(divOffset, divOffset + PKCS8_DIVIDER.length);\n  }\n\n  assert(divider.toString() === PKCS8_DIVIDER.toString(), 'Invalid Pkcs8 divider found in body');\n  const pubOffset = divOffset + PKCS8_DIVIDER.length;\n  const publicKey = encoded.subarray(pubOffset, pubOffset + PUB_LENGTH);\n  return {\n    publicKey,\n    secretKey\n  };\n}\n\nexport function decodePair(passphrase, encrypted, encType = ENCODING) {\n  assert(encrypted, 'No encrypted data available to decode');\n  assert(passphrase || !encType.includes('xsalsa20-poly1305'), 'Password required to decode encypted data');\n  let encoded = encrypted;\n\n  if (passphrase) {\n    let password;\n\n    if (encType.includes('scrypt')) {\n      const {\n        params,\n        salt\n      } = scryptFromU8a(encrypted);\n      password = scryptEncode(passphrase, salt, params).password;\n      encrypted = encrypted.subarray(SCRYPT_LENGTH);\n    } else {\n      password = stringToU8a(passphrase);\n    }\n\n    encoded = naclDecrypt(encrypted.subarray(NONCE_LENGTH), encrypted.subarray(0, NONCE_LENGTH), u8aFixLength(password, 256, true));\n  }\n\n  assert(encoded, 'Unable to decode using the supplied passphrase');\n  return decodePkcs8(encoded);\n}","map":{"version":3,"sources":["/Users/bmacer/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/keyring/pair/decode.mjs"],"names":["assert","stringToU8a","u8aFixLength","naclDecrypt","scryptEncode","scryptFromU8a","ENCODING","NONCE_LENGTH","PKCS8_DIVIDER","PKCS8_HEADER","PUB_LENGTH","SCRYPT_LENGTH","SEC_LENGTH","SEED_LENGTH","SEED_OFFSET","length","decodePkcs8","encoded","header","subarray","toString","secretKey","divOffset","divider","pubOffset","publicKey","decodePair","passphrase","encrypted","encType","includes","password","params","salt"],"mappings":"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","sourcesContent":["// Copyright 2017-2021 @polkadot/keyring authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, stringToU8a, u8aFixLength } from '@polkadot/util';\nimport { naclDecrypt, scryptEncode, scryptFromU8a } from '@polkadot/util-crypto';\nimport { ENCODING, NONCE_LENGTH, PKCS8_DIVIDER, PKCS8_HEADER, PUB_LENGTH, SCRYPT_LENGTH, SEC_LENGTH, SEED_LENGTH } from \"./defaults.mjs\";\nconst SEED_OFFSET = PKCS8_HEADER.length;\n\nfunction decodePkcs8(encoded) {\n  const header = encoded.subarray(0, PKCS8_HEADER.length);\n  assert(header.toString() === PKCS8_HEADER.toString(), 'Invalid Pkcs8 header found in body');\n  let secretKey = encoded.subarray(SEED_OFFSET, SEED_OFFSET + SEC_LENGTH);\n  let divOffset = SEED_OFFSET + SEC_LENGTH;\n  let divider = encoded.subarray(divOffset, divOffset + PKCS8_DIVIDER.length); // old-style, we have the seed here\n\n  if (divider.toString() !== PKCS8_DIVIDER.toString()) {\n    divOffset = SEED_OFFSET + SEED_LENGTH;\n    secretKey = encoded.subarray(SEED_OFFSET, divOffset);\n    divider = encoded.subarray(divOffset, divOffset + PKCS8_DIVIDER.length);\n  }\n\n  assert(divider.toString() === PKCS8_DIVIDER.toString(), 'Invalid Pkcs8 divider found in body');\n  const pubOffset = divOffset + PKCS8_DIVIDER.length;\n  const publicKey = encoded.subarray(pubOffset, pubOffset + PUB_LENGTH);\n  return {\n    publicKey,\n    secretKey\n  };\n}\n\nexport function decodePair(passphrase, encrypted, encType = ENCODING) {\n  assert(encrypted, 'No encrypted data available to decode');\n  assert(passphrase || !encType.includes('xsalsa20-poly1305'), 'Password required to decode encypted data');\n  let encoded = encrypted;\n\n  if (passphrase) {\n    let password;\n\n    if (encType.includes('scrypt')) {\n      const {\n        params,\n        salt\n      } = scryptFromU8a(encrypted);\n      password = scryptEncode(passphrase, salt, params).password;\n      encrypted = encrypted.subarray(SCRYPT_LENGTH);\n    } else {\n      password = stringToU8a(passphrase);\n    }\n\n    encoded = naclDecrypt(encrypted.subarray(NONCE_LENGTH), encrypted.subarray(0, NONCE_LENGTH), u8aFixLength(password, 256, true));\n  }\n\n  assert(encoded, 'Unable to decode using the supplied passphrase');\n  return decodePkcs8(encoded);\n}"]},"metadata":{},"sourceType":"module"}