{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/metadata authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { Raw } from '@polkadot/types/codec';\nimport { assert, compactAddLength, compactStripLength, isNull, isUndefined, stringLowerFirst, u8aConcat } from '@polkadot/util';\nimport { xxhashAsU8a } from '@polkadot/util-crypto';\nimport { getHasher } from \"./getHasher.mjs\";\nconst EMPTY_U8A = new Uint8Array([]);\n\nconst NULL_HASHER = value => value; // get the hashers, the base (and  in the case of DoubleMap), the second key\n\n/** @internal */\n\n\nfunction getHashers({\n  meta: {\n    type\n  }\n}) {\n  if (type.isDoubleMap) {\n    return [getHasher(type.asDoubleMap.hasher), getHasher(type.asDoubleMap.key2Hasher)];\n  } else if (type.isMap) {\n    return [getHasher(type.asMap.hasher)];\n  } // the default\n\n\n  return [getHasher()];\n} // create a base prefixed key\n\n/** @internal */\n\n\nfunction createPrefixedKey({\n  method,\n  prefix\n}) {\n  return u8aConcat(xxhashAsU8a(prefix, 128), xxhashAsU8a(method, 128));\n} // create a key for a DoubleMap type\n\n/** @internal */\n\n\nfunction createKeyDoubleMap(registry, itemFn, args, [hasher1, hasher2]) {\n  const {\n    meta: {\n      name,\n      type\n    }\n  } = itemFn; // since we are passing an almost-unknown through, trust, but verify\n\n  assert(Array.isArray(args) && !isUndefined(args[0]) && !isNull(args[0]) && !isUndefined(args[1]) && !isNull(args[1]), `${(name || 'unknown').toString()} is a DoubleMap and requires two arguments`); // if this fails, we have bigger issues\n\n  assert(!isUndefined(hasher2), '2 hashing functions should be defined for DoubleMaps');\n  const [key1, key2] = args;\n  const map = type.asDoubleMap;\n  const val1 = registry.createType(map.key1.toString(), key1).toU8a();\n  const val2 = registry.createType(map.key2.toString(), key2).toU8a(); // as per createKey, always add the length prefix (underlying it is Bytes)\n\n  return compactAddLength(u8aConcat(createPrefixedKey(itemFn), hasher1(val1), hasher2(val2)));\n} // create a key for either a map or a plain value\n\n/** @internal */\n\n\nfunction createKey(registry, itemFn, arg, hasher) {\n  const {\n    meta: {\n      name,\n      type\n    }\n  } = itemFn;\n  let param = EMPTY_U8A;\n\n  if (type.isMap) {\n    const map = type.asMap;\n    assert(!isUndefined(arg) && !isNull(arg), `${name.toString()} is a Map and requires one argument`);\n    param = registry.createType(map.key.toString(), arg).toU8a();\n  } // StorageKey is a Bytes, so is length-prefixed\n\n\n  return compactAddLength(u8aConcat(createPrefixedKey(itemFn), param.length ? hasher(param) : EMPTY_U8A));\n} // attach the metadata to expand to a StorageFunction\n\n/** @internal */\n\n\nfunction expandWithMeta({\n  meta,\n  method,\n  prefix,\n  section\n}, _storageFn) {\n  const storageFn = _storageFn;\n  storageFn.meta = meta;\n  storageFn.method = stringLowerFirst(method);\n  storageFn.prefix = prefix;\n  storageFn.section = section; // explicitly add the actual method in the toJSON, this gets used to determine caching and without it\n  // instances (e.g. collective) will not work since it is only matched on param meta\n\n  storageFn.toJSON = () => _objectSpread(_objectSpread({}, meta.toJSON()), {}, {\n    storage: {\n      method,\n      prefix,\n      section\n    }\n  });\n\n  return storageFn;\n}\n/** @internal */\n\n\nfunction extendHeadMeta(registry, {\n  meta: {\n    documentation,\n    name,\n    type\n  },\n  section\n}, {\n  method\n}, iterFn) {\n  const outputType = type.isMap ? type.asMap.key.toString() : type.asDoubleMap.key1.toString(); // metadata with a fallback value using the type of the key, the normal\n  // meta fallback only applies to actual entry values, create one for head\n\n  iterFn.meta = registry.createType('StorageEntryMetadataLatest', {\n    documentation,\n    fallback: registry.createType('Bytes', registry.createType(outputType).toHex()),\n    modifier: registry.createType('StorageEntryModifierLatest', 1),\n    // required\n    name,\n    type: registry.createType('StorageEntryTypeLatest', registry.createType('Type', type.isMap ? type.asMap.key : type.asDoubleMap.key1), 0)\n  });\n  const prefixKey = registry.createType('StorageKey', iterFn, {\n    method,\n    section\n  });\n  return arg => !isUndefined(arg) && !isNull(arg) ? registry.createType('StorageKey', iterFn(arg), {\n    method,\n    section\n  }) : prefixKey;\n} // attach the full list hashing for prefixed maps\n\n/** @internal */\n\n\nfunction extendPrefixedMap(registry, itemFn, storageFn) {\n  const {\n    meta: {\n      type\n    }\n  } = itemFn;\n  storageFn.iterKey = extendHeadMeta(registry, itemFn, storageFn, arg => {\n    assert(type.isDoubleMap || isUndefined(arg), 'Filtering arguments for keys/entries are only valid on double maps');\n    return new Raw(registry, type.isDoubleMap && !isUndefined(arg) && !isNull(arg) ? u8aConcat(createPrefixedKey(itemFn), getHasher(type.asDoubleMap.hasher)(registry.createType(type.asDoubleMap.key1.toString(), arg).toU8a())) : createPrefixedKey(itemFn));\n  });\n  return storageFn;\n}\n/** @internal */\n\n\nexport function createFunction(registry, itemFn, options) {\n  const {\n    meta: {\n      type\n    }\n  } = itemFn;\n  const [hasher, key2Hasher] = getHashers(itemFn); // Can only have zero or one argument:\n  //   - storage.system.account(address)\n  //   - storage.timestamp.blockPeriod()\n  // For doublemap queries the params is passed in as an tuple, [key1, key2]\n\n  const storageFn = expandWithMeta(itemFn, arg => type.isDoubleMap ? createKeyDoubleMap(registry, itemFn, arg, [hasher, key2Hasher]) : createKey(registry, itemFn, arg, options.skipHashing ? NULL_HASHER : hasher));\n\n  if (type.isMap || type.isDoubleMap) {\n    extendPrefixedMap(registry, itemFn, storageFn);\n  }\n\n  storageFn.keyPrefix = arg => storageFn.iterKey && storageFn.iterKey(arg) || compactStripLength(storageFn())[1];\n\n  return storageFn;\n}","map":{"version":3,"sources":["/Users/bmacer/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/metadata/decorate/storage/createFunction.mjs"],"names":["_defineProperty","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","Raw","assert","compactAddLength","compactStripLength","isNull","isUndefined","stringLowerFirst","u8aConcat","xxhashAsU8a","getHasher","EMPTY_U8A","Uint8Array","NULL_HASHER","value","getHashers","meta","type","isDoubleMap","asDoubleMap","hasher","key2Hasher","isMap","asMap","createPrefixedKey","method","prefix","createKeyDoubleMap","registry","itemFn","args","hasher1","hasher2","name","Array","isArray","toString","key1","key2","map","val1","createType","toU8a","val2","createKey","arg","param","expandWithMeta","section","_storageFn","storageFn","toJSON","storage","extendHeadMeta","documentation","iterFn","outputType","fallback","toHex","modifier","prefixKey","extendPrefixedMap","iterKey","createFunction","options","skipHashing","keyPrefix"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/metadata authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { Raw } from '@polkadot/types/codec';\nimport { assert, compactAddLength, compactStripLength, isNull, isUndefined, stringLowerFirst, u8aConcat } from '@polkadot/util';\nimport { xxhashAsU8a } from '@polkadot/util-crypto';\nimport { getHasher } from \"./getHasher.mjs\";\nconst EMPTY_U8A = new Uint8Array([]);\n\nconst NULL_HASHER = value => value; // get the hashers, the base (and  in the case of DoubleMap), the second key\n\n/** @internal */\n\n\nfunction getHashers({\n  meta: {\n    type\n  }\n}) {\n  if (type.isDoubleMap) {\n    return [getHasher(type.asDoubleMap.hasher), getHasher(type.asDoubleMap.key2Hasher)];\n  } else if (type.isMap) {\n    return [getHasher(type.asMap.hasher)];\n  } // the default\n\n\n  return [getHasher()];\n} // create a base prefixed key\n\n/** @internal */\n\n\nfunction createPrefixedKey({\n  method,\n  prefix\n}) {\n  return u8aConcat(xxhashAsU8a(prefix, 128), xxhashAsU8a(method, 128));\n} // create a key for a DoubleMap type\n\n/** @internal */\n\n\nfunction createKeyDoubleMap(registry, itemFn, args, [hasher1, hasher2]) {\n  const {\n    meta: {\n      name,\n      type\n    }\n  } = itemFn; // since we are passing an almost-unknown through, trust, but verify\n\n  assert(Array.isArray(args) && !isUndefined(args[0]) && !isNull(args[0]) && !isUndefined(args[1]) && !isNull(args[1]), `${(name || 'unknown').toString()} is a DoubleMap and requires two arguments`); // if this fails, we have bigger issues\n\n  assert(!isUndefined(hasher2), '2 hashing functions should be defined for DoubleMaps');\n  const [key1, key2] = args;\n  const map = type.asDoubleMap;\n  const val1 = registry.createType(map.key1.toString(), key1).toU8a();\n  const val2 = registry.createType(map.key2.toString(), key2).toU8a(); // as per createKey, always add the length prefix (underlying it is Bytes)\n\n  return compactAddLength(u8aConcat(createPrefixedKey(itemFn), hasher1(val1), hasher2(val2)));\n} // create a key for either a map or a plain value\n\n/** @internal */\n\n\nfunction createKey(registry, itemFn, arg, hasher) {\n  const {\n    meta: {\n      name,\n      type\n    }\n  } = itemFn;\n  let param = EMPTY_U8A;\n\n  if (type.isMap) {\n    const map = type.asMap;\n    assert(!isUndefined(arg) && !isNull(arg), `${name.toString()} is a Map and requires one argument`);\n    param = registry.createType(map.key.toString(), arg).toU8a();\n  } // StorageKey is a Bytes, so is length-prefixed\n\n\n  return compactAddLength(u8aConcat(createPrefixedKey(itemFn), param.length ? hasher(param) : EMPTY_U8A));\n} // attach the metadata to expand to a StorageFunction\n\n/** @internal */\n\n\nfunction expandWithMeta({\n  meta,\n  method,\n  prefix,\n  section\n}, _storageFn) {\n  const storageFn = _storageFn;\n  storageFn.meta = meta;\n  storageFn.method = stringLowerFirst(method);\n  storageFn.prefix = prefix;\n  storageFn.section = section; // explicitly add the actual method in the toJSON, this gets used to determine caching and without it\n  // instances (e.g. collective) will not work since it is only matched on param meta\n\n  storageFn.toJSON = () => _objectSpread(_objectSpread({}, meta.toJSON()), {}, {\n    storage: {\n      method,\n      prefix,\n      section\n    }\n  });\n\n  return storageFn;\n}\n/** @internal */\n\n\nfunction extendHeadMeta(registry, {\n  meta: {\n    documentation,\n    name,\n    type\n  },\n  section\n}, {\n  method\n}, iterFn) {\n  const outputType = type.isMap ? type.asMap.key.toString() : type.asDoubleMap.key1.toString(); // metadata with a fallback value using the type of the key, the normal\n  // meta fallback only applies to actual entry values, create one for head\n\n  iterFn.meta = registry.createType('StorageEntryMetadataLatest', {\n    documentation,\n    fallback: registry.createType('Bytes', registry.createType(outputType).toHex()),\n    modifier: registry.createType('StorageEntryModifierLatest', 1),\n    // required\n    name,\n    type: registry.createType('StorageEntryTypeLatest', registry.createType('Type', type.isMap ? type.asMap.key : type.asDoubleMap.key1), 0)\n  });\n  const prefixKey = registry.createType('StorageKey', iterFn, {\n    method,\n    section\n  });\n  return arg => !isUndefined(arg) && !isNull(arg) ? registry.createType('StorageKey', iterFn(arg), {\n    method,\n    section\n  }) : prefixKey;\n} // attach the full list hashing for prefixed maps\n\n/** @internal */\n\n\nfunction extendPrefixedMap(registry, itemFn, storageFn) {\n  const {\n    meta: {\n      type\n    }\n  } = itemFn;\n  storageFn.iterKey = extendHeadMeta(registry, itemFn, storageFn, arg => {\n    assert(type.isDoubleMap || isUndefined(arg), 'Filtering arguments for keys/entries are only valid on double maps');\n    return new Raw(registry, type.isDoubleMap && !isUndefined(arg) && !isNull(arg) ? u8aConcat(createPrefixedKey(itemFn), getHasher(type.asDoubleMap.hasher)(registry.createType(type.asDoubleMap.key1.toString(), arg).toU8a())) : createPrefixedKey(itemFn));\n  });\n  return storageFn;\n}\n/** @internal */\n\n\nexport function createFunction(registry, itemFn, options) {\n  const {\n    meta: {\n      type\n    }\n  } = itemFn;\n  const [hasher, key2Hasher] = getHashers(itemFn); // Can only have zero or one argument:\n  //   - storage.system.account(address)\n  //   - storage.timestamp.blockPeriod()\n  // For doublemap queries the params is passed in as an tuple, [key1, key2]\n\n  const storageFn = expandWithMeta(itemFn, arg => type.isDoubleMap ? createKeyDoubleMap(registry, itemFn, arg, [hasher, key2Hasher]) : createKey(registry, itemFn, arg, options.skipHashing ? NULL_HASHER : hasher));\n\n  if (type.isMap || type.isDoubleMap) {\n    extendPrefixedMap(registry, itemFn, storageFn);\n  }\n\n  storageFn.keyPrefix = arg => storageFn.iterKey && storageFn.iterKey(arg) || compactStripLength(storageFn())[1];\n\n  return storageFn;\n}"]},"metadata":{},"sourceType":"module"}