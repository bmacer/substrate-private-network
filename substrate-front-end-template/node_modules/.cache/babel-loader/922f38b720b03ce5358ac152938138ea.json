{"ast":null,"code":"// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { isString, u8aToU8a } from '@polkadot/util';\nimport { Raw } from \"./Raw.mjs\";\n/** @internal */\n\nfunction decodeU8aFixed(value, bitLength) {\n  if (Array.isArray(value) || isString(value)) {\n    return decodeU8aFixed(u8aToU8a(value), bitLength);\n  } // ensure that we have an actual u8a with the full length as specified by\n  // the bitLength input (padded with zeros as required)\n\n\n  const byteLength = bitLength / 8;\n  const sub = value.subarray(0, byteLength);\n\n  if (sub.length === byteLength) {\n    return sub;\n  }\n\n  const u8a = new Uint8Array(byteLength);\n  u8a.set(sub, 0);\n  return u8a;\n}\n/**\n * @name U8aFixed\n * @description\n * A U8a that manages a a sequence of bytes up to the specified bitLength. Not meant\n * to be used directly, rather is should be subclassed with the specific lengths.\n */\n\n\nexport class U8aFixed extends Raw {\n  constructor(registry, value = new Uint8Array(), bitLength = 256) {\n    super(registry, decodeU8aFixed(value, bitLength));\n  }\n\n  static with(bitLength, typeName) {\n    return class extends U8aFixed {\n      constructor(registry, value) {\n        super(registry, value, bitLength);\n      }\n\n      toRawType() {\n        return typeName || super.toRawType();\n      }\n\n    };\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return `[u8;${this.length}]`;\n  }\n\n}","map":{"version":3,"sources":["/Users/bmacer/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/types/codec/U8aFixed.mjs"],"names":["isString","u8aToU8a","Raw","decodeU8aFixed","value","bitLength","Array","isArray","byteLength","sub","subarray","length","u8a","Uint8Array","set","U8aFixed","constructor","registry","with","typeName","toRawType"],"mappings":"AAAA;AACA;AACA,SAASA,QAAT,EAAmBC,QAAnB,QAAmC,gBAAnC;AACA,SAASC,GAAT,QAAoB,WAApB;AACA;;AAEA,SAASC,cAAT,CAAwBC,KAAxB,EAA+BC,SAA/B,EAA0C;AACxC,MAAIC,KAAK,CAACC,OAAN,CAAcH,KAAd,KAAwBJ,QAAQ,CAACI,KAAD,CAApC,EAA6C;AAC3C,WAAOD,cAAc,CAACF,QAAQ,CAACG,KAAD,CAAT,EAAkBC,SAAlB,CAArB;AACD,GAHuC,CAGtC;AACF;;;AAGA,QAAMG,UAAU,GAAGH,SAAS,GAAG,CAA/B;AACA,QAAMI,GAAG,GAAGL,KAAK,CAACM,QAAN,CAAe,CAAf,EAAkBF,UAAlB,CAAZ;;AAEA,MAAIC,GAAG,CAACE,MAAJ,KAAeH,UAAnB,EAA+B;AAC7B,WAAOC,GAAP;AACD;;AAED,QAAMG,GAAG,GAAG,IAAIC,UAAJ,CAAeL,UAAf,CAAZ;AACAI,EAAAA,GAAG,CAACE,GAAJ,CAAQL,GAAR,EAAa,CAAb;AACA,SAAOG,GAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;;AAGA,OAAO,MAAMG,QAAN,SAAuBb,GAAvB,CAA2B;AAChCc,EAAAA,WAAW,CAACC,QAAD,EAAWb,KAAK,GAAG,IAAIS,UAAJ,EAAnB,EAAqCR,SAAS,GAAG,GAAjD,EAAsD;AAC/D,UAAMY,QAAN,EAAgBd,cAAc,CAACC,KAAD,EAAQC,SAAR,CAA9B;AACD;;AAEU,SAAJa,IAAI,CAACb,SAAD,EAAYc,QAAZ,EAAsB;AAC/B,WAAO,cAAcJ,QAAd,CAAuB;AAC5BC,MAAAA,WAAW,CAACC,QAAD,EAAWb,KAAX,EAAkB;AAC3B,cAAMa,QAAN,EAAgBb,KAAhB,EAAuBC,SAAvB;AACD;;AAEDe,MAAAA,SAAS,GAAG;AACV,eAAOD,QAAQ,IAAI,MAAMC,SAAN,EAAnB;AACD;;AAP2B,KAA9B;AAUD;AACD;AACF;AACA;;;AAGEA,EAAAA,SAAS,GAAG;AACV,WAAQ,OAAM,KAAKT,MAAO,GAA1B;AACD;;AAxB+B","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { isString, u8aToU8a } from '@polkadot/util';\nimport { Raw } from \"./Raw.mjs\";\n/** @internal */\n\nfunction decodeU8aFixed(value, bitLength) {\n  if (Array.isArray(value) || isString(value)) {\n    return decodeU8aFixed(u8aToU8a(value), bitLength);\n  } // ensure that we have an actual u8a with the full length as specified by\n  // the bitLength input (padded with zeros as required)\n\n\n  const byteLength = bitLength / 8;\n  const sub = value.subarray(0, byteLength);\n\n  if (sub.length === byteLength) {\n    return sub;\n  }\n\n  const u8a = new Uint8Array(byteLength);\n  u8a.set(sub, 0);\n  return u8a;\n}\n/**\n * @name U8aFixed\n * @description\n * A U8a that manages a a sequence of bytes up to the specified bitLength. Not meant\n * to be used directly, rather is should be subclassed with the specific lengths.\n */\n\n\nexport class U8aFixed extends Raw {\n  constructor(registry, value = new Uint8Array(), bitLength = 256) {\n    super(registry, decodeU8aFixed(value, bitLength));\n  }\n\n  static with(bitLength, typeName) {\n    return class extends U8aFixed {\n      constructor(registry, value) {\n        super(registry, value, bitLength);\n      }\n\n      toRawType() {\n        return typeName || super.toRawType();\n      }\n\n    };\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return `[u8;${this.length}]`;\n  }\n\n}"]},"metadata":{},"sourceType":"module"}