{"ast":null,"code":"// Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { of } from '@polkadot/x-rxjs';\nimport { map } from '@polkadot/x-rxjs/operators';\nimport { memo } from \"../util/index.mjs\"; // parse into Indexes\n\nfunction parse([activeEra, activeEraStart, currentEra, currentIndex, validatorCount]) {\n  return {\n    activeEra,\n    activeEraStart,\n    currentEra,\n    currentIndex,\n    validatorCount\n  };\n} // query based on latest\n\n\nfunction query(api) {\n  return api.queryMulti([api.query.staking.activeEra, api.query.staking.currentEra, api.query.session.currentIndex, api.query.staking.validatorCount]).pipe(map(([activeOpt, currentEra, currentIndex, validatorCount]) => {\n    const {\n      index,\n      start\n    } = activeOpt.unwrapOrDefault();\n    return parse([index, start, currentEra.unwrapOrDefault(), currentIndex, validatorCount]);\n  }));\n} // empty set when none is available\n\n\nfunction empty(api) {\n  return of(parse([api.registry.createType('EraIndex'), api.registry.createType('Option<Moment>'), api.registry.createType('EraIndex'), api.registry.createType('SessionIndex', 1), api.registry.createType('u32')]));\n}\n\nexport function indexes(instanceId, api) {\n  return memo(instanceId, () => api.query.session && api.query.staking ? query(api) : empty(api));\n}","map":{"version":3,"sources":["/Users/bmacer/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/api-derive/session/indexes.mjs"],"names":["of","map","memo","parse","activeEra","activeEraStart","currentEra","currentIndex","validatorCount","query","api","queryMulti","staking","session","pipe","activeOpt","index","start","unwrapOrDefault","empty","registry","createType","indexes","instanceId"],"mappings":"AAAA;AACA;AACA,SAASA,EAAT,QAAmB,kBAAnB;AACA,SAASC,GAAT,QAAoB,4BAApB;AACA,SAASC,IAAT,QAAqB,mBAArB,C,CAA0C;;AAE1C,SAASC,KAAT,CAAe,CAACC,SAAD,EAAYC,cAAZ,EAA4BC,UAA5B,EAAwCC,YAAxC,EAAsDC,cAAtD,CAAf,EAAsF;AACpF,SAAO;AACLJ,IAAAA,SADK;AAELC,IAAAA,cAFK;AAGLC,IAAAA,UAHK;AAILC,IAAAA,YAJK;AAKLC,IAAAA;AALK,GAAP;AAOD,C,CAAC;;;AAGF,SAASC,KAAT,CAAeC,GAAf,EAAoB;AAClB,SAAOA,GAAG,CAACC,UAAJ,CAAe,CAACD,GAAG,CAACD,KAAJ,CAAUG,OAAV,CAAkBR,SAAnB,EAA8BM,GAAG,CAACD,KAAJ,CAAUG,OAAV,CAAkBN,UAAhD,EAA4DI,GAAG,CAACD,KAAJ,CAAUI,OAAV,CAAkBN,YAA9E,EAA4FG,GAAG,CAACD,KAAJ,CAAUG,OAAV,CAAkBJ,cAA9G,CAAf,EAA8IM,IAA9I,CAAmJb,GAAG,CAAC,CAAC,CAACc,SAAD,EAAYT,UAAZ,EAAwBC,YAAxB,EAAsCC,cAAtC,CAAD,KAA2D;AACvN,UAAM;AACJQ,MAAAA,KADI;AAEJC,MAAAA;AAFI,QAGFF,SAAS,CAACG,eAAV,EAHJ;AAIA,WAAOf,KAAK,CAAC,CAACa,KAAD,EAAQC,KAAR,EAAeX,UAAU,CAACY,eAAX,EAAf,EAA6CX,YAA7C,EAA2DC,cAA3D,CAAD,CAAZ;AACD,GAN4J,CAAtJ,CAAP;AAOD,C,CAAC;;;AAGF,SAASW,KAAT,CAAeT,GAAf,EAAoB;AAClB,SAAOV,EAAE,CAACG,KAAK,CAAC,CAACO,GAAG,CAACU,QAAJ,CAAaC,UAAb,CAAwB,UAAxB,CAAD,EAAsCX,GAAG,CAACU,QAAJ,CAAaC,UAAb,CAAwB,gBAAxB,CAAtC,EAAiFX,GAAG,CAACU,QAAJ,CAAaC,UAAb,CAAwB,UAAxB,CAAjF,EAAsHX,GAAG,CAACU,QAAJ,CAAaC,UAAb,CAAwB,cAAxB,EAAwC,CAAxC,CAAtH,EAAkKX,GAAG,CAACU,QAAJ,CAAaC,UAAb,CAAwB,KAAxB,CAAlK,CAAD,CAAN,CAAT;AACD;;AAED,OAAO,SAASC,OAAT,CAAiBC,UAAjB,EAA6Bb,GAA7B,EAAkC;AACvC,SAAOR,IAAI,CAACqB,UAAD,EAAa,MAAMb,GAAG,CAACD,KAAJ,CAAUI,OAAV,IAAqBH,GAAG,CAACD,KAAJ,CAAUG,OAA/B,GAAyCH,KAAK,CAACC,GAAD,CAA9C,GAAsDS,KAAK,CAACT,GAAD,CAA9E,CAAX;AACD","sourcesContent":["// Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { of } from '@polkadot/x-rxjs';\nimport { map } from '@polkadot/x-rxjs/operators';\nimport { memo } from \"../util/index.mjs\"; // parse into Indexes\n\nfunction parse([activeEra, activeEraStart, currentEra, currentIndex, validatorCount]) {\n  return {\n    activeEra,\n    activeEraStart,\n    currentEra,\n    currentIndex,\n    validatorCount\n  };\n} // query based on latest\n\n\nfunction query(api) {\n  return api.queryMulti([api.query.staking.activeEra, api.query.staking.currentEra, api.query.session.currentIndex, api.query.staking.validatorCount]).pipe(map(([activeOpt, currentEra, currentIndex, validatorCount]) => {\n    const {\n      index,\n      start\n    } = activeOpt.unwrapOrDefault();\n    return parse([index, start, currentEra.unwrapOrDefault(), currentIndex, validatorCount]);\n  }));\n} // empty set when none is available\n\n\nfunction empty(api) {\n  return of(parse([api.registry.createType('EraIndex'), api.registry.createType('Option<Moment>'), api.registry.createType('EraIndex'), api.registry.createType('SessionIndex', 1), api.registry.createType('u32')]));\n}\n\nexport function indexes(instanceId, api) {\n  return memo(instanceId, () => api.query.session && api.query.staking ? query(api) : empty(api));\n}"]},"metadata":{},"sourceType":"module"}