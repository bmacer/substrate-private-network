{"ast":null,"code":"// Copyright 2017-2021 @polkadot/metadata authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n// we are attempting to avoid circular refs, hence the path import\nimport { getTypeDef } from '@polkadot/types/create/getTypeDef';\nimport { TypeDefInfo } from '@polkadot/types/types';\n/** @internal */\n\nexport function extractTypes(types) {\n  return types.map(type => {\n    const decoded = getTypeDef(type);\n\n    switch (decoded.info) {\n      case TypeDefInfo.Plain:\n        return decoded.type;\n\n      case TypeDefInfo.BTreeSet:\n      case TypeDefInfo.Compact:\n      case TypeDefInfo.Option:\n      case TypeDefInfo.Vec:\n      case TypeDefInfo.VecFixed:\n        return extractTypes([decoded.sub.type]);\n\n      case TypeDefInfo.BTreeMap:\n      case TypeDefInfo.HashMap:\n      case TypeDefInfo.Result:\n      case TypeDefInfo.Tuple:\n        return extractTypes(decoded.sub.map(({\n          type\n        }) => type));\n\n      default:\n        throw new Error(`Unhandled: Unable to create and validate type from ${type}`);\n    }\n  });\n}","map":{"version":3,"sources":["/Users/bmacer/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/metadata/util/extractTypes.mjs"],"names":["getTypeDef","TypeDefInfo","extractTypes","types","map","type","decoded","info","Plain","BTreeSet","Compact","Option","Vec","VecFixed","sub","BTreeMap","HashMap","Result","Tuple","Error"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,UAAT,QAA2B,mCAA3B;AACA,SAASC,WAAT,QAA4B,uBAA5B;AAEA;;AACA,OAAO,SAASC,YAAT,CAAsBC,KAAtB,EAA6B;AAClC,SAAOA,KAAK,CAACC,GAAN,CAAUC,IAAI,IAAI;AACvB,UAAMC,OAAO,GAAGN,UAAU,CAACK,IAAD,CAA1B;;AAEA,YAAQC,OAAO,CAACC,IAAhB;AACE,WAAKN,WAAW,CAACO,KAAjB;AACE,eAAOF,OAAO,CAACD,IAAf;;AAEF,WAAKJ,WAAW,CAACQ,QAAjB;AACA,WAAKR,WAAW,CAACS,OAAjB;AACA,WAAKT,WAAW,CAACU,MAAjB;AACA,WAAKV,WAAW,CAACW,GAAjB;AACA,WAAKX,WAAW,CAACY,QAAjB;AACE,eAAOX,YAAY,CAAC,CAACI,OAAO,CAACQ,GAAR,CAAYT,IAAb,CAAD,CAAnB;;AAEF,WAAKJ,WAAW,CAACc,QAAjB;AACA,WAAKd,WAAW,CAACe,OAAjB;AACA,WAAKf,WAAW,CAACgB,MAAjB;AACA,WAAKhB,WAAW,CAACiB,KAAjB;AACE,eAAOhB,YAAY,CAACI,OAAO,CAACQ,GAAR,CAAYV,GAAZ,CAAgB,CAAC;AACnCC,UAAAA;AADmC,SAAD,KAE9BA,IAFc,CAAD,CAAnB;;AAIF;AACE,cAAM,IAAIc,KAAJ,CAAW,sDAAqDd,IAAK,EAArE,CAAN;AApBJ;AAsBD,GAzBM,CAAP;AA0BD","sourcesContent":["// Copyright 2017-2021 @polkadot/metadata authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n// we are attempting to avoid circular refs, hence the path import\nimport { getTypeDef } from '@polkadot/types/create/getTypeDef';\nimport { TypeDefInfo } from '@polkadot/types/types';\n\n/** @internal */\nexport function extractTypes(types) {\n  return types.map(type => {\n    const decoded = getTypeDef(type);\n\n    switch (decoded.info) {\n      case TypeDefInfo.Plain:\n        return decoded.type;\n\n      case TypeDefInfo.BTreeSet:\n      case TypeDefInfo.Compact:\n      case TypeDefInfo.Option:\n      case TypeDefInfo.Vec:\n      case TypeDefInfo.VecFixed:\n        return extractTypes([decoded.sub.type]);\n\n      case TypeDefInfo.BTreeMap:\n      case TypeDefInfo.HashMap:\n      case TypeDefInfo.Result:\n      case TypeDefInfo.Tuple:\n        return extractTypes(decoded.sub.map(({\n          type\n        }) => type));\n\n      default:\n        throw new Error(`Unhandled: Unable to create and validate type from ${type}`);\n    }\n  });\n}"]},"metadata":{},"sourceType":"module"}