{"ast":null,"code":"import _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\"; // Copyright 2017-2021 @polkadot/keyring authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\nimport { assert, hexToU8a, isHex, isUndefined, stringToU8a } from '@polkadot/util';\nimport { base64Decode, decodeAddress, encodeAddress, keyExtractSuri, keyFromPath, mnemonicToLegacySeed, mnemonicToMiniSecret, naclKeypairFromSeed as naclFromSeed, schnorrkelKeypairFromSeed as schnorrkelFromSeed, secp256k1KeypairFromSeed as secp256k1FromSeed } from '@polkadot/util-crypto';\nimport { DEV_PHRASE } from \"./defaults.mjs\";\nimport { createPair } from \"./pair/index.mjs\";\nimport { Pairs } from \"./pairs.mjs\";\nconst keypairFromSeed = {\n  ecdsa: seed => secp256k1FromSeed(seed),\n  ed25519: seed => naclFromSeed(seed),\n  ethereum: seed => secp256k1FromSeed(seed),\n  sr25519: seed => schnorrkelFromSeed(seed)\n};\n/**\n * # @polkadot/keyring\n *\n * ## Overview\n *\n * @name Keyring\n * @summary Keyring management of user accounts\n * @description Allows generation of keyring pairs from a variety of input combinations, such as\n * json object containing account address or public key, account metadata, and account encoded using\n * `addFromJson`, or by providing those values as arguments separately to `addFromAddress`,\n * or by providing the mnemonic (seed phrase) and account metadata as arguments to `addFromMnemonic`.\n * Stores the keyring pairs in a keyring pair dictionary. Removal of the keyring pairs from the keyring pair\n * dictionary is achieved using `removePair`. Retrieval of all the stored pairs via `getPairs` or perform\n * lookup of a pair for a given account address or public key using `getPair`. JSON metadata associated with\n * an account may be obtained using `toJson` accompanied by the account passphrase.\n */\n\nvar _pairs = _classPrivateFieldLooseKey(\"pairs\");\n\nvar _type = _classPrivateFieldLooseKey(\"type\");\n\nvar _ss = _classPrivateFieldLooseKey(\"ss58\");\n\nexport class Keyring {\n  constructor(options = {}) {\n    Object.defineProperty(this, _pairs, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _type, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _ss, {\n      writable: true,\n      value: void 0\n    });\n    this.decodeAddress = decodeAddress;\n\n    this.encodeAddress = (address, ss58Format) => {\n      return encodeAddress(address, isUndefined(ss58Format) ? _classPrivateFieldLooseBase(this, _ss)[_ss] : ss58Format);\n    };\n\n    options.type = options.type || 'ed25519';\n    assert(options && ['ecdsa', 'ethereum', 'ed25519', 'sr25519'].includes(options.type || 'undefined'), `Expected a keyring type of either 'ed25519', 'sr25519' or 'ecdsa', found '${options.type}`);\n    _classPrivateFieldLooseBase(this, _pairs)[_pairs] = new Pairs();\n    _classPrivateFieldLooseBase(this, _ss)[_ss] = options.ss58Format;\n    _classPrivateFieldLooseBase(this, _type)[_type] = options.type;\n  }\n  /**\n   * @description retrieve the pairs (alias for getPairs)\n   */\n\n\n  get pairs() {\n    return this.getPairs();\n  }\n  /**\n   * @description retrieve the publicKeys (alias for getPublicKeys)\n   */\n\n\n  get publicKeys() {\n    return this.getPublicKeys();\n  }\n  /**\n   * @description Returns the type of the keyring, ed25519, sr25519 or ecdsa\n   */\n\n\n  get type() {\n    return _classPrivateFieldLooseBase(this, _type)[_type];\n  }\n  /**\n   * @name addPair\n   * @summary Stores an account, given a keyring pair, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   */\n\n\n  addPair(pair) {\n    return _classPrivateFieldLooseBase(this, _pairs)[_pairs].add(pair);\n  }\n  /**\n   * @name addFromAddress\n   * @summary Stores an account, given an account address, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   * @description Allows user to explicitely provide separate inputs including account address or public key, and optionally\n   * the associated account metadata, and the default encoded value as arguments (that may be obtained from the json file\n   * of an account backup), and then generates a keyring pair from them that it passes to\n   * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n   */\n\n\n  addFromAddress(address, meta = {}, encoded = null, type = this.type, ignoreChecksum, encType) {\n    const publicKey = this.decodeAddress(address, ignoreChecksum);\n    return this.addPair(createPair({\n      toSS58: this.encodeAddress,\n      type\n    }, {\n      publicKey,\n      secretKey: new Uint8Array()\n    }, meta, encoded, encType));\n  }\n  /**\n   * @name addFromJson\n   * @summary Stores an account, given JSON data, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   * @description Allows user to provide a json object argument that contains account information (that may be obtained from the json file\n   * of an account backup), and then generates a keyring pair from it that it passes to\n   * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n   */\n\n\n  addFromJson(json, ignoreChecksum) {\n    return this.addPair(this.createFromJson(json, ignoreChecksum));\n  }\n  /**\n   * @name addFromMnemonic\n   * @summary Stores an account, given a mnemonic, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   * @description Allows user to provide a mnemonic (seed phrase that is provided when account is originally created)\n   * argument and a metadata argument that contains account information (that may be obtained from the json file\n   * of an account backup), and then generates a keyring pair from it that it passes to\n   * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n   */\n\n\n  addFromMnemonic(mnemonic, meta = {}, type = this.type) {\n    return this.addFromUri(mnemonic, meta, type);\n  }\n  /**\n   * @name addFromSeed\n   * @summary Stores an account, given seed data, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   * @description Stores in a keyring pair dictionary the public key of the pair as a key and the pair as the associated value.\n   * Allows user to provide the account seed as an argument, and then generates a keyring pair from it that it passes to\n   * `addPair` to store in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n   */\n\n\n  addFromSeed(seed, meta = {}, type = this.type) {\n    return this.addPair(createPair({\n      toSS58: this.encodeAddress,\n      type\n    }, keypairFromSeed[type](seed), meta, null));\n  }\n  /**\n   * @name addFromUri\n   * @summary Creates an account via an suri\n   * @description Extracts the phrase, path and password from a SURI format for specifying secret keys `<secret>/<soft-key>//<hard-key>///<password>` (the `///password` may be omitted, and `/<soft-key>` and `//<hard-key>` maybe repeated and mixed). The secret can be a hex string, mnemonic phrase or a string (to be padded)\n   */\n\n\n  addFromUri(suri, meta = {}, type = this.type) {\n    return this.addPair(this.createFromUri(suri, meta, type));\n  }\n  /**\n   * @name createFromJson\n   * @description Creates a pair from a JSON keyfile\n   */\n\n\n  createFromJson({\n    address,\n    encoded,\n    encoding: {\n      content,\n      type,\n      version\n    },\n    meta\n  }, ignoreChecksum) {\n    const cryptoType = version === '0' || !Array.isArray(content) ? this.type : content[1];\n    const encType = !Array.isArray(type) ? [type] : type;\n    const publicKey = isHex(address) ? hexToU8a(address) : this.decodeAddress(address, ignoreChecksum);\n    const decoded = isHex(encoded) ? hexToU8a(encoded) : base64Decode(encoded);\n    return createPair({\n      toSS58: this.encodeAddress,\n      type: cryptoType\n    }, {\n      publicKey,\n      secretKey: new Uint8Array()\n    }, meta, decoded, encType);\n  }\n  /**\n   * @name createFromUri\n   * @summary Creates a Keypair from an suri\n   * @description This creates a pair from the suri, but does not add it to the keyring\n   */\n\n\n  createFromUri(_suri, meta = {}, type = this.type) {\n    // here we only aut-add the dev phrase if we have a hard-derived path\n    const suri = _suri.startsWith('//') ? `${DEV_PHRASE}${_suri}` : _suri;\n    const {\n      password,\n      path,\n      phrase\n    } = keyExtractSuri(suri);\n    let seed;\n\n    if (isHex(phrase, 256)) {\n      seed = hexToU8a(phrase);\n    } else {\n      const str = phrase;\n      const parts = str.split(' ');\n\n      if ([12, 15, 18, 21, 24].includes(parts.length)) {\n        seed = type === 'ethereum' ? mnemonicToLegacySeed(phrase) : mnemonicToMiniSecret(phrase, password);\n      } else {\n        assert(str.length <= 32, 'specified phrase is not a valid mnemonic and is invalid as a raw seed at > 32 bytes');\n        seed = stringToU8a(str.padEnd(32));\n      }\n    } // FIXME Need to support Ethereum-type derivation paths\n\n\n    const derived = keyFromPath(keypairFromSeed[type](seed), path, type);\n    return createPair({\n      toSS58: this.encodeAddress,\n      type\n    }, derived, meta, null);\n  }\n  /**\n   * @name encodeAddress\n   * @description Encodes the input into an ss58 representation\n   */\n\n  /**\n   * @name getPair\n   * @summary Retrieves an account keyring pair from the Keyring Pair Dictionary, given an account address\n   * @description Returns a keyring pair value from the keyring pair dictionary by performing\n   * a key lookup using the provided account address or public key (after decoding it).\n   */\n\n\n  getPair(address) {\n    return _classPrivateFieldLooseBase(this, _pairs)[_pairs].get(address);\n  }\n  /**\n   * @name getPairs\n   * @summary Retrieves all account keyring pairs from the Keyring Pair Dictionary\n   * @description Returns an array list of all the keyring pair values that are stored in the keyring pair dictionary.\n   */\n\n\n  getPairs() {\n    return _classPrivateFieldLooseBase(this, _pairs)[_pairs].all();\n  }\n  /**\n   * @name getPublicKeys\n   * @summary Retrieves Public Keys of all Keyring Pairs stored in the Keyring Pair Dictionary\n   * @description Returns an array list of all the public keys associated with each of the keyring pair values that are stored in the keyring pair dictionary.\n   */\n\n\n  getPublicKeys() {\n    return _classPrivateFieldLooseBase(this, _pairs)[_pairs].all().map(({\n      publicKey\n    }) => publicKey);\n  }\n  /**\n   * @name removePair\n   * @description Deletes the provided input address or public key from the stored Keyring Pair Dictionary.\n   */\n\n\n  removePair(address) {\n    _classPrivateFieldLooseBase(this, _pairs)[_pairs].remove(address);\n  }\n  /**\n   * @name setSS58Format;\n   * @description Sets the ss58 format for the keyring\n   */\n\n\n  setSS58Format(ss58) {\n    _classPrivateFieldLooseBase(this, _ss)[_ss] = ss58;\n  }\n  /**\n   * @name toJson\n   * @summary Returns a JSON object associated with the input argument that contains metadata assocated with an account\n   * @description Returns a JSON object containing the metadata associated with an account\n   * when valid address or public key and when the account passphrase is provided if the account secret\n   * is not already unlocked and available in memory. Note that in [Polkadot-JS Apps](https://github.com/polkadot-js/apps) the user\n   * may backup their account to a JSON file that contains this information.\n   */\n\n\n  toJson(address, passphrase) {\n    return _classPrivateFieldLooseBase(this, _pairs)[_pairs].get(address).toJson(passphrase);\n  }\n\n}","map":{"version":3,"sources":["/Users/bmacer/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/keyring/keyring.mjs"],"names":["_classPrivateFieldLooseBase","_classPrivateFieldLooseKey","assert","hexToU8a","isHex","isUndefined","stringToU8a","base64Decode","decodeAddress","encodeAddress","keyExtractSuri","keyFromPath","mnemonicToLegacySeed","mnemonicToMiniSecret","naclKeypairFromSeed","naclFromSeed","schnorrkelKeypairFromSeed","schnorrkelFromSeed","secp256k1KeypairFromSeed","secp256k1FromSeed","DEV_PHRASE","createPair","Pairs","keypairFromSeed","ecdsa","seed","ed25519","ethereum","sr25519","_pairs","_type","_ss","Keyring","constructor","options","Object","defineProperty","writable","value","address","ss58Format","type","includes","pairs","getPairs","publicKeys","getPublicKeys","addPair","pair","add","addFromAddress","meta","encoded","ignoreChecksum","encType","publicKey","toSS58","secretKey","Uint8Array","addFromJson","json","createFromJson","addFromMnemonic","mnemonic","addFromUri","addFromSeed","suri","createFromUri","encoding","content","version","cryptoType","Array","isArray","decoded","_suri","startsWith","password","path","phrase","str","parts","split","length","padEnd","derived","getPair","get","all","map","removePair","remove","setSS58Format","ss58","toJson","passphrase"],"mappings":"AAAA,OAAOA,2BAAP,MAAwC,uDAAxC;AACA,OAAOC,0BAAP,MAAuC,sDAAvC,C,CACA;AACA;;AACA,SAASC,MAAT,EAAiBC,QAAjB,EAA2BC,KAA3B,EAAkCC,WAAlC,EAA+CC,WAA/C,QAAkE,gBAAlE;AACA,SAASC,YAAT,EAAuBC,aAAvB,EAAsCC,aAAtC,EAAqDC,cAArD,EAAqEC,WAArE,EAAkFC,oBAAlF,EAAwGC,oBAAxG,EAA8HC,mBAAmB,IAAIC,YAArJ,EAAmKC,yBAAyB,IAAIC,kBAAhM,EAAoNC,wBAAwB,IAAIC,iBAAhP,QAAyQ,uBAAzQ;AACA,SAASC,UAAT,QAA2B,gBAA3B;AACA,SAASC,UAAT,QAA2B,kBAA3B;AACA,SAASC,KAAT,QAAsB,aAAtB;AACA,MAAMC,eAAe,GAAG;AACtBC,EAAAA,KAAK,EAAEC,IAAI,IAAIN,iBAAiB,CAACM,IAAD,CADV;AAEtBC,EAAAA,OAAO,EAAED,IAAI,IAAIV,YAAY,CAACU,IAAD,CAFP;AAGtBE,EAAAA,QAAQ,EAAEF,IAAI,IAAIN,iBAAiB,CAACM,IAAD,CAHb;AAItBG,EAAAA,OAAO,EAAEH,IAAI,IAAIR,kBAAkB,CAACQ,IAAD;AAJb,CAAxB;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAII,MAAM,GAAG5B,0BAA0B,CAAC,OAAD,CAAvC;;AAEA,IAAI6B,KAAK,GAAG7B,0BAA0B,CAAC,MAAD,CAAtC;;AAEA,IAAI8B,GAAG,GAAG9B,0BAA0B,CAAC,MAAD,CAApC;;AAEA,OAAO,MAAM+B,OAAN,CAAc;AACnBC,EAAAA,WAAW,CAACC,OAAO,GAAG,EAAX,EAAe;AACxBC,IAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4BP,MAA5B,EAAoC;AAClCQ,MAAAA,QAAQ,EAAE,IADwB;AAElCC,MAAAA,KAAK,EAAE,KAAK;AAFsB,KAApC;AAIAH,IAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4BN,KAA5B,EAAmC;AACjCO,MAAAA,QAAQ,EAAE,IADuB;AAEjCC,MAAAA,KAAK,EAAE,KAAK;AAFqB,KAAnC;AAIAH,IAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4BL,GAA5B,EAAiC;AAC/BM,MAAAA,QAAQ,EAAE,IADqB;AAE/BC,MAAAA,KAAK,EAAE,KAAK;AAFmB,KAAjC;AAIA,SAAK9B,aAAL,GAAqBA,aAArB;;AAEA,SAAKC,aAAL,GAAqB,CAAC8B,OAAD,EAAUC,UAAV,KAAyB;AAC5C,aAAO/B,aAAa,CAAC8B,OAAD,EAAUlC,WAAW,CAACmC,UAAD,CAAX,GAA0BxC,2BAA2B,CAAC,IAAD,EAAO+B,GAAP,CAA3B,CAAuCA,GAAvC,CAA1B,GAAwES,UAAlF,CAApB;AACD,KAFD;;AAIAN,IAAAA,OAAO,CAACO,IAAR,GAAeP,OAAO,CAACO,IAAR,IAAgB,SAA/B;AACAvC,IAAAA,MAAM,CAACgC,OAAO,IAAI,CAAC,OAAD,EAAU,UAAV,EAAsB,SAAtB,EAAiC,SAAjC,EAA4CQ,QAA5C,CAAqDR,OAAO,CAACO,IAAR,IAAgB,WAArE,CAAZ,EAAgG,6EAA4EP,OAAO,CAACO,IAAK,EAAzL,CAAN;AACAzC,IAAAA,2BAA2B,CAAC,IAAD,EAAO6B,MAAP,CAA3B,CAA0CA,MAA1C,IAAoD,IAAIP,KAAJ,EAApD;AACAtB,IAAAA,2BAA2B,CAAC,IAAD,EAAO+B,GAAP,CAA3B,CAAuCA,GAAvC,IAA8CG,OAAO,CAACM,UAAtD;AACAxC,IAAAA,2BAA2B,CAAC,IAAD,EAAO8B,KAAP,CAA3B,CAAyCA,KAAzC,IAAkDI,OAAO,CAACO,IAA1D;AACD;AACD;AACF;AACA;;;AAGW,MAALE,KAAK,GAAG;AACV,WAAO,KAAKC,QAAL,EAAP;AACD;AACD;AACF;AACA;;;AAGgB,MAAVC,UAAU,GAAG;AACf,WAAO,KAAKC,aAAL,EAAP;AACD;AACD;AACF;AACA;;;AAGU,MAAJL,IAAI,GAAG;AACT,WAAOzC,2BAA2B,CAAC,IAAD,EAAO8B,KAAP,CAA3B,CAAyCA,KAAzC,CAAP;AACD;AACD;AACF;AACA;AACA;;;AAGEiB,EAAAA,OAAO,CAACC,IAAD,EAAO;AACZ,WAAOhD,2BAA2B,CAAC,IAAD,EAAO6B,MAAP,CAA3B,CAA0CA,MAA1C,EAAkDoB,GAAlD,CAAsDD,IAAtD,CAAP;AACD;AACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGEE,EAAAA,cAAc,CAACX,OAAD,EAAUY,IAAI,GAAG,EAAjB,EAAqBC,OAAO,GAAG,IAA/B,EAAqCX,IAAI,GAAG,KAAKA,IAAjD,EAAuDY,cAAvD,EAAuEC,OAAvE,EAAgF;AAC5F,UAAMC,SAAS,GAAG,KAAK/C,aAAL,CAAmB+B,OAAnB,EAA4Bc,cAA5B,CAAlB;AACA,WAAO,KAAKN,OAAL,CAAa1B,UAAU,CAAC;AAC7BmC,MAAAA,MAAM,EAAE,KAAK/C,aADgB;AAE7BgC,MAAAA;AAF6B,KAAD,EAG3B;AACDc,MAAAA,SADC;AAEDE,MAAAA,SAAS,EAAE,IAAIC,UAAJ;AAFV,KAH2B,EAM3BP,IAN2B,EAMrBC,OANqB,EAMZE,OANY,CAAvB,CAAP;AAOD;AACD;AACF;AACA;AACA;AACA;AACA;AACA;;;AAGEK,EAAAA,WAAW,CAACC,IAAD,EAAOP,cAAP,EAAuB;AAChC,WAAO,KAAKN,OAAL,CAAa,KAAKc,cAAL,CAAoBD,IAApB,EAA0BP,cAA1B,CAAb,CAAP;AACD;AACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGES,EAAAA,eAAe,CAACC,QAAD,EAAWZ,IAAI,GAAG,EAAlB,EAAsBV,IAAI,GAAG,KAAKA,IAAlC,EAAwC;AACrD,WAAO,KAAKuB,UAAL,CAAgBD,QAAhB,EAA0BZ,IAA1B,EAAgCV,IAAhC,CAAP;AACD;AACD;AACF;AACA;AACA;AACA;AACA;AACA;;;AAGEwB,EAAAA,WAAW,CAACxC,IAAD,EAAO0B,IAAI,GAAG,EAAd,EAAkBV,IAAI,GAAG,KAAKA,IAA9B,EAAoC;AAC7C,WAAO,KAAKM,OAAL,CAAa1B,UAAU,CAAC;AAC7BmC,MAAAA,MAAM,EAAE,KAAK/C,aADgB;AAE7BgC,MAAAA;AAF6B,KAAD,EAG3BlB,eAAe,CAACkB,IAAD,CAAf,CAAsBhB,IAAtB,CAH2B,EAGE0B,IAHF,EAGQ,IAHR,CAAvB,CAAP;AAID;AACD;AACF;AACA;AACA;AACA;;;AAGEa,EAAAA,UAAU,CAACE,IAAD,EAAOf,IAAI,GAAG,EAAd,EAAkBV,IAAI,GAAG,KAAKA,IAA9B,EAAoC;AAC5C,WAAO,KAAKM,OAAL,CAAa,KAAKoB,aAAL,CAAmBD,IAAnB,EAAyBf,IAAzB,EAA+BV,IAA/B,CAAb,CAAP;AACD;AACD;AACF;AACA;AACA;;;AAGEoB,EAAAA,cAAc,CAAC;AACbtB,IAAAA,OADa;AAEba,IAAAA,OAFa;AAGbgB,IAAAA,QAAQ,EAAE;AACRC,MAAAA,OADQ;AAER5B,MAAAA,IAFQ;AAGR6B,MAAAA;AAHQ,KAHG;AAQbnB,IAAAA;AARa,GAAD,EASXE,cATW,EASK;AACjB,UAAMkB,UAAU,GAAGD,OAAO,KAAK,GAAZ,IAAmB,CAACE,KAAK,CAACC,OAAN,CAAcJ,OAAd,CAApB,GAA6C,KAAK5B,IAAlD,GAAyD4B,OAAO,CAAC,CAAD,CAAnF;AACA,UAAMf,OAAO,GAAG,CAACkB,KAAK,CAACC,OAAN,CAAchC,IAAd,CAAD,GAAuB,CAACA,IAAD,CAAvB,GAAgCA,IAAhD;AACA,UAAMc,SAAS,GAAGnD,KAAK,CAACmC,OAAD,CAAL,GAAiBpC,QAAQ,CAACoC,OAAD,CAAzB,GAAqC,KAAK/B,aAAL,CAAmB+B,OAAnB,EAA4Bc,cAA5B,CAAvD;AACA,UAAMqB,OAAO,GAAGtE,KAAK,CAACgD,OAAD,CAAL,GAAiBjD,QAAQ,CAACiD,OAAD,CAAzB,GAAqC7C,YAAY,CAAC6C,OAAD,CAAjE;AACA,WAAO/B,UAAU,CAAC;AAChBmC,MAAAA,MAAM,EAAE,KAAK/C,aADG;AAEhBgC,MAAAA,IAAI,EAAE8B;AAFU,KAAD,EAGd;AACDhB,MAAAA,SADC;AAEDE,MAAAA,SAAS,EAAE,IAAIC,UAAJ;AAFV,KAHc,EAMdP,IANc,EAMRuB,OANQ,EAMCpB,OAND,CAAjB;AAOD;AACD;AACF;AACA;AACA;AACA;;;AAGEa,EAAAA,aAAa,CAACQ,KAAD,EAAQxB,IAAI,GAAG,EAAf,EAAmBV,IAAI,GAAG,KAAKA,IAA/B,EAAqC;AAChD;AACA,UAAMyB,IAAI,GAAGS,KAAK,CAACC,UAAN,CAAiB,IAAjB,IAA0B,GAAExD,UAAW,GAAEuD,KAAM,EAA/C,GAAmDA,KAAhE;AACA,UAAM;AACJE,MAAAA,QADI;AAEJC,MAAAA,IAFI;AAGJC,MAAAA;AAHI,QAIFrE,cAAc,CAACwD,IAAD,CAJlB;AAKA,QAAIzC,IAAJ;;AAEA,QAAIrB,KAAK,CAAC2E,MAAD,EAAS,GAAT,CAAT,EAAwB;AACtBtD,MAAAA,IAAI,GAAGtB,QAAQ,CAAC4E,MAAD,CAAf;AACD,KAFD,MAEO;AACL,YAAMC,GAAG,GAAGD,MAAZ;AACA,YAAME,KAAK,GAAGD,GAAG,CAACE,KAAJ,CAAU,GAAV,CAAd;;AAEA,UAAI,CAAC,EAAD,EAAK,EAAL,EAAS,EAAT,EAAa,EAAb,EAAiB,EAAjB,EAAqBxC,QAArB,CAA8BuC,KAAK,CAACE,MAApC,CAAJ,EAAiD;AAC/C1D,QAAAA,IAAI,GAAGgB,IAAI,KAAK,UAAT,GAAsB7B,oBAAoB,CAACmE,MAAD,CAA1C,GAAqDlE,oBAAoB,CAACkE,MAAD,EAASF,QAAT,CAAhF;AACD,OAFD,MAEO;AACL3E,QAAAA,MAAM,CAAC8E,GAAG,CAACG,MAAJ,IAAc,EAAf,EAAmB,qFAAnB,CAAN;AACA1D,QAAAA,IAAI,GAAGnB,WAAW,CAAC0E,GAAG,CAACI,MAAJ,CAAW,EAAX,CAAD,CAAlB;AACD;AACF,KAtB+C,CAsB9C;;;AAGF,UAAMC,OAAO,GAAG1E,WAAW,CAACY,eAAe,CAACkB,IAAD,CAAf,CAAsBhB,IAAtB,CAAD,EAA8BqD,IAA9B,EAAoCrC,IAApC,CAA3B;AACA,WAAOpB,UAAU,CAAC;AAChBmC,MAAAA,MAAM,EAAE,KAAK/C,aADG;AAEhBgC,MAAAA;AAFgB,KAAD,EAGd4C,OAHc,EAGLlC,IAHK,EAGC,IAHD,CAAjB;AAID;AACD;AACF;AACA;AACA;;AAGE;AACF;AACA;AACA;AACA;AACA;;;AACEmC,EAAAA,OAAO,CAAC/C,OAAD,EAAU;AACf,WAAOvC,2BAA2B,CAAC,IAAD,EAAO6B,MAAP,CAA3B,CAA0CA,MAA1C,EAAkD0D,GAAlD,CAAsDhD,OAAtD,CAAP;AACD;AACD;AACF;AACA;AACA;AACA;;;AAGEK,EAAAA,QAAQ,GAAG;AACT,WAAO5C,2BAA2B,CAAC,IAAD,EAAO6B,MAAP,CAA3B,CAA0CA,MAA1C,EAAkD2D,GAAlD,EAAP;AACD;AACD;AACF;AACA;AACA;AACA;;;AAGE1C,EAAAA,aAAa,GAAG;AACd,WAAO9C,2BAA2B,CAAC,IAAD,EAAO6B,MAAP,CAA3B,CAA0CA,MAA1C,EAAkD2D,GAAlD,GAAwDC,GAAxD,CAA4D,CAAC;AAClElC,MAAAA;AADkE,KAAD,KAE7DA,SAFC,CAAP;AAGD;AACD;AACF;AACA;AACA;;;AAGEmC,EAAAA,UAAU,CAACnD,OAAD,EAAU;AAClBvC,IAAAA,2BAA2B,CAAC,IAAD,EAAO6B,MAAP,CAA3B,CAA0CA,MAA1C,EAAkD8D,MAAlD,CAAyDpD,OAAzD;AACD;AACD;AACF;AACA;AACA;;;AAGEqD,EAAAA,aAAa,CAACC,IAAD,EAAO;AAClB7F,IAAAA,2BAA2B,CAAC,IAAD,EAAO+B,GAAP,CAA3B,CAAuCA,GAAvC,IAA8C8D,IAA9C;AACD;AACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGEC,EAAAA,MAAM,CAACvD,OAAD,EAAUwD,UAAV,EAAsB;AAC1B,WAAO/F,2BAA2B,CAAC,IAAD,EAAO6B,MAAP,CAA3B,CAA0CA,MAA1C,EAAkD0D,GAAlD,CAAsDhD,OAAtD,EAA+DuD,MAA/D,CAAsEC,UAAtE,CAAP;AACD;;AAtQkB","sourcesContent":["import _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n// Copyright 2017-2021 @polkadot/keyring authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, hexToU8a, isHex, isUndefined, stringToU8a } from '@polkadot/util';\nimport { base64Decode, decodeAddress, encodeAddress, keyExtractSuri, keyFromPath, mnemonicToLegacySeed, mnemonicToMiniSecret, naclKeypairFromSeed as naclFromSeed, schnorrkelKeypairFromSeed as schnorrkelFromSeed, secp256k1KeypairFromSeed as secp256k1FromSeed } from '@polkadot/util-crypto';\nimport { DEV_PHRASE } from \"./defaults.mjs\";\nimport { createPair } from \"./pair/index.mjs\";\nimport { Pairs } from \"./pairs.mjs\";\nconst keypairFromSeed = {\n  ecdsa: seed => secp256k1FromSeed(seed),\n  ed25519: seed => naclFromSeed(seed),\n  ethereum: seed => secp256k1FromSeed(seed),\n  sr25519: seed => schnorrkelFromSeed(seed)\n};\n/**\n * # @polkadot/keyring\n *\n * ## Overview\n *\n * @name Keyring\n * @summary Keyring management of user accounts\n * @description Allows generation of keyring pairs from a variety of input combinations, such as\n * json object containing account address or public key, account metadata, and account encoded using\n * `addFromJson`, or by providing those values as arguments separately to `addFromAddress`,\n * or by providing the mnemonic (seed phrase) and account metadata as arguments to `addFromMnemonic`.\n * Stores the keyring pairs in a keyring pair dictionary. Removal of the keyring pairs from the keyring pair\n * dictionary is achieved using `removePair`. Retrieval of all the stored pairs via `getPairs` or perform\n * lookup of a pair for a given account address or public key using `getPair`. JSON metadata associated with\n * an account may be obtained using `toJson` accompanied by the account passphrase.\n */\n\nvar _pairs = _classPrivateFieldLooseKey(\"pairs\");\n\nvar _type = _classPrivateFieldLooseKey(\"type\");\n\nvar _ss = _classPrivateFieldLooseKey(\"ss58\");\n\nexport class Keyring {\n  constructor(options = {}) {\n    Object.defineProperty(this, _pairs, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _type, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _ss, {\n      writable: true,\n      value: void 0\n    });\n    this.decodeAddress = decodeAddress;\n\n    this.encodeAddress = (address, ss58Format) => {\n      return encodeAddress(address, isUndefined(ss58Format) ? _classPrivateFieldLooseBase(this, _ss)[_ss] : ss58Format);\n    };\n\n    options.type = options.type || 'ed25519';\n    assert(options && ['ecdsa', 'ethereum', 'ed25519', 'sr25519'].includes(options.type || 'undefined'), `Expected a keyring type of either 'ed25519', 'sr25519' or 'ecdsa', found '${options.type}`);\n    _classPrivateFieldLooseBase(this, _pairs)[_pairs] = new Pairs();\n    _classPrivateFieldLooseBase(this, _ss)[_ss] = options.ss58Format;\n    _classPrivateFieldLooseBase(this, _type)[_type] = options.type;\n  }\n  /**\n   * @description retrieve the pairs (alias for getPairs)\n   */\n\n\n  get pairs() {\n    return this.getPairs();\n  }\n  /**\n   * @description retrieve the publicKeys (alias for getPublicKeys)\n   */\n\n\n  get publicKeys() {\n    return this.getPublicKeys();\n  }\n  /**\n   * @description Returns the type of the keyring, ed25519, sr25519 or ecdsa\n   */\n\n\n  get type() {\n    return _classPrivateFieldLooseBase(this, _type)[_type];\n  }\n  /**\n   * @name addPair\n   * @summary Stores an account, given a keyring pair, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   */\n\n\n  addPair(pair) {\n    return _classPrivateFieldLooseBase(this, _pairs)[_pairs].add(pair);\n  }\n  /**\n   * @name addFromAddress\n   * @summary Stores an account, given an account address, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   * @description Allows user to explicitely provide separate inputs including account address or public key, and optionally\n   * the associated account metadata, and the default encoded value as arguments (that may be obtained from the json file\n   * of an account backup), and then generates a keyring pair from them that it passes to\n   * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n   */\n\n\n  addFromAddress(address, meta = {}, encoded = null, type = this.type, ignoreChecksum, encType) {\n    const publicKey = this.decodeAddress(address, ignoreChecksum);\n    return this.addPair(createPair({\n      toSS58: this.encodeAddress,\n      type\n    }, {\n      publicKey,\n      secretKey: new Uint8Array()\n    }, meta, encoded, encType));\n  }\n  /**\n   * @name addFromJson\n   * @summary Stores an account, given JSON data, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   * @description Allows user to provide a json object argument that contains account information (that may be obtained from the json file\n   * of an account backup), and then generates a keyring pair from it that it passes to\n   * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n   */\n\n\n  addFromJson(json, ignoreChecksum) {\n    return this.addPair(this.createFromJson(json, ignoreChecksum));\n  }\n  /**\n   * @name addFromMnemonic\n   * @summary Stores an account, given a mnemonic, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   * @description Allows user to provide a mnemonic (seed phrase that is provided when account is originally created)\n   * argument and a metadata argument that contains account information (that may be obtained from the json file\n   * of an account backup), and then generates a keyring pair from it that it passes to\n   * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n   */\n\n\n  addFromMnemonic(mnemonic, meta = {}, type = this.type) {\n    return this.addFromUri(mnemonic, meta, type);\n  }\n  /**\n   * @name addFromSeed\n   * @summary Stores an account, given seed data, as a Key/Value (public key, pair) in Keyring Pair Dictionary\n   * @description Stores in a keyring pair dictionary the public key of the pair as a key and the pair as the associated value.\n   * Allows user to provide the account seed as an argument, and then generates a keyring pair from it that it passes to\n   * `addPair` to store in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.\n   */\n\n\n  addFromSeed(seed, meta = {}, type = this.type) {\n    return this.addPair(createPair({\n      toSS58: this.encodeAddress,\n      type\n    }, keypairFromSeed[type](seed), meta, null));\n  }\n  /**\n   * @name addFromUri\n   * @summary Creates an account via an suri\n   * @description Extracts the phrase, path and password from a SURI format for specifying secret keys `<secret>/<soft-key>//<hard-key>///<password>` (the `///password` may be omitted, and `/<soft-key>` and `//<hard-key>` maybe repeated and mixed). The secret can be a hex string, mnemonic phrase or a string (to be padded)\n   */\n\n\n  addFromUri(suri, meta = {}, type = this.type) {\n    return this.addPair(this.createFromUri(suri, meta, type));\n  }\n  /**\n   * @name createFromJson\n   * @description Creates a pair from a JSON keyfile\n   */\n\n\n  createFromJson({\n    address,\n    encoded,\n    encoding: {\n      content,\n      type,\n      version\n    },\n    meta\n  }, ignoreChecksum) {\n    const cryptoType = version === '0' || !Array.isArray(content) ? this.type : content[1];\n    const encType = !Array.isArray(type) ? [type] : type;\n    const publicKey = isHex(address) ? hexToU8a(address) : this.decodeAddress(address, ignoreChecksum);\n    const decoded = isHex(encoded) ? hexToU8a(encoded) : base64Decode(encoded);\n    return createPair({\n      toSS58: this.encodeAddress,\n      type: cryptoType\n    }, {\n      publicKey,\n      secretKey: new Uint8Array()\n    }, meta, decoded, encType);\n  }\n  /**\n   * @name createFromUri\n   * @summary Creates a Keypair from an suri\n   * @description This creates a pair from the suri, but does not add it to the keyring\n   */\n\n\n  createFromUri(_suri, meta = {}, type = this.type) {\n    // here we only aut-add the dev phrase if we have a hard-derived path\n    const suri = _suri.startsWith('//') ? `${DEV_PHRASE}${_suri}` : _suri;\n    const {\n      password,\n      path,\n      phrase\n    } = keyExtractSuri(suri);\n    let seed;\n\n    if (isHex(phrase, 256)) {\n      seed = hexToU8a(phrase);\n    } else {\n      const str = phrase;\n      const parts = str.split(' ');\n\n      if ([12, 15, 18, 21, 24].includes(parts.length)) {\n        seed = type === 'ethereum' ? mnemonicToLegacySeed(phrase) : mnemonicToMiniSecret(phrase, password);\n      } else {\n        assert(str.length <= 32, 'specified phrase is not a valid mnemonic and is invalid as a raw seed at > 32 bytes');\n        seed = stringToU8a(str.padEnd(32));\n      }\n    } // FIXME Need to support Ethereum-type derivation paths\n\n\n    const derived = keyFromPath(keypairFromSeed[type](seed), path, type);\n    return createPair({\n      toSS58: this.encodeAddress,\n      type\n    }, derived, meta, null);\n  }\n  /**\n   * @name encodeAddress\n   * @description Encodes the input into an ss58 representation\n   */\n\n\n  /**\n   * @name getPair\n   * @summary Retrieves an account keyring pair from the Keyring Pair Dictionary, given an account address\n   * @description Returns a keyring pair value from the keyring pair dictionary by performing\n   * a key lookup using the provided account address or public key (after decoding it).\n   */\n  getPair(address) {\n    return _classPrivateFieldLooseBase(this, _pairs)[_pairs].get(address);\n  }\n  /**\n   * @name getPairs\n   * @summary Retrieves all account keyring pairs from the Keyring Pair Dictionary\n   * @description Returns an array list of all the keyring pair values that are stored in the keyring pair dictionary.\n   */\n\n\n  getPairs() {\n    return _classPrivateFieldLooseBase(this, _pairs)[_pairs].all();\n  }\n  /**\n   * @name getPublicKeys\n   * @summary Retrieves Public Keys of all Keyring Pairs stored in the Keyring Pair Dictionary\n   * @description Returns an array list of all the public keys associated with each of the keyring pair values that are stored in the keyring pair dictionary.\n   */\n\n\n  getPublicKeys() {\n    return _classPrivateFieldLooseBase(this, _pairs)[_pairs].all().map(({\n      publicKey\n    }) => publicKey);\n  }\n  /**\n   * @name removePair\n   * @description Deletes the provided input address or public key from the stored Keyring Pair Dictionary.\n   */\n\n\n  removePair(address) {\n    _classPrivateFieldLooseBase(this, _pairs)[_pairs].remove(address);\n  }\n  /**\n   * @name setSS58Format;\n   * @description Sets the ss58 format for the keyring\n   */\n\n\n  setSS58Format(ss58) {\n    _classPrivateFieldLooseBase(this, _ss)[_ss] = ss58;\n  }\n  /**\n   * @name toJson\n   * @summary Returns a JSON object associated with the input argument that contains metadata assocated with an account\n   * @description Returns a JSON object containing the metadata associated with an account\n   * when valid address or public key and when the account passphrase is provided if the account secret\n   * is not already unlocked and available in memory. Note that in [Polkadot-JS Apps](https://github.com/polkadot-js/apps) the user\n   * may backup their account to a JSON file that contains this information.\n   */\n\n\n  toJson(address, passphrase) {\n    return _classPrivateFieldLooseBase(this, _pairs)[_pairs].get(address).toJson(passphrase);\n  }\n\n}"]},"metadata":{},"sourceType":"module"}