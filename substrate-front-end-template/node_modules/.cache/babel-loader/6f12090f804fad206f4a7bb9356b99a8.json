{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { assert, isNumber, isUndefined } from '@polkadot/util';\nimport { TypeDefInfo } from \"./types.mjs\";\n\nconst stringIdentity = value => value.toString();\n\nconst INFO_WRAP = ['BTreeMap', 'BTreeSet', 'Compact', 'HashMap', 'Option', 'Result', 'Vec'];\nexport function paramsNotation(outer, inner, transform = stringIdentity) {\n  return `${outer}${inner ? `<${(Array.isArray(inner) ? inner : [inner]).map(transform).join(', ')}>` : ''}`;\n}\n\nfunction encodeWithParams(typeDef, outer) {\n  const {\n    info,\n    sub\n  } = typeDef;\n\n  switch (info) {\n    case TypeDefInfo.BTreeMap:\n    case TypeDefInfo.BTreeSet:\n    case TypeDefInfo.Compact:\n    case TypeDefInfo.HashMap:\n    case TypeDefInfo.Linkage:\n    case TypeDefInfo.Option:\n    case TypeDefInfo.Result:\n    case TypeDefInfo.Vec:\n      return paramsNotation(outer, sub, param => encodeTypeDef(param));\n  }\n\n  throw new Error(`Unable to encode ${JSON.stringify(typeDef)} with params`);\n}\n\nfunction encodeDoNotConstruct({\n  displayName\n}) {\n  return `DoNotConstruct<${displayName || 'Unknown'}>`;\n}\n\nfunction encodeSubTypes(sub, asEnum) {\n  const names = sub.map(({\n    name\n  }) => name);\n  assert(names.every(n => !!n), `Subtypes does not have consistent names, ${names.join(', ')}`);\n  const inner = sub.reduce((result, type) => _objectSpread(_objectSpread({}, result), {}, {\n    [type.name]: encodeTypeDef(type)\n  }), {});\n  return JSON.stringify(asEnum ? {\n    _enum: inner\n  } : inner);\n}\n\nfunction encodeEnum(typeDef) {\n  assert(typeDef.sub && Array.isArray(typeDef.sub), 'Unable to encode Enum type');\n  const sub = typeDef.sub; // c-like enums have all Null entries\n  // TODO We need to take the disciminant into account and auto-add empty entries\n\n  return sub.every(({\n    type\n  }) => type === 'Null') ? JSON.stringify({\n    _enum: sub.map(({\n      name\n    }, index) => `${name || `Empty${index}`}`)\n  }) : encodeSubTypes(sub, true);\n}\n\nfunction encodeStruct(typeDef) {\n  assert(typeDef.sub && Array.isArray(typeDef.sub), 'Unable to encode Struct type');\n  return encodeSubTypes(typeDef.sub);\n}\n\nfunction encodeTuple(typeDef) {\n  assert(typeDef.sub && Array.isArray(typeDef.sub), 'Unable to encode Tuple type');\n  return `(${typeDef.sub.map(type => encodeTypeDef(type)).join(', ')})`;\n}\n\nfunction encodeUInt({\n  length\n}, type) {\n  assert(isNumber(length), 'Unable to encode VecFixed type');\n  return `${type}<${length}>`;\n}\n\nfunction encodeVecFixed({\n  length,\n  sub\n}) {\n  assert(isNumber(length) && !isUndefined(sub) && !Array.isArray(sub), 'Unable to encode VecFixed type');\n  return `[${sub.type};${length}]`;\n} // We setup a record here to ensure we have comprehensive coverage (any item not covered will result\n// in a compile-time error with the missing index)\n\n\nconst encoders = {\n  [TypeDefInfo.BTreeMap]: typeDef => encodeWithParams(typeDef, 'BTreeMap'),\n  [TypeDefInfo.BTreeSet]: typeDef => encodeWithParams(typeDef, 'BTreeSet'),\n  [TypeDefInfo.Compact]: typeDef => encodeWithParams(typeDef, 'Compact'),\n  [TypeDefInfo.DoNotConstruct]: typeDef => encodeDoNotConstruct(typeDef),\n  [TypeDefInfo.Enum]: typeDef => encodeEnum(typeDef),\n  [TypeDefInfo.HashMap]: typeDef => encodeWithParams(typeDef, 'HashMap'),\n  [TypeDefInfo.Int]: typeDef => encodeUInt(typeDef, 'Int'),\n  [TypeDefInfo.Linkage]: typeDef => encodeWithParams(typeDef, 'Linkage'),\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  [TypeDefInfo.Null]: typeDef => 'Null',\n  [TypeDefInfo.Option]: typeDef => encodeWithParams(typeDef, 'Option'),\n  [TypeDefInfo.Plain]: typeDef => typeDef.displayName || typeDef.type,\n  [TypeDefInfo.Result]: typeDef => encodeWithParams(typeDef, 'Result'),\n  [TypeDefInfo.Set]: typeDef => typeDef.type,\n  [TypeDefInfo.Struct]: typeDef => encodeStruct(typeDef),\n  [TypeDefInfo.Tuple]: typeDef => encodeTuple(typeDef),\n  [TypeDefInfo.UInt]: typeDef => encodeUInt(typeDef, 'UInt'),\n  [TypeDefInfo.Vec]: typeDef => encodeWithParams(typeDef, 'Vec'),\n  [TypeDefInfo.VecFixed]: typeDef => encodeVecFixed(typeDef)\n};\n\nfunction encodeType(typeDef) {\n  const encoder = encoders[typeDef.info];\n  assert(encoder, `Cannot encode type: ${JSON.stringify(typeDef)}`);\n  return encoder(typeDef);\n}\n\nexport function encodeTypeDef(typeDef) {\n  assert(!isUndefined(typeDef.info), `Invalid type definition with no instance info, ${JSON.stringify(typeDef)}`); // In the case of contracts we do have the unfortunate situation where the displayName would\n  // refer to \"Option\" when it is an option. For these, string it out, only using when actually\n  // not a top-level element to be used\n\n  if (typeDef.displayName && !INFO_WRAP.some(i => typeDef.displayName === i)) {\n    return typeDef.displayName;\n  }\n\n  return encodeType(typeDef);\n}\nexport function withTypeString(typeDef) {\n  return _objectSpread(_objectSpread({}, typeDef), {}, {\n    type: encodeType(typeDef)\n  });\n}","map":{"version":3,"sources":["/Users/bmacer/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/types/create/encodeTypes.mjs"],"names":["_defineProperty","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","assert","isNumber","isUndefined","TypeDefInfo","stringIdentity","value","toString","INFO_WRAP","paramsNotation","outer","inner","transform","Array","isArray","map","join","encodeWithParams","typeDef","info","sub","BTreeMap","BTreeSet","Compact","HashMap","Linkage","Option","Result","Vec","param","encodeTypeDef","Error","JSON","stringify","encodeDoNotConstruct","displayName","encodeSubTypes","asEnum","names","name","every","n","reduce","result","type","_enum","encodeEnum","index","encodeStruct","encodeTuple","encodeUInt","encodeVecFixed","encoders","DoNotConstruct","Enum","Int","Null","Plain","Set","Struct","Tuple","UInt","VecFixed","encodeType","encoder","some","withTypeString"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isNumber, isUndefined } from '@polkadot/util';\nimport { TypeDefInfo } from \"./types.mjs\";\n\nconst stringIdentity = value => value.toString();\n\nconst INFO_WRAP = ['BTreeMap', 'BTreeSet', 'Compact', 'HashMap', 'Option', 'Result', 'Vec'];\nexport function paramsNotation(outer, inner, transform = stringIdentity) {\n  return `${outer}${inner ? `<${(Array.isArray(inner) ? inner : [inner]).map(transform).join(', ')}>` : ''}`;\n}\n\nfunction encodeWithParams(typeDef, outer) {\n  const {\n    info,\n    sub\n  } = typeDef;\n\n  switch (info) {\n    case TypeDefInfo.BTreeMap:\n    case TypeDefInfo.BTreeSet:\n    case TypeDefInfo.Compact:\n    case TypeDefInfo.HashMap:\n    case TypeDefInfo.Linkage:\n    case TypeDefInfo.Option:\n    case TypeDefInfo.Result:\n    case TypeDefInfo.Vec:\n      return paramsNotation(outer, sub, param => encodeTypeDef(param));\n  }\n\n  throw new Error(`Unable to encode ${JSON.stringify(typeDef)} with params`);\n}\n\nfunction encodeDoNotConstruct({\n  displayName\n}) {\n  return `DoNotConstruct<${displayName || 'Unknown'}>`;\n}\n\nfunction encodeSubTypes(sub, asEnum) {\n  const names = sub.map(({\n    name\n  }) => name);\n  assert(names.every(n => !!n), `Subtypes does not have consistent names, ${names.join(', ')}`);\n  const inner = sub.reduce((result, type) => _objectSpread(_objectSpread({}, result), {}, {\n    [type.name]: encodeTypeDef(type)\n  }), {});\n  return JSON.stringify(asEnum ? {\n    _enum: inner\n  } : inner);\n}\n\nfunction encodeEnum(typeDef) {\n  assert(typeDef.sub && Array.isArray(typeDef.sub), 'Unable to encode Enum type');\n  const sub = typeDef.sub; // c-like enums have all Null entries\n  // TODO We need to take the disciminant into account and auto-add empty entries\n\n  return sub.every(({\n    type\n  }) => type === 'Null') ? JSON.stringify({\n    _enum: sub.map(({\n      name\n    }, index) => `${name || `Empty${index}`}`)\n  }) : encodeSubTypes(sub, true);\n}\n\nfunction encodeStruct(typeDef) {\n  assert(typeDef.sub && Array.isArray(typeDef.sub), 'Unable to encode Struct type');\n  return encodeSubTypes(typeDef.sub);\n}\n\nfunction encodeTuple(typeDef) {\n  assert(typeDef.sub && Array.isArray(typeDef.sub), 'Unable to encode Tuple type');\n  return `(${typeDef.sub.map(type => encodeTypeDef(type)).join(', ')})`;\n}\n\nfunction encodeUInt({\n  length\n}, type) {\n  assert(isNumber(length), 'Unable to encode VecFixed type');\n  return `${type}<${length}>`;\n}\n\nfunction encodeVecFixed({\n  length,\n  sub\n}) {\n  assert(isNumber(length) && !isUndefined(sub) && !Array.isArray(sub), 'Unable to encode VecFixed type');\n  return `[${sub.type};${length}]`;\n} // We setup a record here to ensure we have comprehensive coverage (any item not covered will result\n// in a compile-time error with the missing index)\n\n\nconst encoders = {\n  [TypeDefInfo.BTreeMap]: typeDef => encodeWithParams(typeDef, 'BTreeMap'),\n  [TypeDefInfo.BTreeSet]: typeDef => encodeWithParams(typeDef, 'BTreeSet'),\n  [TypeDefInfo.Compact]: typeDef => encodeWithParams(typeDef, 'Compact'),\n  [TypeDefInfo.DoNotConstruct]: typeDef => encodeDoNotConstruct(typeDef),\n  [TypeDefInfo.Enum]: typeDef => encodeEnum(typeDef),\n  [TypeDefInfo.HashMap]: typeDef => encodeWithParams(typeDef, 'HashMap'),\n  [TypeDefInfo.Int]: typeDef => encodeUInt(typeDef, 'Int'),\n  [TypeDefInfo.Linkage]: typeDef => encodeWithParams(typeDef, 'Linkage'),\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  [TypeDefInfo.Null]: typeDef => 'Null',\n  [TypeDefInfo.Option]: typeDef => encodeWithParams(typeDef, 'Option'),\n  [TypeDefInfo.Plain]: typeDef => typeDef.displayName || typeDef.type,\n  [TypeDefInfo.Result]: typeDef => encodeWithParams(typeDef, 'Result'),\n  [TypeDefInfo.Set]: typeDef => typeDef.type,\n  [TypeDefInfo.Struct]: typeDef => encodeStruct(typeDef),\n  [TypeDefInfo.Tuple]: typeDef => encodeTuple(typeDef),\n  [TypeDefInfo.UInt]: typeDef => encodeUInt(typeDef, 'UInt'),\n  [TypeDefInfo.Vec]: typeDef => encodeWithParams(typeDef, 'Vec'),\n  [TypeDefInfo.VecFixed]: typeDef => encodeVecFixed(typeDef)\n};\n\nfunction encodeType(typeDef) {\n  const encoder = encoders[typeDef.info];\n  assert(encoder, `Cannot encode type: ${JSON.stringify(typeDef)}`);\n  return encoder(typeDef);\n}\n\nexport function encodeTypeDef(typeDef) {\n  assert(!isUndefined(typeDef.info), `Invalid type definition with no instance info, ${JSON.stringify(typeDef)}`); // In the case of contracts we do have the unfortunate situation where the displayName would\n  // refer to \"Option\" when it is an option. For these, string it out, only using when actually\n  // not a top-level element to be used\n\n  if (typeDef.displayName && !INFO_WRAP.some(i => typeDef.displayName === i)) {\n    return typeDef.displayName;\n  }\n\n  return encodeType(typeDef);\n}\nexport function withTypeString(typeDef) {\n  return _objectSpread(_objectSpread({}, typeDef), {}, {\n    type: encodeType(typeDef)\n  });\n}"]},"metadata":{},"sourceType":"module"}