{"ast":null,"code":"import _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\"; // Copyright 2017-2021 @polkadot/rpc-provider authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\nimport { assert, isNumber, isString, isUndefined } from '@polkadot/util';\n\nfunction formatErrorData(data) {\n  if (isUndefined(data)) {\n    return '';\n  }\n\n  const formatted = `: ${isString(data) ? data.replace(/Error\\(\"/g, '').replace(/\\(\"/g, '(').replace(/\"\\)/g, ')').replace(/\\(/g, ', ').replace(/\\)/g, '') : JSON.stringify(data)}`; // We need some sort of cut-off here since these can be very large and\n  // very nested, pick a number and trim the result display to it\n\n  return formatted.length <= 256 ? formatted : `${formatted.substr(0, 255)}…`;\n}\n/** @internal */\n\n\nvar _id = _classPrivateFieldLooseKey(\"id\");\n\nexport class RpcCoder {\n  constructor() {\n    Object.defineProperty(this, _id, {\n      writable: true,\n      value: 0\n    });\n  }\n\n  decodeResponse(response) {\n    assert(response, 'Empty response object received');\n    assert(response.jsonrpc === '2.0', 'Invalid jsonrpc field in decoded object');\n    const isSubscription = !isUndefined(response.params) && !isUndefined(response.method);\n    assert(isNumber(response.id) || isSubscription && (isNumber(response.params.subscription) || isString(response.params.subscription)), 'Invalid id field in decoded object');\n\n    this._checkError(response.error);\n\n    assert(!isUndefined(response.result) || isSubscription, 'No result found in JsonRpc response');\n\n    if (isSubscription) {\n      this._checkError(response.params.error);\n\n      return response.params.result;\n    }\n\n    return response.result;\n  }\n\n  encodeJson(method, params) {\n    return JSON.stringify(this.encodeObject(method, params));\n  }\n\n  encodeObject(method, params) {\n    return {\n      id: ++_classPrivateFieldLooseBase(this, _id)[_id],\n      jsonrpc: '2.0',\n      method,\n      params\n    };\n  }\n\n  getId() {\n    return _classPrivateFieldLooseBase(this, _id)[_id];\n  }\n\n  _checkError(error) {\n    if (error) {\n      const {\n        code,\n        data,\n        message\n      } = error;\n      throw new Error(`${code}: ${message}${formatErrorData(data)}`);\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/bmacer/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/rpc-provider/coder/index.mjs"],"names":["_classPrivateFieldLooseBase","_classPrivateFieldLooseKey","assert","isNumber","isString","isUndefined","formatErrorData","data","formatted","replace","JSON","stringify","length","substr","_id","RpcCoder","constructor","Object","defineProperty","writable","value","decodeResponse","response","jsonrpc","isSubscription","params","method","id","subscription","_checkError","error","result","encodeJson","encodeObject","getId","code","message","Error"],"mappings":"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","sourcesContent":["import _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n// Copyright 2017-2021 @polkadot/rpc-provider authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isNumber, isString, isUndefined } from '@polkadot/util';\n\nfunction formatErrorData(data) {\n  if (isUndefined(data)) {\n    return '';\n  }\n\n  const formatted = `: ${isString(data) ? data.replace(/Error\\(\"/g, '').replace(/\\(\"/g, '(').replace(/\"\\)/g, ')').replace(/\\(/g, ', ').replace(/\\)/g, '') : JSON.stringify(data)}`; // We need some sort of cut-off here since these can be very large and\n  // very nested, pick a number and trim the result display to it\n\n  return formatted.length <= 256 ? formatted : `${formatted.substr(0, 255)}…`;\n}\n/** @internal */\n\n\nvar _id = _classPrivateFieldLooseKey(\"id\");\n\nexport class RpcCoder {\n  constructor() {\n    Object.defineProperty(this, _id, {\n      writable: true,\n      value: 0\n    });\n  }\n\n  decodeResponse(response) {\n    assert(response, 'Empty response object received');\n    assert(response.jsonrpc === '2.0', 'Invalid jsonrpc field in decoded object');\n    const isSubscription = !isUndefined(response.params) && !isUndefined(response.method);\n    assert(isNumber(response.id) || isSubscription && (isNumber(response.params.subscription) || isString(response.params.subscription)), 'Invalid id field in decoded object');\n\n    this._checkError(response.error);\n\n    assert(!isUndefined(response.result) || isSubscription, 'No result found in JsonRpc response');\n\n    if (isSubscription) {\n      this._checkError(response.params.error);\n\n      return response.params.result;\n    }\n\n    return response.result;\n  }\n\n  encodeJson(method, params) {\n    return JSON.stringify(this.encodeObject(method, params));\n  }\n\n  encodeObject(method, params) {\n    return {\n      id: ++_classPrivateFieldLooseBase(this, _id)[_id],\n      jsonrpc: '2.0',\n      method,\n      params\n    };\n  }\n\n  getId() {\n    return _classPrivateFieldLooseBase(this, _id)[_id];\n  }\n\n  _checkError(error) {\n    if (error) {\n      const {\n        code,\n        data,\n        message\n      } = error;\n      throw new Error(`${code}: ${message}${formatErrorData(data)}`);\n    }\n  }\n\n}"]},"metadata":{},"sourceType":"module"}