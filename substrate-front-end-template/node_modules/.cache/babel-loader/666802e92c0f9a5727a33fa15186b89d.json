{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/metadata authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { getModuleTypes } from '@polkadot/types-known';\nimport { stringCamelCase } from '@polkadot/util'; // Since we don't have insight into the origin specification, we can only define what we know about\n// in a pure Substrate/Polkadot implementation, any other custom origins won't be handled at all\n\nconst KNOWN_ORIGINS = {\n  Council: 'CollectiveOrigin',\n  System: 'SystemOrigin',\n  TechnicalCommittee: 'CollectiveOrigin'\n};\n/**\n * Find and apply the correct type override\n * @internal\n **/\n\nfunction setTypeOverride(sectionTypes, type) {\n  const override = Object.keys(sectionTypes).find(aliased => type.eq(aliased));\n\n  if (override) {\n    type.setOverride(sectionTypes[override]);\n  } else {\n    // FIXME: NOT happy with this approach, but gets over the initial hump cased by (Vec<Announcement>,BalanceOf)\n    const orig = type.toString();\n    const alias = Object.entries(sectionTypes).reduce((result, [from, to]) => [['<', '>'], ['<', ','], [',', '>'], ['(', ')'], ['(', ','], [',', ','], [',', ')']].reduce((result, [one, two]) => result.replace(`${one}${from}${two}`, `${one}${to}${two}`), result), orig);\n\n    if (orig !== alias) {\n      type.setOverride(alias);\n    }\n  }\n}\n/**\n * Apply module-specific type overrides (always be done as part of toLatest)\n * @internal\n **/\n\n\nfunction convertCalls(registry, calls, sectionTypes) {\n  return calls.map(c => {\n    c.args.forEach(({\n      type\n    }) => setTypeOverride(sectionTypes, type));\n    return registry.createType('FunctionMetadataLatest', c);\n  });\n}\n/**\n * Apply module-specific type overrides (always be done as part of toLatest)\n * @internal\n */\n\n\nfunction convertConstants(registry, constants, sectionTypes) {\n  return constants.map(c => {\n    setTypeOverride(sectionTypes, c.type);\n    return registry.createType('ModuleConstantMetadataLatest', c);\n  });\n}\n/**\n * Apply module-specific type overrides (always be done as part of toLatest)\n * @internal\n **/\n\n\nfunction convertEvents(registry, events, sectionTypes) {\n  return events.map(e => {\n    e.args.forEach(type => setTypeOverride(sectionTypes, type));\n    return registry.createType('EventMetadataLatest', e);\n  });\n}\n/**\n * Apply module-specific storage type overrides (always part of toLatest)\n * @internal\n **/\n\n\nfunction convertStorage(registry, {\n  items,\n  prefix\n}, sectionTypes) {\n  return registry.createType('StorageMetadataLatest', {\n    items: items.map(s => {\n      let resultType;\n\n      if (s.type.isMap) {\n        resultType = s.type.asMap.value;\n      } else if (s.type.isDoubleMap) {\n        resultType = s.type.asDoubleMap.value;\n      } else {\n        resultType = s.type.asPlain;\n      }\n\n      setTypeOverride(sectionTypes, resultType);\n      return registry.createType('StorageEntryMetadataLatest', s);\n    }),\n    prefix\n  });\n} // generate & register the OriginCaller type\n\n\nfunction registerOriginCaller(registry, modules, metaVersion) {\n  registry.register({\n    OriginCaller: {\n      _enum: modules.map((mod, index) => [mod.name.toString(), metaVersion >= 12 ? mod.index.toNumber() : index]).sort((a, b) => a[1] - b[1]).reduce((result, [name, index]) => {\n        for (let i = Object.keys(result).length; i < index; i++) {\n          result[`Empty${i}`] = 'Null';\n        }\n\n        result[name] = KNOWN_ORIGINS[name] || 'Null';\n        return result;\n      }, {})\n    }\n  });\n}\n/** @internal */\n\n\nfunction createModule(registry, mod, {\n  calls,\n  constants,\n  events,\n  storage\n}) {\n  const sectionTypes = getModuleTypes(registry, stringCamelCase(mod.name));\n  return registry.createType('ModuleMetadataLatest', _objectSpread(_objectSpread({}, mod), {}, {\n    calls: calls && convertCalls(registry, calls, sectionTypes),\n    constants: convertConstants(registry, constants, sectionTypes),\n    events: events && convertEvents(registry, events, sectionTypes),\n    storage: storage && convertStorage(registry, storage, sectionTypes)\n  }));\n}\n/**\n * Convert the Metadata (which is an alias) to latest - effectively this _always_ get applied to the top-level &\n * most-recent metadata, since it allows us a chance to actually apply call and storage specific type aliasses\n * @internal\n **/\n\n\nexport function toLatest(registry, {\n  extrinsic,\n  modules\n}, metaVersion) {\n  registerOriginCaller(registry, modules, metaVersion);\n  return registry.createType('MetadataLatest', {\n    extrinsic,\n    modules: modules.map(mod => createModule(registry, mod, {\n      calls: mod.calls.unwrapOr(null),\n      constants: mod.constants,\n      events: mod.events.unwrapOr(null),\n      storage: mod.storage.unwrapOr(null)\n    }))\n  });\n}","map":{"version":3,"sources":["/Users/bmacer/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/metadata/v12/toLatest.mjs"],"names":["_defineProperty","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","getModuleTypes","stringCamelCase","KNOWN_ORIGINS","Council","System","TechnicalCommittee","setTypeOverride","sectionTypes","type","override","find","aliased","eq","setOverride","orig","toString","alias","entries","reduce","result","from","to","one","two","replace","convertCalls","registry","calls","map","c","args","createType","convertConstants","constants","convertEvents","events","e","convertStorage","items","prefix","s","resultType","isMap","asMap","value","isDoubleMap","asDoubleMap","asPlain","registerOriginCaller","modules","metaVersion","register","OriginCaller","_enum","mod","index","name","toNumber","sort","a","b","createModule","storage","toLatest","extrinsic","unwrapOr"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/metadata authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { getModuleTypes } from '@polkadot/types-known';\nimport { stringCamelCase } from '@polkadot/util'; // Since we don't have insight into the origin specification, we can only define what we know about\n// in a pure Substrate/Polkadot implementation, any other custom origins won't be handled at all\n\nconst KNOWN_ORIGINS = {\n  Council: 'CollectiveOrigin',\n  System: 'SystemOrigin',\n  TechnicalCommittee: 'CollectiveOrigin'\n};\n/**\n * Find and apply the correct type override\n * @internal\n **/\n\nfunction setTypeOverride(sectionTypes, type) {\n  const override = Object.keys(sectionTypes).find(aliased => type.eq(aliased));\n\n  if (override) {\n    type.setOverride(sectionTypes[override]);\n  } else {\n    // FIXME: NOT happy with this approach, but gets over the initial hump cased by (Vec<Announcement>,BalanceOf)\n    const orig = type.toString();\n    const alias = Object.entries(sectionTypes).reduce((result, [from, to]) => [['<', '>'], ['<', ','], [',', '>'], ['(', ')'], ['(', ','], [',', ','], [',', ')']].reduce((result, [one, two]) => result.replace(`${one}${from}${two}`, `${one}${to}${two}`), result), orig);\n\n    if (orig !== alias) {\n      type.setOverride(alias);\n    }\n  }\n}\n/**\n * Apply module-specific type overrides (always be done as part of toLatest)\n * @internal\n **/\n\n\nfunction convertCalls(registry, calls, sectionTypes) {\n  return calls.map(c => {\n    c.args.forEach(({\n      type\n    }) => setTypeOverride(sectionTypes, type));\n    return registry.createType('FunctionMetadataLatest', c);\n  });\n}\n/**\n * Apply module-specific type overrides (always be done as part of toLatest)\n * @internal\n */\n\n\nfunction convertConstants(registry, constants, sectionTypes) {\n  return constants.map(c => {\n    setTypeOverride(sectionTypes, c.type);\n    return registry.createType('ModuleConstantMetadataLatest', c);\n  });\n}\n/**\n * Apply module-specific type overrides (always be done as part of toLatest)\n * @internal\n **/\n\n\nfunction convertEvents(registry, events, sectionTypes) {\n  return events.map(e => {\n    e.args.forEach(type => setTypeOverride(sectionTypes, type));\n    return registry.createType('EventMetadataLatest', e);\n  });\n}\n/**\n * Apply module-specific storage type overrides (always part of toLatest)\n * @internal\n **/\n\n\nfunction convertStorage(registry, {\n  items,\n  prefix\n}, sectionTypes) {\n  return registry.createType('StorageMetadataLatest', {\n    items: items.map(s => {\n      let resultType;\n\n      if (s.type.isMap) {\n        resultType = s.type.asMap.value;\n      } else if (s.type.isDoubleMap) {\n        resultType = s.type.asDoubleMap.value;\n      } else {\n        resultType = s.type.asPlain;\n      }\n\n      setTypeOverride(sectionTypes, resultType);\n      return registry.createType('StorageEntryMetadataLatest', s);\n    }),\n    prefix\n  });\n} // generate & register the OriginCaller type\n\n\nfunction registerOriginCaller(registry, modules, metaVersion) {\n  registry.register({\n    OriginCaller: {\n      _enum: modules.map((mod, index) => [mod.name.toString(), metaVersion >= 12 ? mod.index.toNumber() : index]).sort((a, b) => a[1] - b[1]).reduce((result, [name, index]) => {\n        for (let i = Object.keys(result).length; i < index; i++) {\n          result[`Empty${i}`] = 'Null';\n        }\n\n        result[name] = KNOWN_ORIGINS[name] || 'Null';\n        return result;\n      }, {})\n    }\n  });\n}\n/** @internal */\n\n\nfunction createModule(registry, mod, {\n  calls,\n  constants,\n  events,\n  storage\n}) {\n  const sectionTypes = getModuleTypes(registry, stringCamelCase(mod.name));\n  return registry.createType('ModuleMetadataLatest', _objectSpread(_objectSpread({}, mod), {}, {\n    calls: calls && convertCalls(registry, calls, sectionTypes),\n    constants: convertConstants(registry, constants, sectionTypes),\n    events: events && convertEvents(registry, events, sectionTypes),\n    storage: storage && convertStorage(registry, storage, sectionTypes)\n  }));\n}\n/**\n * Convert the Metadata (which is an alias) to latest - effectively this _always_ get applied to the top-level &\n * most-recent metadata, since it allows us a chance to actually apply call and storage specific type aliasses\n * @internal\n **/\n\n\nexport function toLatest(registry, {\n  extrinsic,\n  modules\n}, metaVersion) {\n  registerOriginCaller(registry, modules, metaVersion);\n  return registry.createType('MetadataLatest', {\n    extrinsic,\n    modules: modules.map(mod => createModule(registry, mod, {\n      calls: mod.calls.unwrapOr(null),\n      constants: mod.constants,\n      events: mod.events.unwrapOr(null),\n      storage: mod.storage.unwrapOr(null)\n    }))\n  });\n}"]},"metadata":{},"sourceType":"module"}