{"ast":null,"code":"// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert } from '@polkadot/util';\nimport { sanitize } from \"./sanitize.mjs\";\nimport { TypeDefInfo } from \"./types.mjs\";\nimport { typeSplit } from \"./typeSplit.mjs\";\nconst MAX_NESTED = 64; // decode an enum of either of the following forms\n//  { _enum: ['A', 'B', 'C'] }\n//  { _enum: { A: AccountId, B: Balance, C: u32 } }\n\nfunction _decodeEnum(value, details, count) {\n  value.info = TypeDefInfo.Enum; // not as pretty, but remain compatible with oo7 for both struct and Array types\n\n  value.sub = Array.isArray(details) ? details.map(name => ({\n    info: TypeDefInfo.Plain,\n    name,\n    type: 'Null'\n  })) : Object.entries(details).map(([name, type]) => // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  getTypeDef(type || 'Null', {\n    name\n  }, count));\n  return value;\n} // decode a set of the form\n//   { _set: { A: 0b0001, B: 0b0010, C: 0b0100 } }\n\n\nfunction _decodeSet(value, details) {\n  value.info = TypeDefInfo.Set;\n  value.length = details._bitLength;\n  value.sub = Object.entries(details).filter(([name]) => !name.startsWith('_')).map(([name, index]) => ({\n    index,\n    info: TypeDefInfo.Plain,\n    name,\n    type: name\n  }));\n  return value;\n} // decode a struct, set or enum\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeStruct(value, type, _, count) {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  const parsed = JSON.parse(type);\n  const keys = Object.keys(parsed);\n\n  if (keys.length === 1 && keys[0] === '_enum') {\n    return _decodeEnum(value, parsed[keys[0]], count);\n  } else if (keys.length === 1 && keys[0] === '_set') {\n    return _decodeSet(value, parsed[keys[0]]);\n  }\n\n  value.alias = parsed._alias ? new Map(Object.entries(parsed._alias)) : undefined;\n  value.sub = keys.filter(name => !['_alias'].includes(name)).map(name => // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  getTypeDef(parsed[name], {\n    name\n  }, count));\n  return value;\n} // decode a fixed vector, e.g. [u8;32]\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeFixedVec(value, type, _, count) {\n  const [vecType, strLength, displayName] = type.substr(1, type.length - 2).split(';');\n  const length = parseInt(strLength.trim(), 10); // as a first round, only u8 via u8aFixed, we can add more support\n\n  assert(length <= 256, `${type}: Only support for [Type; <length>], where length <= 256`);\n  value.displayName = displayName;\n  value.length = length; // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n  value.sub = getTypeDef(vecType, {}, count);\n  return value;\n} // decode a tuple\n\n\nfunction _decodeTuple(value, _, subType, count) {\n  value.sub = subType.length === 0 ? [] // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  : typeSplit(subType).map(inner => getTypeDef(inner, {}, count));\n  return value;\n} // decode a Int/UInt<bitLength[, name]>\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeAnyInt(value, type, _, clazz) {\n  const [strLength, displayName] = type.substr(clazz.length + 1, type.length - clazz.length - 1 - 1).split(',');\n  const length = parseInt(strLength.trim(), 10); // as a first round, only u8 via u8aFixed, we can add more support\n\n  assert(length <= 8192 && length % 8 === 0, `${type}: Only support for ${clazz}<bitLength>, where length <= 8192 and a power of 8, found ${length}`);\n  value.displayName = displayName;\n  value.length = length;\n  return value;\n}\n\nfunction _decodeInt(value, type, subType) {\n  return _decodeAnyInt(value, type, subType, 'Int');\n}\n\nfunction _decodeUInt(value, type, subType) {\n  return _decodeAnyInt(value, type, subType, 'UInt');\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeDoNotConstruct(value, type, _) {\n  const NAME_LENGTH = 'DoNotConstruct'.length;\n  value.displayName = type.substr(NAME_LENGTH + 1, type.length - NAME_LENGTH - 1 - 1);\n  return value;\n}\n\nfunction hasWrapper(type, [start, end]) {\n  return type.substr(0, start.length) === start && type.substr(-1 * end.length) === end;\n}\n\nconst nestedExtraction = [['[', ']', TypeDefInfo.VecFixed, _decodeFixedVec], ['{', '}', TypeDefInfo.Struct, _decodeStruct], ['(', ')', TypeDefInfo.Tuple, _decodeTuple], // the inner for these are the same as tuple, multiple values\n['BTreeMap<', '>', TypeDefInfo.BTreeMap, _decodeTuple], ['HashMap<', '>', TypeDefInfo.HashMap, _decodeTuple], ['Int<', '>', TypeDefInfo.Int, _decodeInt], ['Result<', '>', TypeDefInfo.Result, _decodeTuple], ['UInt<', '>', TypeDefInfo.UInt, _decodeUInt], ['DoNotConstruct<', '>', TypeDefInfo.DoNotConstruct, _decodeDoNotConstruct]];\nconst wrappedExtraction = [['BTreeSet<', '>', TypeDefInfo.BTreeSet], ['Compact<', '>', TypeDefInfo.Compact], ['Linkage<', '>', TypeDefInfo.Linkage], ['Option<', '>', TypeDefInfo.Option], ['Vec<', '>', TypeDefInfo.Vec]];\n\nfunction extractSubType(type, [start, end]) {\n  return type.substr(start.length, type.length - start.length - end.length);\n} // eslint-disable-next-line @typescript-eslint/ban-types\n\n\nexport function getTypeDef(_type, {\n  displayName,\n  name\n} = {}, count = 0) {\n  // create the type via Type, allowing types to be sanitized\n  const type = sanitize(_type);\n  const value = {\n    displayName,\n    info: TypeDefInfo.Plain,\n    name,\n    type\n  };\n  assert(++count !== MAX_NESTED, 'getTypeDef: Maximum nested limit reached');\n  const nested = nestedExtraction.find(nested => hasWrapper(type, nested));\n\n  if (nested) {\n    value.info = nested[2];\n    return nested[3](value, type, extractSubType(type, nested), count);\n  }\n\n  const wrapped = wrappedExtraction.find(wrapped => hasWrapper(type, wrapped));\n\n  if (wrapped) {\n    value.info = wrapped[2];\n    value.sub = getTypeDef(extractSubType(type, wrapped), {}, count);\n  }\n\n  return value;\n}","map":{"version":3,"sources":["/Users/bmacer/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/types/create/getTypeDef.mjs"],"names":["assert","sanitize","TypeDefInfo","typeSplit","MAX_NESTED","_decodeEnum","value","details","count","info","Enum","sub","Array","isArray","map","name","Plain","type","Object","entries","getTypeDef","_decodeSet","Set","length","_bitLength","filter","startsWith","index","_decodeStruct","_","parsed","JSON","parse","keys","alias","_alias","Map","undefined","includes","_decodeFixedVec","vecType","strLength","displayName","substr","split","parseInt","trim","_decodeTuple","subType","inner","_decodeAnyInt","clazz","_decodeInt","_decodeUInt","_decodeDoNotConstruct","NAME_LENGTH","hasWrapper","start","end","nestedExtraction","VecFixed","Struct","Tuple","BTreeMap","HashMap","Int","Result","UInt","DoNotConstruct","wrappedExtraction","BTreeSet","Compact","Linkage","Option","Vec","extractSubType","_type","nested","find","wrapped"],"mappings":"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","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert } from '@polkadot/util';\nimport { sanitize } from \"./sanitize.mjs\";\nimport { TypeDefInfo } from \"./types.mjs\";\nimport { typeSplit } from \"./typeSplit.mjs\";\nconst MAX_NESTED = 64; // decode an enum of either of the following forms\n//  { _enum: ['A', 'B', 'C'] }\n//  { _enum: { A: AccountId, B: Balance, C: u32 } }\n\nfunction _decodeEnum(value, details, count) {\n  value.info = TypeDefInfo.Enum; // not as pretty, but remain compatible with oo7 for both struct and Array types\n\n  value.sub = Array.isArray(details) ? details.map(name => ({\n    info: TypeDefInfo.Plain,\n    name,\n    type: 'Null'\n  })) : Object.entries(details).map(([name, type]) => // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  getTypeDef(type || 'Null', {\n    name\n  }, count));\n  return value;\n} // decode a set of the form\n//   { _set: { A: 0b0001, B: 0b0010, C: 0b0100 } }\n\n\nfunction _decodeSet(value, details) {\n  value.info = TypeDefInfo.Set;\n  value.length = details._bitLength;\n  value.sub = Object.entries(details).filter(([name]) => !name.startsWith('_')).map(([name, index]) => ({\n    index,\n    info: TypeDefInfo.Plain,\n    name,\n    type: name\n  }));\n  return value;\n} // decode a struct, set or enum\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeStruct(value, type, _, count) {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  const parsed = JSON.parse(type);\n  const keys = Object.keys(parsed);\n\n  if (keys.length === 1 && keys[0] === '_enum') {\n    return _decodeEnum(value, parsed[keys[0]], count);\n  } else if (keys.length === 1 && keys[0] === '_set') {\n    return _decodeSet(value, parsed[keys[0]]);\n  }\n\n  value.alias = parsed._alias ? new Map(Object.entries(parsed._alias)) : undefined;\n  value.sub = keys.filter(name => !['_alias'].includes(name)).map(name => // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  getTypeDef(parsed[name], {\n    name\n  }, count));\n  return value;\n} // decode a fixed vector, e.g. [u8;32]\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeFixedVec(value, type, _, count) {\n  const [vecType, strLength, displayName] = type.substr(1, type.length - 2).split(';');\n  const length = parseInt(strLength.trim(), 10); // as a first round, only u8 via u8aFixed, we can add more support\n\n  assert(length <= 256, `${type}: Only support for [Type; <length>], where length <= 256`);\n  value.displayName = displayName;\n  value.length = length; // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n  value.sub = getTypeDef(vecType, {}, count);\n  return value;\n} // decode a tuple\n\n\nfunction _decodeTuple(value, _, subType, count) {\n  value.sub = subType.length === 0 ? [] // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  : typeSplit(subType).map(inner => getTypeDef(inner, {}, count));\n  return value;\n} // decode a Int/UInt<bitLength[, name]>\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeAnyInt(value, type, _, clazz) {\n  const [strLength, displayName] = type.substr(clazz.length + 1, type.length - clazz.length - 1 - 1).split(',');\n  const length = parseInt(strLength.trim(), 10); // as a first round, only u8 via u8aFixed, we can add more support\n\n  assert(length <= 8192 && length % 8 === 0, `${type}: Only support for ${clazz}<bitLength>, where length <= 8192 and a power of 8, found ${length}`);\n  value.displayName = displayName;\n  value.length = length;\n  return value;\n}\n\nfunction _decodeInt(value, type, subType) {\n  return _decodeAnyInt(value, type, subType, 'Int');\n}\n\nfunction _decodeUInt(value, type, subType) {\n  return _decodeAnyInt(value, type, subType, 'UInt');\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeDoNotConstruct(value, type, _) {\n  const NAME_LENGTH = 'DoNotConstruct'.length;\n  value.displayName = type.substr(NAME_LENGTH + 1, type.length - NAME_LENGTH - 1 - 1);\n  return value;\n}\n\nfunction hasWrapper(type, [start, end]) {\n  return type.substr(0, start.length) === start && type.substr(-1 * end.length) === end;\n}\n\nconst nestedExtraction = [['[', ']', TypeDefInfo.VecFixed, _decodeFixedVec], ['{', '}', TypeDefInfo.Struct, _decodeStruct], ['(', ')', TypeDefInfo.Tuple, _decodeTuple], // the inner for these are the same as tuple, multiple values\n['BTreeMap<', '>', TypeDefInfo.BTreeMap, _decodeTuple], ['HashMap<', '>', TypeDefInfo.HashMap, _decodeTuple], ['Int<', '>', TypeDefInfo.Int, _decodeInt], ['Result<', '>', TypeDefInfo.Result, _decodeTuple], ['UInt<', '>', TypeDefInfo.UInt, _decodeUInt], ['DoNotConstruct<', '>', TypeDefInfo.DoNotConstruct, _decodeDoNotConstruct]];\nconst wrappedExtraction = [['BTreeSet<', '>', TypeDefInfo.BTreeSet], ['Compact<', '>', TypeDefInfo.Compact], ['Linkage<', '>', TypeDefInfo.Linkage], ['Option<', '>', TypeDefInfo.Option], ['Vec<', '>', TypeDefInfo.Vec]];\n\nfunction extractSubType(type, [start, end]) {\n  return type.substr(start.length, type.length - start.length - end.length);\n} // eslint-disable-next-line @typescript-eslint/ban-types\n\n\nexport function getTypeDef(_type, {\n  displayName,\n  name\n} = {}, count = 0) {\n  // create the type via Type, allowing types to be sanitized\n  const type = sanitize(_type);\n  const value = {\n    displayName,\n    info: TypeDefInfo.Plain,\n    name,\n    type\n  };\n  assert(++count !== MAX_NESTED, 'getTypeDef: Maximum nested limit reached');\n  const nested = nestedExtraction.find(nested => hasWrapper(type, nested));\n\n  if (nested) {\n    value.info = nested[2];\n    return nested[3](value, type, extractSubType(type, nested), count);\n  }\n\n  const wrapped = wrappedExtraction.find(wrapped => hasWrapper(type, wrapped));\n\n  if (wrapped) {\n    value.info = wrapped[2];\n    value.sub = getTypeDef(extractSubType(type, wrapped), {}, count);\n  }\n\n  return value;\n}"]},"metadata":{},"sourceType":"module"}