{"ast":null,"code":"// Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { combineLatest, of } from '@polkadot/x-rxjs';\nimport { map, take } from '@polkadot/x-rxjs/operators'; // the order and types needs to map with the all array setup below\n\nfunction mapCapabilities([systemRefcount32, systemRefcountDual, stakingVersion]) {\n  const types = {}; // AccountInfo\n\n  if (systemRefcountDual && systemRefcountDual.isTrue) {\n    types.AccountInfo = 'AccountInfoWithProviders';\n  } else if (systemRefcount32 && systemRefcount32.isTrue) {\n    types.AccountInfo = 'AccountInfoWithRefCount';\n  } // ValidatorPrefs\n\n\n  if (stakingVersion) {\n    if (stakingVersion.index >= 4) {\n      // v1 = index 0, V5 = index 4\n      types.ValidatorPrefs = 'ValidatorPrefsWithBlocked';\n    } else {\n      types.ValidatorPrefs = 'ValidatorPrefsWithCommission';\n    }\n  }\n\n  return types;\n}\n/**\n * @description Query the chain for the specific capabilities\n */\n\n\nexport function detectedCapabilities(api, blockHash) {\n  var _api$query$system, _api$query$system2, _api$query$staking;\n\n  const all = [(_api$query$system = api.query.system) === null || _api$query$system === void 0 ? void 0 : _api$query$system.upgradedToU32RefCount, (_api$query$system2 = api.query.system) === null || _api$query$system2 === void 0 ? void 0 : _api$query$system2.upgradedToDualRefCount, (_api$query$staking = api.query.staking) === null || _api$query$staking === void 0 ? void 0 : _api$query$staking.storageVersion];\n  const included = all.map(c => !!c);\n  const filtered = all.filter((_, index) => included[index]);\n  return (filtered.length ? blockHash ? combineLatest(filtered.map(c => c.at(blockHash))) : api.queryMulti(filtered) : of([])).pipe(map(results => {\n    let offset = -1;\n    return mapCapabilities(included.map(isIncluded => isIncluded ? results[++offset] : null));\n  }), take(1));\n}","map":{"version":3,"sources":["/Users/bmacer/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/api/base/util.mjs"],"names":["combineLatest","of","map","take","mapCapabilities","systemRefcount32","systemRefcountDual","stakingVersion","types","isTrue","AccountInfo","index","ValidatorPrefs","detectedCapabilities","api","blockHash","_api$query$system","_api$query$system2","_api$query$staking","all","query","system","upgradedToU32RefCount","upgradedToDualRefCount","staking","storageVersion","included","c","filtered","filter","_","length","at","queryMulti","pipe","results","offset","isIncluded"],"mappings":"AAAA;AACA;AACA,SAASA,aAAT,EAAwBC,EAAxB,QAAkC,kBAAlC;AACA,SAASC,GAAT,EAAcC,IAAd,QAA0B,4BAA1B,C,CAAwD;;AAExD,SAASC,eAAT,CAAyB,CAACC,gBAAD,EAAmBC,kBAAnB,EAAuCC,cAAvC,CAAzB,EAAiF;AAC/E,QAAMC,KAAK,GAAG,EAAd,CAD+E,CAC7D;;AAElB,MAAIF,kBAAkB,IAAIA,kBAAkB,CAACG,MAA7C,EAAqD;AACnDD,IAAAA,KAAK,CAACE,WAAN,GAAoB,0BAApB;AACD,GAFD,MAEO,IAAIL,gBAAgB,IAAIA,gBAAgB,CAACI,MAAzC,EAAiD;AACtDD,IAAAA,KAAK,CAACE,WAAN,GAAoB,yBAApB;AACD,GAP8E,CAO7E;;;AAGF,MAAIH,cAAJ,EAAoB;AAClB,QAAIA,cAAc,CAACI,KAAf,IAAwB,CAA5B,EAA+B;AAC7B;AACAH,MAAAA,KAAK,CAACI,cAAN,GAAuB,2BAAvB;AACD,KAHD,MAGO;AACLJ,MAAAA,KAAK,CAACI,cAAN,GAAuB,8BAAvB;AACD;AACF;;AAED,SAAOJ,KAAP;AACD;AACD;AACA;AACA;;;AAGA,OAAO,SAASK,oBAAT,CAA8BC,GAA9B,EAAmCC,SAAnC,EAA8C;AACnD,MAAIC,iBAAJ,EAAuBC,kBAAvB,EAA2CC,kBAA3C;;AAEA,QAAMC,GAAG,GAAG,CAAC,CAACH,iBAAiB,GAAGF,GAAG,CAACM,KAAJ,CAAUC,MAA/B,MAA2C,IAA3C,IAAmDL,iBAAiB,KAAK,KAAK,CAA9E,GAAkF,KAAK,CAAvF,GAA2FA,iBAAiB,CAACM,qBAA9G,EAAqI,CAACL,kBAAkB,GAAGH,GAAG,CAACM,KAAJ,CAAUC,MAAhC,MAA4C,IAA5C,IAAoDJ,kBAAkB,KAAK,KAAK,CAAhF,GAAoF,KAAK,CAAzF,GAA6FA,kBAAkB,CAACM,sBAArP,EAA6Q,CAACL,kBAAkB,GAAGJ,GAAG,CAACM,KAAJ,CAAUI,OAAhC,MAA6C,IAA7C,IAAqDN,kBAAkB,KAAK,KAAK,CAAjF,GAAqF,KAAK,CAA1F,GAA8FA,kBAAkB,CAACO,cAA9X,CAAZ;AACA,QAAMC,QAAQ,GAAGP,GAAG,CAACjB,GAAJ,CAAQyB,CAAC,IAAI,CAAC,CAACA,CAAf,CAAjB;AACA,QAAMC,QAAQ,GAAGT,GAAG,CAACU,MAAJ,CAAW,CAACC,CAAD,EAAInB,KAAJ,KAAce,QAAQ,CAACf,KAAD,CAAjC,CAAjB;AACA,SAAO,CAACiB,QAAQ,CAACG,MAAT,GAAkBhB,SAAS,GAAGf,aAAa,CAAC4B,QAAQ,CAAC1B,GAAT,CAAayB,CAAC,IAAIA,CAAC,CAACK,EAAF,CAAKjB,SAAL,CAAlB,CAAD,CAAhB,GAAuDD,GAAG,CAACmB,UAAJ,CAAeL,QAAf,CAAlF,GAA6G3B,EAAE,CAAC,EAAD,CAAhH,EAAsHiC,IAAtH,CAA2HhC,GAAG,CAACiC,OAAO,IAAI;AAC/I,QAAIC,MAAM,GAAG,CAAC,CAAd;AACA,WAAOhC,eAAe,CAACsB,QAAQ,CAACxB,GAAT,CAAamC,UAAU,IAAIA,UAAU,GAAGF,OAAO,CAAC,EAAEC,MAAH,CAAV,GAAuB,IAA5D,CAAD,CAAtB;AACD,GAHoI,CAA9H,EAGHjC,IAAI,CAAC,CAAD,CAHD,CAAP;AAID","sourcesContent":["// Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { combineLatest, of } from '@polkadot/x-rxjs';\nimport { map, take } from '@polkadot/x-rxjs/operators'; // the order and types needs to map with the all array setup below\n\nfunction mapCapabilities([systemRefcount32, systemRefcountDual, stakingVersion]) {\n  const types = {}; // AccountInfo\n\n  if (systemRefcountDual && systemRefcountDual.isTrue) {\n    types.AccountInfo = 'AccountInfoWithProviders';\n  } else if (systemRefcount32 && systemRefcount32.isTrue) {\n    types.AccountInfo = 'AccountInfoWithRefCount';\n  } // ValidatorPrefs\n\n\n  if (stakingVersion) {\n    if (stakingVersion.index >= 4) {\n      // v1 = index 0, V5 = index 4\n      types.ValidatorPrefs = 'ValidatorPrefsWithBlocked';\n    } else {\n      types.ValidatorPrefs = 'ValidatorPrefsWithCommission';\n    }\n  }\n\n  return types;\n}\n/**\n * @description Query the chain for the specific capabilities\n */\n\n\nexport function detectedCapabilities(api, blockHash) {\n  var _api$query$system, _api$query$system2, _api$query$staking;\n\n  const all = [(_api$query$system = api.query.system) === null || _api$query$system === void 0 ? void 0 : _api$query$system.upgradedToU32RefCount, (_api$query$system2 = api.query.system) === null || _api$query$system2 === void 0 ? void 0 : _api$query$system2.upgradedToDualRefCount, (_api$query$staking = api.query.staking) === null || _api$query$staking === void 0 ? void 0 : _api$query$staking.storageVersion];\n  const included = all.map(c => !!c);\n  const filtered = all.filter((_, index) => included[index]);\n  return (filtered.length ? blockHash ? combineLatest(filtered.map(c => c.at(blockHash))) : api.queryMulti(filtered) : of([])).pipe(map(results => {\n    let offset = -1;\n    return mapCapabilities(included.map(isIncluded => isIncluded ? results[++offset] : null));\n  }), take(1));\n}"]},"metadata":{},"sourceType":"module"}