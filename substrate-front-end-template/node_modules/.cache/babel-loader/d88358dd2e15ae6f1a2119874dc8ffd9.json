{"ast":null,"code":"// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Given an u8a, and an array of Type constructors, decode the u8a against the\n * types, and return an array of decoded values.\n *\n * @param u8a - The u8a to decode.\n * @param types - The array of Constructor to decode the U8a against.\n */\nexport function decodeU8a(registry, u8a, _types) {\n  const types = Array.isArray(_types) ? _types : Object.values(_types);\n  const result = [];\n  let offset = 0;\n\n  for (let i = 0; i < types.length; i++) {\n    const value = new types[i](registry, u8a.subarray(offset));\n    result.push(value);\n    offset += value.encodedLength;\n  }\n\n  return result;\n}","map":{"version":3,"sources":["/Users/bmacer/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/types/codec/utils/decodeU8a.mjs"],"names":["decodeU8a","registry","u8a","_types","types","Array","isArray","Object","values","result","offset","i","length","value","subarray","push","encodedLength"],"mappings":"AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,SAAT,CAAmBC,QAAnB,EAA6BC,GAA7B,EAAkCC,MAAlC,EAA0C;AAC/C,QAAMC,KAAK,GAAGC,KAAK,CAACC,OAAN,CAAcH,MAAd,IAAwBA,MAAxB,GAAiCI,MAAM,CAACC,MAAP,CAAcL,MAAd,CAA/C;AACA,QAAMM,MAAM,GAAG,EAAf;AACA,MAAIC,MAAM,GAAG,CAAb;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,KAAK,CAACQ,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AACrC,UAAME,KAAK,GAAG,IAAIT,KAAK,CAACO,CAAD,CAAT,CAAaV,QAAb,EAAuBC,GAAG,CAACY,QAAJ,CAAaJ,MAAb,CAAvB,CAAd;AACAD,IAAAA,MAAM,CAACM,IAAP,CAAYF,KAAZ;AACAH,IAAAA,MAAM,IAAIG,KAAK,CAACG,aAAhB;AACD;;AAED,SAAOP,MAAP;AACD","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Given an u8a, and an array of Type constructors, decode the u8a against the\n * types, and return an array of decoded values.\n *\n * @param u8a - The u8a to decode.\n * @param types - The array of Constructor to decode the U8a against.\n */\nexport function decodeU8a(registry, u8a, _types) {\n  const types = Array.isArray(_types) ? _types : Object.values(_types);\n  const result = [];\n  let offset = 0;\n\n  for (let i = 0; i < types.length; i++) {\n    const value = new types[i](registry, u8a.subarray(offset));\n    result.push(value);\n    offset += value.encodedLength;\n  }\n\n  return result;\n}"]},"metadata":{},"sourceType":"module"}