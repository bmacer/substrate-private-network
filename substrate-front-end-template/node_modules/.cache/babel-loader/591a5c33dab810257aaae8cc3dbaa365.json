{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RpcCore = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _classPrivateFieldLooseBase2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseBase\"));\n\nvar _classPrivateFieldLooseKey2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseKey\"));\n\nvar _types = require(\"@polkadot/types\");\n\nvar _create = require(\"@polkadot/types/create\");\n\nvar _jsonrpc = _interopRequireDefault(require(\"@polkadot/types/interfaces/jsonrpc\"));\n\nvar _util = require(\"@polkadot/util\");\n\nvar _xRxjs = require(\"@polkadot/x-rxjs\");\n\nvar _operators = require(\"@polkadot/x-rxjs/operators\");\n\nvar _util2 = require(\"./util\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nconst l = (0, _util.logger)('rpc-core');\nconst EMPTY_META = {\n  fallback: undefined,\n  modifier: {\n    isOptional: true\n  },\n  type: {\n    asMap: {\n      linked: {\n        isTrue: false\n      }\n    },\n    isMap: false\n  }\n}; // utility method to create a nicely-formatted error\n\n/** @internal */\n\nfunction logErrorMessage(method, {\n  params,\n  type\n}, error) {\n  const inputs = params.map(({\n    isOptional,\n    name,\n    type\n  }) => `${name}${isOptional ? '?' : ''}: ${type}`).join(', ');\n  l.error(`${method}(${inputs}): ${type}:: ${error.message}`);\n}\n\nfunction isTreatAsHex(key) {\n  // :code is problematic - it does not have the length attached, which is\n  // unlike all other storage entries where it is indeed properly encoded\n  return ['0x3a636f6465'].includes(key.toHex());\n}\n/**\n * @name Rpc\n * @summary The API may use a HTTP or WebSockets provider.\n * @description It allows for querying a Polkadot Client Node.\n * WebSockets provider is recommended since HTTP provider only supports basic querying.\n *\n * ```mermaid\n * graph LR;\n *   A[Api] --> |WebSockets| B[WsProvider];\n *   B --> |endpoint| C[ws://127.0.0.1:9944]\n * ```\n *\n * @example\n * <BR>\n *\n * ```javascript\n * import Rpc from '@polkadot/rpc-core';\n * import { WsProvider } from '@polkadot/rpc-provider/ws';\n *\n * const provider = new WsProvider('ws://127.0.0.1:9944');\n * const rpc = new Rpc(provider);\n * ```\n */\n\n\nvar _instanceId = (0, _classPrivateFieldLooseKey2.default)(\"instanceId\");\n\nvar _registryDefault = (0, _classPrivateFieldLooseKey2.default)(\"registryDefault\");\n\nvar _getBlockRegistry = (0, _classPrivateFieldLooseKey2.default)(\"getBlockRegistry\");\n\nvar _storageCache = (0, _classPrivateFieldLooseKey2.default)(\"storageCache\");\n\nclass RpcCore {\n  // Ok, this is quite horrible - we really should not be using the ! here, but we are actually assigning\n  // these via the createInterfaces inside the constructor. However... this is not quite visible. The reason\n  // why we don't do for individual assignments is to allow user-defined RPCs to also be defined\n\n  /**\n   * @constructor\n   * Default constructor for the Api Object\n   * @param  {ProviderInterface} provider An API provider using HTTP or WebSocket\n   */\n  constructor(instanceId, registry, provider, userRpc = {}) {\n    Object.defineProperty(this, _instanceId, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _registryDefault, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _getBlockRegistry, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _storageCache, {\n      writable: true,\n      value: new Map()\n    });\n    this.mapping = new Map();\n    this.provider = void 0;\n    this.sections = [];\n    this.author = void 0;\n    this.babe = void 0;\n    this.chain = void 0;\n    this.childstate = void 0;\n    this.contracts = void 0;\n    this.engine = void 0;\n    this.eth = void 0;\n    this.grandpa = void 0;\n    this.net = void 0;\n    this.offchain = void 0;\n    this.payment = void 0;\n    this.rpc = void 0;\n    this.state = void 0;\n    this.syncstate = void 0;\n    this.system = void 0;\n    this.web3 = void 0; // eslint-disable-next-line @typescript-eslint/unbound-method\n\n    (0, _util.assert)(provider && (0, _util.isFunction)(provider.send), 'Expected Provider to API create');\n    (0, _classPrivateFieldLooseBase2.default)(this, _instanceId)[_instanceId] = instanceId;\n    (0, _classPrivateFieldLooseBase2.default)(this, _registryDefault)[_registryDefault] = registry;\n    this.provider = provider;\n    const sectionNames = Object.keys(_jsonrpc.default); // these are the base keys (i.e. part of jsonrpc)\n\n    this.sections.push(...sectionNames);\n    this.addUserInterfaces(userRpc);\n  }\n  /**\n   * @description Returns the connected status of a provider\n   */\n\n\n  get isConnected() {\n    return this.provider.isConnected;\n  }\n  /**\n   * @description Manually connect from the attached provider\n   */\n\n\n  connect() {\n    return this.provider.connect();\n  }\n  /**\n   * @description Manually disconnect from the attached provider\n   */\n\n\n  disconnect() {\n    return this.provider.disconnect();\n  }\n  /**\n   * @description Sets a registry swap (typically from Api)\n   */\n\n\n  setRegistrySwap(registrySwap) {\n    (0, _classPrivateFieldLooseBase2.default)(this, _getBlockRegistry)[_getBlockRegistry] = registrySwap;\n  }\n\n  addUserInterfaces(userRpc) {\n    // add any extra user-defined sections\n    this.sections.push(...Object.keys(userRpc).filter(key => !this.sections.includes(key))); // decorate the sections with base and user methods\n\n    this.sections.forEach(sectionName => {\n      var _ref, _ref2;\n\n      (_ref = this)[_ref2 = sectionName] || (_ref[_ref2] = {});\n      const section = this[sectionName];\n      Object.entries(_objectSpread(_objectSpread({}, this._createInterface(sectionName, _jsonrpc.default[sectionName] || {})), this._createInterface(sectionName, userRpc[sectionName] || {}))).forEach(([key, value]) => {\n        section[key] || (section[key] = value);\n      });\n    });\n  }\n\n  _createInterface(section, methods) {\n    return Object.entries(methods).filter(([method, {\n      endpoint\n    }]) => !this.mapping.has(endpoint || `${section}_${method}`)).reduce((exposed, [method, {\n      endpoint\n    }]) => {\n      const def = methods[method];\n      const isSubscription = !!def.pubsub;\n      const jsonrpc = endpoint || `${section}_${method}`;\n      this.mapping.set(jsonrpc, _objectSpread(_objectSpread({}, def), {}, {\n        isSubscription,\n        jsonrpc,\n        method,\n        section\n      })); // FIXME Remove any here\n      // To do so, remove `RpcInterfaceMethod` from './types.ts', and refactor\n      // every method inside this class to take:\n      // `<S extends keyof RpcInterface, M extends keyof RpcInterface[S]>`\n      // Not doing so, because it makes this class a little bit less readable,\n      // and leaving it as-is doesn't harm much\n\n      exposed[method] = isSubscription ? this._createMethodSubscribe(section, method, def) : this._createMethodSend(section, method, def);\n      return exposed;\n    }, {});\n  }\n\n  _memomize(creator) {\n    const memoized = (0, _util.memoize)(creator('scale'), {\n      getInstanceId: () => (0, _classPrivateFieldLooseBase2.default)(this, _instanceId)[_instanceId]\n    });\n    memoized.json = creator('json');\n    memoized.raw = creator('raw');\n    return memoized;\n  }\n\n  _createMethodSend(section, method, def) {\n    const rpcName = def.endpoint || `${section}_${method}`;\n    const hashIndex = def.params.findIndex(({\n      isHistoric\n    }) => isHistoric);\n    const cacheIndex = def.params.findIndex(({\n      isCached\n    }) => isCached);\n    let memoized = null; // execute the RPC call, doing a registry swap for historic as applicable\n\n    const callWithRegistry = async (outputAs, values) => {\n      const hash = hashIndex === -1 ? undefined : values[hashIndex];\n      const {\n        registry\n      } = hash && (0, _classPrivateFieldLooseBase2.default)(this, _getBlockRegistry)[_getBlockRegistry] ? await (0, _classPrivateFieldLooseBase2.default)(this, _getBlockRegistry)[_getBlockRegistry](hash) : {\n        registry: (0, _classPrivateFieldLooseBase2.default)(this, _registryDefault)[_registryDefault]\n      };\n\n      const params = this._formatInputs(registry, def, values);\n\n      const data = await this.provider.send(rpcName, params.map(param => param.toJSON()));\n      return outputAs === 'scale' ? this._formatOutput(registry, method, def, params, data) : registry.createType(outputAs === 'raw' ? 'Raw' : 'Json', data);\n    };\n\n    const creator = outputAs => (...values) => {\n      const isDelayed = hashIndex !== -1 && !!values[hashIndex] || cacheIndex !== -1 && !!values[cacheIndex];\n      return new _xRxjs.Observable(observer => {\n        callWithRegistry(outputAs, values).then(value => {\n          observer.next(value);\n          observer.complete();\n        }).catch(error => {\n          logErrorMessage(method, def, error);\n          observer.error(error);\n          observer.complete();\n        });\n        return () => {\n          var _memoized; // delete old results from cache\n\n\n          (_memoized = memoized) === null || _memoized === void 0 ? void 0 : _memoized.unmemoize(...values);\n        };\n      }).pipe((0, _operators.publishReplay)(1), // create a Replay(1)\n      isDelayed ? (0, _util2.refCountDelay)() // Unsubscribe after delay\n      : (0, _operators.refCount)());\n    };\n\n    memoized = this._memomize(creator);\n    return memoized;\n  } // create a subscriptor, it subscribes once and resolves with the id as subscribe\n\n\n  _createSubscriber({\n    paramsJson,\n    subName,\n    subType,\n    update\n  }, errorHandler) {\n    return new Promise((resolve, reject) => {\n      this.provider.subscribe(subType, subName, paramsJson, update).then(resolve).catch(error => {\n        errorHandler(error);\n        reject(error);\n      });\n    });\n  }\n\n  _createMethodSubscribe(section, method, def) {\n    const [updateType, subMethod, unsubMethod] = def.pubsub;\n    const subName = `${section}_${subMethod}`;\n    const unsubName = `${section}_${unsubMethod}`;\n    const subType = `${section}_${updateType}`;\n    let memoized = null;\n\n    const creator = outputAs => (...values) => {\n      return new _xRxjs.Observable(observer => {\n        // Have at least an empty promise, as used in the unsubscribe\n        let subscriptionPromise = Promise.resolve(null);\n\n        const registry = (0, _classPrivateFieldLooseBase2.default)(this, _registryDefault)[_registryDefault];\n\n        const errorHandler = error => {\n          logErrorMessage(method, def, error);\n          observer.error(error);\n        };\n\n        try {\n          const params = this._formatInputs(registry, def, values);\n\n          const paramsJson = params.map(param => param.toJSON());\n\n          const update = (error, result) => {\n            if (error) {\n              logErrorMessage(method, def, error);\n              return;\n            }\n\n            try {\n              observer.next(outputAs === 'scale' ? this._formatOutput(registry, method, def, params, result) : registry.createType(outputAs === 'raw' ? 'Raw' : 'Json', result));\n            } catch (error) {\n              observer.error(error);\n            }\n          };\n\n          subscriptionPromise = this._createSubscriber({\n            paramsJson,\n            subName,\n            subType,\n            update\n          }, errorHandler);\n        } catch (error) {\n          errorHandler(error);\n        } // Teardown logic\n\n\n        return () => {\n          var _memoized2; // Delete from cache, so old results don't hang around\n\n\n          (_memoized2 = memoized) === null || _memoized2 === void 0 ? void 0 : _memoized2.unmemoize(...values); // Unsubscribe from provider\n\n          subscriptionPromise.then(subscriptionId => (0, _util.isNull)(subscriptionId) ? Promise.resolve(false) : this.provider.unsubscribe(subType, unsubName, subscriptionId)).catch(error => logErrorMessage(method, def, error));\n        };\n      }).pipe((0, _util2.drr)());\n    };\n\n    memoized = this._memomize(creator);\n    return memoized;\n  }\n\n  _formatInputs(registry, def, inputs) {\n    const reqArgCount = def.params.filter(({\n      isOptional\n    }) => !isOptional).length;\n    const optText = reqArgCount === def.params.length ? '' : ` (${def.params.length - reqArgCount} optional)`;\n    (0, _util.assert)(inputs.length >= reqArgCount && inputs.length <= def.params.length, `Expected ${def.params.length} parameters${optText}, ${inputs.length} found instead`);\n    return inputs.map((input, index) => (0, _create.createTypeUnsafe)(registry, def.params[index].type, [input]));\n  }\n\n  _formatOutput(registry, method, rpc, params, result) {\n    if (rpc.type === 'StorageData') {\n      const key = params[0];\n      return this._formatStorageData(registry, key, result);\n    } else if (rpc.type === 'StorageChangeSet') {\n      const keys = params[0];\n      return keys ? this._formatStorageSet(registry, keys, result.changes) : registry.createType('StorageChangeSet', result);\n    } else if (rpc.type === 'Vec<StorageChangeSet>') {\n      const mapped = result.map(({\n        block,\n        changes\n      }) => [registry.createType('Hash', block), this._formatStorageSet(registry, params[0], changes)]); // we only query at a specific block, not a range - flatten\n\n      return method === 'queryStorageAt' ? mapped[0][1] : mapped;\n    }\n\n    return (0, _create.createTypeUnsafe)(registry, rpc.type, [result]);\n  }\n\n  _formatStorageData(registry, key, value) {\n    const isEmpty = (0, _util.isNull)(value); // we convert to Uint8Array since it maps to the raw encoding, all\n    // data will be correctly encoded (incl. numbers, excl. :code)\n\n    const input = isEmpty ? null : isTreatAsHex(key) ? value : (0, _util.u8aToU8a)(value);\n    return this._newType(registry, key, input, isEmpty);\n  }\n\n  _formatStorageSet(registry, keys, changes) {\n    // For StorageChangeSet, the changes has the [key, value] mappings\n    const withCache = keys.length !== 1; // multiple return values (via state.storage subscription), decode the values\n    // one at a time, all based on the query types. Three values can be returned -\n    //   - Codec - There is a valid value, non-empty\n    //   - null - The storage key is empty\n\n    return keys.reduce((results, key, index) => {\n      results.push(this._formatStorageSetEntry(registry, key, changes, withCache, index));\n      return results;\n    }, []);\n  }\n\n  _formatStorageSetEntry(registry, key, changes, witCache, entryIndex) {\n    const hexKey = key.toHex();\n    const found = changes.find(([key]) => key === hexKey); // if we don't find the value, this is our fallback\n    //   - in the case of an array of values, fill the hole from the cache\n    //   - if a single result value, don't fill - it is not an update hole\n    //   - fallback to an empty option in all cases\n\n    const value = (0, _util.isUndefined)(found) ? witCache && (0, _classPrivateFieldLooseBase2.default)(this, _storageCache)[_storageCache].get(hexKey) || null : found[1];\n    const isEmpty = (0, _util.isNull)(value);\n    const input = isEmpty || isTreatAsHex(key) ? value : (0, _util.u8aToU8a)(value); // store the retrieved result - the only issue with this cache is that there is no\n    // clearing of it, so very long running processes (not just a couple of hours, longer)\n    // will increase memory beyond what is allowed.\n\n    (0, _classPrivateFieldLooseBase2.default)(this, _storageCache)[_storageCache].set(hexKey, value);\n\n    return this._newType(registry, key, input, isEmpty, entryIndex);\n  }\n\n  _newType(registry, key, input, isEmpty, entryIndex = -1) {\n    // single return value (via state.getStorage), decode the value based on the\n    // outputType that we have specified. Fallback to Raw on nothing\n    const type = key.outputType || 'Raw';\n    const meta = key.meta || EMPTY_META;\n    const entryNum = entryIndex === -1 ? '' : ` entry ${entryIndex}:`;\n\n    if (meta.modifier.isOptional) {\n      let inner = null;\n\n      if (!isEmpty) {\n        try {\n          inner = (0, _create.createTypeUnsafe)(registry, type, [input], {\n            isPedantic: true\n          });\n        } catch (error) {\n          l.error(`Unable to decode storage ${key.section || 'unknown'}.${key.method || 'unknown'}:${entryNum}`, error.message);\n        }\n      }\n\n      return new _types.Option(registry, (0, _create.createClass)(registry, type), inner);\n    }\n\n    try {\n      return (0, _create.createTypeUnsafe)(registry, type, [isEmpty ? meta.fallback ? (0, _util.hexToU8a)(meta.fallback.toHex()) : undefined : input], {\n        isPedantic: true\n      });\n    } catch (error) {\n      l.error(`Unable to decode storage ${key.section || 'unknown'}.${key.method || 'unknown'}:${entryNum}`, error.message);\n      return registry.createType('Raw', input);\n    }\n  }\n\n}\n\nexports.RpcCore = RpcCore;","map":{"version":3,"sources":["/Users/bmacer/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/rpc-core/index.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","RpcCore","_defineProperty2","_classPrivateFieldLooseBase2","_classPrivateFieldLooseKey2","_types","_create","_jsonrpc","_util","_xRxjs","_operators","_util2","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","default","getOwnPropertyDescriptors","defineProperties","l","logger","EMPTY_META","fallback","undefined","modifier","isOptional","type","asMap","linked","isTrue","isMap","logErrorMessage","method","params","error","inputs","map","name","join","message","isTreatAsHex","includes","toHex","_instanceId","_registryDefault","_getBlockRegistry","_storageCache","constructor","instanceId","registry","provider","userRpc","writable","Map","mapping","sections","author","babe","chain","childstate","contracts","engine","eth","grandpa","net","offchain","payment","rpc","state","syncstate","system","web3","assert","isFunction","send","sectionNames","addUserInterfaces","isConnected","connect","disconnect","setRegistrySwap","registrySwap","sectionName","_ref","_ref2","section","entries","_createInterface","methods","endpoint","has","reduce","exposed","def","isSubscription","pubsub","jsonrpc","set","_createMethodSubscribe","_createMethodSend","_memomize","creator","memoized","memoize","getInstanceId","json","raw","rpcName","hashIndex","findIndex","isHistoric","cacheIndex","isCached","callWithRegistry","outputAs","values","hash","_formatInputs","data","param","toJSON","_formatOutput","createType","isDelayed","Observable","observer","then","next","complete","catch","_memoized","unmemoize","pipe","publishReplay","refCountDelay","refCount","_createSubscriber","paramsJson","subName","subType","update","errorHandler","Promise","resolve","reject","subscribe","updateType","subMethod","unsubMethod","unsubName","subscriptionPromise","result","_memoized2","subscriptionId","isNull","unsubscribe","drr","reqArgCount","optText","input","index","createTypeUnsafe","_formatStorageData","_formatStorageSet","changes","mapped","block","isEmpty","u8aToU8a","_newType","withCache","results","_formatStorageSetEntry","witCache","entryIndex","hexKey","found","find","isUndefined","get","outputType","meta","entryNum","inner","isPedantic","Option","createClass","hexToU8a"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RpcCore = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _classPrivateFieldLooseBase2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseBase\"));\n\nvar _classPrivateFieldLooseKey2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseKey\"));\n\nvar _types = require(\"@polkadot/types\");\n\nvar _create = require(\"@polkadot/types/create\");\n\nvar _jsonrpc = _interopRequireDefault(require(\"@polkadot/types/interfaces/jsonrpc\"));\n\nvar _util = require(\"@polkadot/util\");\n\nvar _xRxjs = require(\"@polkadot/x-rxjs\");\n\nvar _operators = require(\"@polkadot/x-rxjs/operators\");\n\nvar _util2 = require(\"./util\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nconst l = (0, _util.logger)('rpc-core');\nconst EMPTY_META = {\n  fallback: undefined,\n  modifier: {\n    isOptional: true\n  },\n  type: {\n    asMap: {\n      linked: {\n        isTrue: false\n      }\n    },\n    isMap: false\n  }\n}; // utility method to create a nicely-formatted error\n\n/** @internal */\n\nfunction logErrorMessage(method, {\n  params,\n  type\n}, error) {\n  const inputs = params.map(({\n    isOptional,\n    name,\n    type\n  }) => `${name}${isOptional ? '?' : ''}: ${type}`).join(', ');\n  l.error(`${method}(${inputs}): ${type}:: ${error.message}`);\n}\n\nfunction isTreatAsHex(key) {\n  // :code is problematic - it does not have the length attached, which is\n  // unlike all other storage entries where it is indeed properly encoded\n  return ['0x3a636f6465'].includes(key.toHex());\n}\n/**\n * @name Rpc\n * @summary The API may use a HTTP or WebSockets provider.\n * @description It allows for querying a Polkadot Client Node.\n * WebSockets provider is recommended since HTTP provider only supports basic querying.\n *\n * ```mermaid\n * graph LR;\n *   A[Api] --> |WebSockets| B[WsProvider];\n *   B --> |endpoint| C[ws://127.0.0.1:9944]\n * ```\n *\n * @example\n * <BR>\n *\n * ```javascript\n * import Rpc from '@polkadot/rpc-core';\n * import { WsProvider } from '@polkadot/rpc-provider/ws';\n *\n * const provider = new WsProvider('ws://127.0.0.1:9944');\n * const rpc = new Rpc(provider);\n * ```\n */\n\n\nvar _instanceId = (0, _classPrivateFieldLooseKey2.default)(\"instanceId\");\n\nvar _registryDefault = (0, _classPrivateFieldLooseKey2.default)(\"registryDefault\");\n\nvar _getBlockRegistry = (0, _classPrivateFieldLooseKey2.default)(\"getBlockRegistry\");\n\nvar _storageCache = (0, _classPrivateFieldLooseKey2.default)(\"storageCache\");\n\nclass RpcCore {\n  // Ok, this is quite horrible - we really should not be using the ! here, but we are actually assigning\n  // these via the createInterfaces inside the constructor. However... this is not quite visible. The reason\n  // why we don't do for individual assignments is to allow user-defined RPCs to also be defined\n\n  /**\n   * @constructor\n   * Default constructor for the Api Object\n   * @param  {ProviderInterface} provider An API provider using HTTP or WebSocket\n   */\n  constructor(instanceId, registry, provider, userRpc = {}) {\n    Object.defineProperty(this, _instanceId, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _registryDefault, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _getBlockRegistry, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _storageCache, {\n      writable: true,\n      value: new Map()\n    });\n    this.mapping = new Map();\n    this.provider = void 0;\n    this.sections = [];\n    this.author = void 0;\n    this.babe = void 0;\n    this.chain = void 0;\n    this.childstate = void 0;\n    this.contracts = void 0;\n    this.engine = void 0;\n    this.eth = void 0;\n    this.grandpa = void 0;\n    this.net = void 0;\n    this.offchain = void 0;\n    this.payment = void 0;\n    this.rpc = void 0;\n    this.state = void 0;\n    this.syncstate = void 0;\n    this.system = void 0;\n    this.web3 = void 0;\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    (0, _util.assert)(provider && (0, _util.isFunction)(provider.send), 'Expected Provider to API create');\n    (0, _classPrivateFieldLooseBase2.default)(this, _instanceId)[_instanceId] = instanceId;\n    (0, _classPrivateFieldLooseBase2.default)(this, _registryDefault)[_registryDefault] = registry;\n    this.provider = provider;\n    const sectionNames = Object.keys(_jsonrpc.default); // these are the base keys (i.e. part of jsonrpc)\n\n    this.sections.push(...sectionNames);\n    this.addUserInterfaces(userRpc);\n  }\n  /**\n   * @description Returns the connected status of a provider\n   */\n\n\n  get isConnected() {\n    return this.provider.isConnected;\n  }\n  /**\n   * @description Manually connect from the attached provider\n   */\n\n\n  connect() {\n    return this.provider.connect();\n  }\n  /**\n   * @description Manually disconnect from the attached provider\n   */\n\n\n  disconnect() {\n    return this.provider.disconnect();\n  }\n  /**\n   * @description Sets a registry swap (typically from Api)\n   */\n\n\n  setRegistrySwap(registrySwap) {\n    (0, _classPrivateFieldLooseBase2.default)(this, _getBlockRegistry)[_getBlockRegistry] = registrySwap;\n  }\n\n  addUserInterfaces(userRpc) {\n    // add any extra user-defined sections\n    this.sections.push(...Object.keys(userRpc).filter(key => !this.sections.includes(key))); // decorate the sections with base and user methods\n\n    this.sections.forEach(sectionName => {\n      var _ref, _ref2;\n\n      (_ref = this)[_ref2 = sectionName] || (_ref[_ref2] = {});\n      const section = this[sectionName];\n      Object.entries(_objectSpread(_objectSpread({}, this._createInterface(sectionName, _jsonrpc.default[sectionName] || {})), this._createInterface(sectionName, userRpc[sectionName] || {}))).forEach(([key, value]) => {\n        section[key] || (section[key] = value);\n      });\n    });\n  }\n\n  _createInterface(section, methods) {\n    return Object.entries(methods).filter(([method, {\n      endpoint\n    }]) => !this.mapping.has(endpoint || `${section}_${method}`)).reduce((exposed, [method, {\n      endpoint\n    }]) => {\n      const def = methods[method];\n      const isSubscription = !!def.pubsub;\n      const jsonrpc = endpoint || `${section}_${method}`;\n      this.mapping.set(jsonrpc, _objectSpread(_objectSpread({}, def), {}, {\n        isSubscription,\n        jsonrpc,\n        method,\n        section\n      })); // FIXME Remove any here\n      // To do so, remove `RpcInterfaceMethod` from './types.ts', and refactor\n      // every method inside this class to take:\n      // `<S extends keyof RpcInterface, M extends keyof RpcInterface[S]>`\n      // Not doing so, because it makes this class a little bit less readable,\n      // and leaving it as-is doesn't harm much\n\n      exposed[method] = isSubscription ? this._createMethodSubscribe(section, method, def) : this._createMethodSend(section, method, def);\n      return exposed;\n    }, {});\n  }\n\n  _memomize(creator) {\n    const memoized = (0, _util.memoize)(creator('scale'), {\n      getInstanceId: () => (0, _classPrivateFieldLooseBase2.default)(this, _instanceId)[_instanceId]\n    });\n    memoized.json = creator('json');\n    memoized.raw = creator('raw');\n    return memoized;\n  }\n\n  _createMethodSend(section, method, def) {\n    const rpcName = def.endpoint || `${section}_${method}`;\n    const hashIndex = def.params.findIndex(({\n      isHistoric\n    }) => isHistoric);\n    const cacheIndex = def.params.findIndex(({\n      isCached\n    }) => isCached);\n    let memoized = null; // execute the RPC call, doing a registry swap for historic as applicable\n\n    const callWithRegistry = async (outputAs, values) => {\n      const hash = hashIndex === -1 ? undefined : values[hashIndex];\n      const {\n        registry\n      } = hash && (0, _classPrivateFieldLooseBase2.default)(this, _getBlockRegistry)[_getBlockRegistry] ? await (0, _classPrivateFieldLooseBase2.default)(this, _getBlockRegistry)[_getBlockRegistry](hash) : {\n        registry: (0, _classPrivateFieldLooseBase2.default)(this, _registryDefault)[_registryDefault]\n      };\n\n      const params = this._formatInputs(registry, def, values);\n\n      const data = await this.provider.send(rpcName, params.map(param => param.toJSON()));\n      return outputAs === 'scale' ? this._formatOutput(registry, method, def, params, data) : registry.createType(outputAs === 'raw' ? 'Raw' : 'Json', data);\n    };\n\n    const creator = outputAs => (...values) => {\n      const isDelayed = hashIndex !== -1 && !!values[hashIndex] || cacheIndex !== -1 && !!values[cacheIndex];\n      return new _xRxjs.Observable(observer => {\n        callWithRegistry(outputAs, values).then(value => {\n          observer.next(value);\n          observer.complete();\n        }).catch(error => {\n          logErrorMessage(method, def, error);\n          observer.error(error);\n          observer.complete();\n        });\n        return () => {\n          var _memoized;\n\n          // delete old results from cache\n          (_memoized = memoized) === null || _memoized === void 0 ? void 0 : _memoized.unmemoize(...values);\n        };\n      }).pipe((0, _operators.publishReplay)(1), // create a Replay(1)\n      isDelayed ? (0, _util2.refCountDelay)() // Unsubscribe after delay\n      : (0, _operators.refCount)());\n    };\n\n    memoized = this._memomize(creator);\n    return memoized;\n  } // create a subscriptor, it subscribes once and resolves with the id as subscribe\n\n\n  _createSubscriber({\n    paramsJson,\n    subName,\n    subType,\n    update\n  }, errorHandler) {\n    return new Promise((resolve, reject) => {\n      this.provider.subscribe(subType, subName, paramsJson, update).then(resolve).catch(error => {\n        errorHandler(error);\n        reject(error);\n      });\n    });\n  }\n\n  _createMethodSubscribe(section, method, def) {\n    const [updateType, subMethod, unsubMethod] = def.pubsub;\n    const subName = `${section}_${subMethod}`;\n    const unsubName = `${section}_${unsubMethod}`;\n    const subType = `${section}_${updateType}`;\n    let memoized = null;\n\n    const creator = outputAs => (...values) => {\n      return new _xRxjs.Observable(observer => {\n        // Have at least an empty promise, as used in the unsubscribe\n        let subscriptionPromise = Promise.resolve(null);\n\n        const registry = (0, _classPrivateFieldLooseBase2.default)(this, _registryDefault)[_registryDefault];\n\n        const errorHandler = error => {\n          logErrorMessage(method, def, error);\n          observer.error(error);\n        };\n\n        try {\n          const params = this._formatInputs(registry, def, values);\n\n          const paramsJson = params.map(param => param.toJSON());\n\n          const update = (error, result) => {\n            if (error) {\n              logErrorMessage(method, def, error);\n              return;\n            }\n\n            try {\n              observer.next(outputAs === 'scale' ? this._formatOutput(registry, method, def, params, result) : registry.createType(outputAs === 'raw' ? 'Raw' : 'Json', result));\n            } catch (error) {\n              observer.error(error);\n            }\n          };\n\n          subscriptionPromise = this._createSubscriber({\n            paramsJson,\n            subName,\n            subType,\n            update\n          }, errorHandler);\n        } catch (error) {\n          errorHandler(error);\n        } // Teardown logic\n\n\n        return () => {\n          var _memoized2;\n\n          // Delete from cache, so old results don't hang around\n          (_memoized2 = memoized) === null || _memoized2 === void 0 ? void 0 : _memoized2.unmemoize(...values); // Unsubscribe from provider\n\n          subscriptionPromise.then(subscriptionId => (0, _util.isNull)(subscriptionId) ? Promise.resolve(false) : this.provider.unsubscribe(subType, unsubName, subscriptionId)).catch(error => logErrorMessage(method, def, error));\n        };\n      }).pipe((0, _util2.drr)());\n    };\n\n    memoized = this._memomize(creator);\n    return memoized;\n  }\n\n  _formatInputs(registry, def, inputs) {\n    const reqArgCount = def.params.filter(({\n      isOptional\n    }) => !isOptional).length;\n    const optText = reqArgCount === def.params.length ? '' : ` (${def.params.length - reqArgCount} optional)`;\n    (0, _util.assert)(inputs.length >= reqArgCount && inputs.length <= def.params.length, `Expected ${def.params.length} parameters${optText}, ${inputs.length} found instead`);\n    return inputs.map((input, index) => (0, _create.createTypeUnsafe)(registry, def.params[index].type, [input]));\n  }\n\n  _formatOutput(registry, method, rpc, params, result) {\n    if (rpc.type === 'StorageData') {\n      const key = params[0];\n      return this._formatStorageData(registry, key, result);\n    } else if (rpc.type === 'StorageChangeSet') {\n      const keys = params[0];\n      return keys ? this._formatStorageSet(registry, keys, result.changes) : registry.createType('StorageChangeSet', result);\n    } else if (rpc.type === 'Vec<StorageChangeSet>') {\n      const mapped = result.map(({\n        block,\n        changes\n      }) => [registry.createType('Hash', block), this._formatStorageSet(registry, params[0], changes)]); // we only query at a specific block, not a range - flatten\n\n      return method === 'queryStorageAt' ? mapped[0][1] : mapped;\n    }\n\n    return (0, _create.createTypeUnsafe)(registry, rpc.type, [result]);\n  }\n\n  _formatStorageData(registry, key, value) {\n    const isEmpty = (0, _util.isNull)(value); // we convert to Uint8Array since it maps to the raw encoding, all\n    // data will be correctly encoded (incl. numbers, excl. :code)\n\n    const input = isEmpty ? null : isTreatAsHex(key) ? value : (0, _util.u8aToU8a)(value);\n    return this._newType(registry, key, input, isEmpty);\n  }\n\n  _formatStorageSet(registry, keys, changes) {\n    // For StorageChangeSet, the changes has the [key, value] mappings\n    const withCache = keys.length !== 1; // multiple return values (via state.storage subscription), decode the values\n    // one at a time, all based on the query types. Three values can be returned -\n    //   - Codec - There is a valid value, non-empty\n    //   - null - The storage key is empty\n\n    return keys.reduce((results, key, index) => {\n      results.push(this._formatStorageSetEntry(registry, key, changes, withCache, index));\n      return results;\n    }, []);\n  }\n\n  _formatStorageSetEntry(registry, key, changes, witCache, entryIndex) {\n    const hexKey = key.toHex();\n    const found = changes.find(([key]) => key === hexKey); // if we don't find the value, this is our fallback\n    //   - in the case of an array of values, fill the hole from the cache\n    //   - if a single result value, don't fill - it is not an update hole\n    //   - fallback to an empty option in all cases\n\n    const value = (0, _util.isUndefined)(found) ? witCache && (0, _classPrivateFieldLooseBase2.default)(this, _storageCache)[_storageCache].get(hexKey) || null : found[1];\n    const isEmpty = (0, _util.isNull)(value);\n    const input = isEmpty || isTreatAsHex(key) ? value : (0, _util.u8aToU8a)(value); // store the retrieved result - the only issue with this cache is that there is no\n    // clearing of it, so very long running processes (not just a couple of hours, longer)\n    // will increase memory beyond what is allowed.\n\n    (0, _classPrivateFieldLooseBase2.default)(this, _storageCache)[_storageCache].set(hexKey, value);\n\n    return this._newType(registry, key, input, isEmpty, entryIndex);\n  }\n\n  _newType(registry, key, input, isEmpty, entryIndex = -1) {\n    // single return value (via state.getStorage), decode the value based on the\n    // outputType that we have specified. Fallback to Raw on nothing\n    const type = key.outputType || 'Raw';\n    const meta = key.meta || EMPTY_META;\n    const entryNum = entryIndex === -1 ? '' : ` entry ${entryIndex}:`;\n\n    if (meta.modifier.isOptional) {\n      let inner = null;\n\n      if (!isEmpty) {\n        try {\n          inner = (0, _create.createTypeUnsafe)(registry, type, [input], {\n            isPedantic: true\n          });\n        } catch (error) {\n          l.error(`Unable to decode storage ${key.section || 'unknown'}.${key.method || 'unknown'}:${entryNum}`, error.message);\n        }\n      }\n\n      return new _types.Option(registry, (0, _create.createClass)(registry, type), inner);\n    }\n\n    try {\n      return (0, _create.createTypeUnsafe)(registry, type, [isEmpty ? meta.fallback ? (0, _util.hexToU8a)(meta.fallback.toHex()) : undefined : input], {\n        isPedantic: true\n      });\n    } catch (error) {\n      l.error(`Unable to decode storage ${key.section || 'unknown'}.${key.method || 'unknown'}:${entryNum}`, error.message);\n      return registry.createType('Raw', input);\n    }\n  }\n\n}\n\nexports.RpcCore = RpcCore;"]},"metadata":{},"sourceType":"script"}