{"ast":null,"code":"// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { isU8a, logger, u8aToHex } from '@polkadot/util';\nimport { createClass } from \"./createClass.mjs\";\nconst l = logger('registry');\n\nfunction u8aHasValue(value) {\n  return value.some(v => !!v);\n} // With isPedantic, actually check that the encoding matches that supplied. This\n// is much slower, but verifies that we have the correct types defined\n\n\nfunction checkInstance(value, created) {\n  // the underlying type created.toRawType()\n  const rawType = created.toRawType(); // ignore bytes completely - this is probably a FIXME, since these are somewhat\n  // breaking for at least online queries - not quite sure wtf is going wrong here\n\n  if (rawType === 'Bytes') {\n    return;\n  } // the hex values for what we have\n\n\n  const inHex = u8aToHex(value);\n  const crHex = created.toHex(); // Check equality, based on some different approaches (as decoded)\n\n  const isEqual = inHex === crHex || // raw hex values, quick path\n  inHex === created.toHex(true) || // wrapped options\n  u8aToHex(value.reverse()) === crHex; // reverse (for numbers, which are BE)\n  // if the hex doesn't match and the value for both is non-empty, complain... bitterly\n\n  if (!isEqual && (u8aHasValue(value) || u8aHasValue(created.toU8a(true)))) {\n    l.warn(`${rawType}:: Input doesn't match output, received ${u8aToHex(value)}, created ${crHex}`);\n  }\n} // Initializes a type with a value. This also checks for fallbacks and in the cases\n// where isPedantic is specified (storage decoding), also check the format/structure\n\n\nfunction initType(registry, Type, params = [], isPedantic) {\n  const created = new Type(registry, ...params); // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\n  const [value] = params;\n\n  if (isPedantic && isU8a(value)) {\n    checkInstance(value, created);\n  }\n\n  return created;\n} // An unsafe version of the `createType` below. It's unsafe because the `type`\n// argument here can be any string, which, when it cannot parse, will yield a\n// runtime error.\n\n\nexport function createTypeUnsafe(registry, type, params = [], {\n  withoutLog\n} = {}) {\n  try {\n    // Circle back to isPedantic when it handles all cases 100% - as of now,\n    // it provides false warning which is more hinderance than help\n    return initType(registry, createClass(registry, type), params); // , isPedantic);\n  } catch (error) {\n    !withoutLog && l.error(error);\n    throw new Error(`createType(${type}):: ${error.message}`);\n  }\n}\n/**\n * Create an instance of a `type` with a given `params`.\n * @param type - A recognizable string representing the type to create an\n * instance from\n * @param params - The value to instantiate the type with\n */\n\nexport function createType(registry, type, ...params) {\n  return createTypeUnsafe(registry, type, params);\n}","map":{"version":3,"sources":["/Users/bmacer/substrate-node-template/substrate-front-end-template/node_modules/@polkadot/types/create/createType.mjs"],"names":["isU8a","logger","u8aToHex","createClass","l","u8aHasValue","value","some","v","checkInstance","created","rawType","toRawType","inHex","crHex","toHex","isEqual","reverse","toU8a","warn","initType","registry","Type","params","isPedantic","createTypeUnsafe","type","withoutLog","error","Error","message","createType"],"mappings":"AAAA;AACA;AACA,SAASA,KAAT,EAAgBC,MAAhB,EAAwBC,QAAxB,QAAwC,gBAAxC;AACA,SAASC,WAAT,QAA4B,mBAA5B;AACA,MAAMC,CAAC,GAAGH,MAAM,CAAC,UAAD,CAAhB;;AAEA,SAASI,WAAT,CAAqBC,KAArB,EAA4B;AAC1B,SAAOA,KAAK,CAACC,IAAN,CAAWC,CAAC,IAAI,CAAC,CAACA,CAAlB,CAAP;AACD,C,CAAC;AACF;;;AAGA,SAASC,aAAT,CAAuBH,KAAvB,EAA8BI,OAA9B,EAAuC;AACrC;AACA,QAAMC,OAAO,GAAGD,OAAO,CAACE,SAAR,EAAhB,CAFqC,CAEA;AACrC;;AAEA,MAAID,OAAO,KAAK,OAAhB,EAAyB;AACvB;AACD,GAPoC,CAOnC;;;AAGF,QAAME,KAAK,GAAGX,QAAQ,CAACI,KAAD,CAAtB;AACA,QAAMQ,KAAK,GAAGJ,OAAO,CAACK,KAAR,EAAd,CAXqC,CAWN;;AAE/B,QAAMC,OAAO,GAAGH,KAAK,KAAKC,KAAV,IAAmB;AACnCD,EAAAA,KAAK,KAAKH,OAAO,CAACK,KAAR,CAAc,IAAd,CADM,IACiB;AACjCb,EAAAA,QAAQ,CAACI,KAAK,CAACW,OAAN,EAAD,CAAR,KAA8BH,KAF9B,CAbqC,CAeA;AACrC;;AAEA,MAAI,CAACE,OAAD,KAAaX,WAAW,CAACC,KAAD,CAAX,IAAsBD,WAAW,CAACK,OAAO,CAACQ,KAAR,CAAc,IAAd,CAAD,CAA9C,CAAJ,EAA0E;AACxEd,IAAAA,CAAC,CAACe,IAAF,CAAQ,GAAER,OAAQ,2CAA0CT,QAAQ,CAACI,KAAD,CAAQ,aAAYQ,KAAM,EAA9F;AACD;AACF,C,CAAC;AACF;;;AAGA,SAASM,QAAT,CAAkBC,QAAlB,EAA4BC,IAA5B,EAAkCC,MAAM,GAAG,EAA3C,EAA+CC,UAA/C,EAA2D;AACzD,QAAMd,OAAO,GAAG,IAAIY,IAAJ,CAASD,QAAT,EAAmB,GAAGE,MAAtB,CAAhB,CADyD,CACV;;AAE/C,QAAM,CAACjB,KAAD,IAAUiB,MAAhB;;AAEA,MAAIC,UAAU,IAAIxB,KAAK,CAACM,KAAD,CAAvB,EAAgC;AAC9BG,IAAAA,aAAa,CAACH,KAAD,EAAQI,OAAR,CAAb;AACD;;AAED,SAAOA,OAAP;AACD,C,CAAC;AACF;AACA;;;AAGA,OAAO,SAASe,gBAAT,CAA0BJ,QAA1B,EAAoCK,IAApC,EAA0CH,MAAM,GAAG,EAAnD,EAAuD;AAC5DI,EAAAA;AAD4D,IAE1D,EAFG,EAEC;AACN,MAAI;AACF;AACA;AACA,WAAOP,QAAQ,CAACC,QAAD,EAAWlB,WAAW,CAACkB,QAAD,EAAWK,IAAX,CAAtB,EAAwCH,MAAxC,CAAf,CAHE,CAG8D;AACjE,GAJD,CAIE,OAAOK,KAAP,EAAc;AACd,KAACD,UAAD,IAAevB,CAAC,CAACwB,KAAF,CAAQA,KAAR,CAAf;AACA,UAAM,IAAIC,KAAJ,CAAW,cAAaH,IAAK,OAAME,KAAK,CAACE,OAAQ,EAAjD,CAAN;AACD;AACF;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,UAAT,CAAoBV,QAApB,EAA8BK,IAA9B,EAAoC,GAAGH,MAAvC,EAA+C;AACpD,SAAOE,gBAAgB,CAACJ,QAAD,EAAWK,IAAX,EAAiBH,MAAjB,CAAvB;AACD","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { isU8a, logger, u8aToHex } from '@polkadot/util';\nimport { createClass } from \"./createClass.mjs\";\nconst l = logger('registry');\n\nfunction u8aHasValue(value) {\n  return value.some(v => !!v);\n} // With isPedantic, actually check that the encoding matches that supplied. This\n// is much slower, but verifies that we have the correct types defined\n\n\nfunction checkInstance(value, created) {\n  // the underlying type created.toRawType()\n  const rawType = created.toRawType(); // ignore bytes completely - this is probably a FIXME, since these are somewhat\n  // breaking for at least online queries - not quite sure wtf is going wrong here\n\n  if (rawType === 'Bytes') {\n    return;\n  } // the hex values for what we have\n\n\n  const inHex = u8aToHex(value);\n  const crHex = created.toHex(); // Check equality, based on some different approaches (as decoded)\n\n  const isEqual = inHex === crHex || // raw hex values, quick path\n  inHex === created.toHex(true) || // wrapped options\n  u8aToHex(value.reverse()) === crHex; // reverse (for numbers, which are BE)\n  // if the hex doesn't match and the value for both is non-empty, complain... bitterly\n\n  if (!isEqual && (u8aHasValue(value) || u8aHasValue(created.toU8a(true)))) {\n    l.warn(`${rawType}:: Input doesn't match output, received ${u8aToHex(value)}, created ${crHex}`);\n  }\n} // Initializes a type with a value. This also checks for fallbacks and in the cases\n// where isPedantic is specified (storage decoding), also check the format/structure\n\n\nfunction initType(registry, Type, params = [], isPedantic) {\n  const created = new Type(registry, ...params); // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\n  const [value] = params;\n\n  if (isPedantic && isU8a(value)) {\n    checkInstance(value, created);\n  }\n\n  return created;\n} // An unsafe version of the `createType` below. It's unsafe because the `type`\n// argument here can be any string, which, when it cannot parse, will yield a\n// runtime error.\n\n\nexport function createTypeUnsafe(registry, type, params = [], {\n  withoutLog\n} = {}) {\n  try {\n    // Circle back to isPedantic when it handles all cases 100% - as of now,\n    // it provides false warning which is more hinderance than help\n    return initType(registry, createClass(registry, type), params); // , isPedantic);\n  } catch (error) {\n    !withoutLog && l.error(error);\n    throw new Error(`createType(${type}):: ${error.message}`);\n  }\n}\n/**\n * Create an instance of a `type` with a given `params`.\n * @param type - A recognizable string representing the type to create an\n * instance from\n * @param params - The value to instantiate the type with\n */\n\nexport function createType(registry, type, ...params) {\n  return createTypeUnsafe(registry, type, params);\n}"]},"metadata":{},"sourceType":"module"}